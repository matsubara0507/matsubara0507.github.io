<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>ひげメモ</title>
    <link href="https://matsubara0507.github.io/feed.xml" rel="self" />
    <link href="https://matsubara0507.github.io" />
    <id>https://matsubara0507.github.io/feed.xml</id>
    <author>
        <name>MATSUBARA Nobutada</name>
        <email></email>
    </author>
    <updated>2018-10-28T00:00:00Z</updated>
    <entry>
    <title>GHC 8.6 がインストールできなかった</title>
    <link href="https://matsubara0507.github.io/posts/2018-10-28-ghc-8-6-error-no-gmp.html" />
    <id>https://matsubara0507.github.io/posts/2018-10-28-ghc-8-6-error-no-gmp.html</id>
    <published>2018-10-28T00:00:00Z</published>
    <updated>2018-10-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">GHC 8.6 がインストールできなかった</h1>
    <p class="post-meta">
      <time datetime="2018-10-28" itemprop="datePublished">
        Oct 28, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>対したことではないんだけど，日本語の記事が無っかたのでメモ． ちなみに OS は macOS Sierra (10.12.6) です．</p>
<h2 id="ghc-8.6-でビルドできない">GHC 8.6 でビルドできない</h2>
<p>現在 stackage の Nightly は最新の GHC バージョンである 8.6 がインストールされる． 結構パッケージも揃ってきたので，自分のパッケージもビルドしてみようかなと思って，resolver を Nightly に変えて <code>stack build</code> したら下記のようなエラーが出た．</p>
<pre class="shell"><code>$ stack build
Downloaded nightly-2018-10-26 build plan.    
Preparing to install GHC to an isolated location.
This will not interfere with any system-level installation.
Downloaded ghc-8.6.1.                                      
Installing GHC ...                                                                         
Received ExitFailure 2 when running
Raw command: /usr/bin/make install
Run from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/</code></pre>
<p><code>--vebose</code> を付けて詳細を見てみる．</p>
<pre class="shell"><code>$ stack build --verbose
Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0
2018-10-28 13:31:22.068195: [debug] Checking for project config at: /Users/username/git/haskell/servant-kotlin/stack.yaml
2018-10-28 13:31:22.069706: [debug] Loading project config file stack.yaml
 .
 .
 .
2018-10-28 13:32:21.355443: [debug] /Library/Developer/CommandLineTools/usr/bin/ranlib: file: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/lib/ghc-8.6.1/rts/libHSrts_thr_p.a(Select.thr_p_o) has no symbols
2018-10-28 13:32:21.621133: [debug] &quot;utils/ghc-cabal/dist-install/build/tmp/ghc-cabal-bindist&quot; copy libraries/ghc-prim dist-install &quot;strip&quot; &#39;&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/lib/ghc-8.6.1&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/share/doc/ghc-8.6.1/html/libraries&#39; &#39;v p dyn&#39;  
2018-10-28 13:32:21.841900: [debug] dyld: Library not loaded: /usr/local/opt/gmp/lib/libgmp.10.dylib
2018-10-28 13:32:21.842003: [debug]   Referenced from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/libraries/base/dist-install/build/libHSbase-4.12.0.0-ghc8.6.1.dylib
2018-10-28 13:32:21.842062: [debug]   Reason: image not found
2018-10-28 13:32:21.842273: [debug] make[1]: *** [install_packages] Abort trap: 6
2018-10-28 13:32:21.844303: [debug] make: *** [install] Error 2
Installing GHC ...
Received ExitFailure 2 when running
Raw command: /usr/bin/make install
Run from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/</code></pre>
<p>どうやら <code>/usr/local/opt/gmp/lib/libgmp.10.dylib</code> が無いみたいだ．</p>
<pre class="shell"><code>$ ls /usr/local/opt/gmp/lib/libgmp.10.dylib
ls: /usr/local/opt/gmp/lib/libgmp.10.dylib: No such file or directory</code></pre>
<p>これで検索すると，Ruby に関することだが <a href="https://stackoverflow.com/questions/34912946">StackOverflow があった</a>． 曰く，<code>gmp</code> パッケージを入れれば良いらしい（多くの人は他のどこかのタイミングで入ってるのかも）．</p>
<pre class="shell"><code>$ brew reinstall gmp
==&gt; Reinstalling gmp
==&gt; Downloading https://homebrew.bintray.com/bottles/gmp-6.1.2_2.sierra.bottle.tar.gz
######################################################################## 100.0%
==&gt; Pouring gmp-6.1.2_2.sierra.bottle.tar.gz
🍺  /usr/local/Cellar/gmp/6.1.2_2: 18 files, 3.1MB

$ ls /usr/local/opt/gmp/lib/libgmp.10.dylib
/usr/local/opt/gmp/lib/libgmp.10.dylib</code></pre>
<p>これで GHC 8.6 で <code>stack build</code> できるようになった．</p>
<h2 id="おしまい">おしまい</h2>
<p>まぁ一応ね，一応メモした．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>stack-templates を集める with GraphQL</title>
    <link href="https://matsubara0507.github.io/posts/2018-10-14-collect-stack-templates.html" />
    <id>https://matsubara0507.github.io/posts/2018-10-14-collect-stack-templates.html</id>
    <published>2018-10-14T00:00:00Z</published>
    <updated>2018-10-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">stack-templates を集める with GraphQL</h1>
    <p class="post-meta">
      <time datetime="2018-10-14" itemprop="datePublished">
        Oct 14, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/GraphQL.html">GraphQL</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Haskell Day の仕込みパート1です(2があるかは知らない)． stack の次期バージョン v1.9 で追加される namespaced template を試してみました．</p>
<p>ちなみに，現在 v1.9 はプレリリースになったので，下記コマンドで簡単にアップデートできます．</p>
<pre><code>$ stack upgrade --binary-version 1.9.0.1</code></pre>
<h2 id="namespaced-template">namespaced template</h2>
<p><code>stack new</code> で指定できるテンプレートを，GitHub などのオンラインからも取ってこれるようになった機能． 詳しくは開発段階からキャッチアップしてる e-bigmoon さんの記事を読むと良い．</p>
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html">namespaced templates - BIGMOON haskellers blog</a></li>
</ul>
<h3 id="作ってみた">作ってみた</h3>
<p>GitHub などで <code>stack-templates</code> という名前のリポジトリを作り，<code>hsfiles</code> という拡張子のテンプレートファイルをトップレベルに置く． 今回ぼくは <a href="https://github.com/matsubara0507/stack-templates">matsubara0507/stack-templates</a> というリポジトリを作り，２つ程作ってみた．</p>
<ul>
<li><code>get-opt-cli.hsfiles</code> : <a href="http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html"><code>System.Console.GetOpt</code></a> を用いたCLIのテンプレート</li>
<li><code>optparse-applicative-cli.hsfiles</code> : <a href="http://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> を用いたCLIのテンプレート</li>
</ul>
<p>どちらも，よくCLIを作るときの書き方をテンプレートとして起こしたもの． 普段は <a href="http://hackage.haskell.org/package/rio">rio</a> と <a href="http://hackage.haskell.org/package/extensible">extensible</a> を使っているので，単純に optparse-applicative などを使ったテンプレートという訳でもない．</p>
<h3 id="テストする">テストする</h3>
<p>できれば，テンプレートを <code>stack new</code> して <code>stack build</code> した時点ではコンパイルを通ってほしい． ということで <code>stack new</code> して <code>stack build</code> を試してくれるテストを <a href="https://github.com/matsubara0507/stack-templates/blob/7abc95184241c2df9f81ec1a45f9a662a98db05a/.travis.yml">TravisCI</a> に書いた．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">matrix:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">-</span> <span class="fu">env:</span><span class="at"> TEMPLATE=&quot;get-opt-cli&quot; ARGS=&quot;--resolver lts-12&quot;</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="fu">compiler:</span><span class="at"> </span><span class="st">&quot;: #stack 8.4.3&quot;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="fu">addons:</span><span class="at"> </span><span class="kw">{</span><span class="fu">apt:</span><span class="at"> </span><span class="kw">{</span><span class="fu">packages:</span><span class="at"> </span><span class="kw">[</span>libgmp-dev<span class="kw">]}}</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="kw">-</span> <span class="fu">env:</span><span class="at"> TEMPLATE=&quot;optparse-applicative-cli&quot; ARGS=&quot;--resolver lts-12&quot;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    <span class="fu">compiler:</span><span class="at"> </span><span class="st">&quot;: #stack 8.4.3&quot;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="fu">addons:</span><span class="at"> </span><span class="kw">{</span><span class="fu">apt:</span><span class="at"> </span><span class="kw">{</span><span class="fu">packages:</span><span class="at"> </span><span class="kw">[</span>libgmp-dev<span class="kw">]}}</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="fu">before_install:</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co"># install stack</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="fu">install:</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="kw">-</span> stack new sample <span class="st">&quot;./$TEMPLATE&quot;</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="kw">-</span> |</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  set -ex</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  cd sample</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  stack --no-terminal --install-ghc $ARGS test --bench --only-dependencies</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">  set +ex</a>
<a class="sourceLine" id="cb2-20" data-line-number="20"><span class="fu">script:</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21"><span class="kw">-</span> |</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">  set -ex</a>
<a class="sourceLine" id="cb2-23" data-line-number="23">  stack --no-terminal $ARGS test --bench --no-run-benchmarks --no-haddock-deps</a>
<a class="sourceLine" id="cb2-24" data-line-number="24">  set +ex</a></code></pre></div>
<p><a href="https://github.com/commercialhaskell/stack-templates/blob/879f95dc44b24201bc64fcf8f4b9e2192c23dad4/test-templates.hs">commercialhaskell/stack-templates でもテストは書いてある</a>がぼくのはすごいシンプルだ．</p>
<h2 id="stack-templates-を集める">stack-templates を集める</h2>
<p>さて，これだけでは完全に e-bigmoon さんの劣化記事だ． なので，stack-templates を GitHub から集めてくる CLI ツールを作ることにした．</p>
<p>試したところ，GitHub の検索で <code>stack-template in:name</code> と検索すれば，それなりにヒットすることがわかった(間違いも多いが)． なので，ざっくりとした手順は:</p>
<ol type="1">
<li>検索系の GitHub API を叩く</li>
<li>stack-templates という名前のリポジトリの <code>*.hsfiles</code> というファイルだけ抽出</li>
<li>それらを出力</li>
</ol>
<p>ここで GitHub API v3 (RESTful API)を利用すると，リポジトリのファイル群を取得するのに検索系の API を叩いてから，各リポジトリの API を叩く必要がある． それは面倒だ． なので，ここ数年注目を集めている(？) GraphQL API (GitHub API v4)を試してみることにした．</p>
<h3 id="graphql">GraphQL</h3>
<p>ちょうどこの前に，友人から「GraphQL はいいぞ，API をなんども叩く必要がない．」と紹介されたので試してみた．</p>
<p>GitHub の API では <code>api.github.com/graphql</code> というエンドポイントに対し，POST メソッドでクエリを送信する．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">curl</span> \</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  -H <span class="st">&quot;Authorization: bearer token&quot;</span> \</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  -X POST \</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  -d <span class="st">&quot;{ </span><span class="dt">\&quot;</span><span class="st">query</span><span class="dt">\&quot;</span><span class="st">: </span><span class="dt">\&quot;</span><span class="st"> ... </span><span class="dt">\&quot;</span><span class="st"> }&quot;</span> \</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  https://api.github.com/graphql</a></code></pre></div>
<p><code>...</code> のところにクエリを記述する． クエリは簡単な DSL のようになっており，クエリによってどんな形の JSON が返ってくるか(型のようなもの)やどんな値が返ってくるかが決まる． 例えば <code>stack-template in:name</code> 検索してヒットしたリポジトリの名前だけを取得してみよう． その場合は次のようなクエリを書く．</p>
<pre><code>query{
  search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 2) {
    repositoryCount,
    edges{
      node{ ... on Repository{ nameWithOwner } }
    }
  }
}</code></pre>
<p><code>first</code> は検索にヒットした最初の2つを返すという意味． 上限は 100 で，<code>first</code> ないしは逆の意味の <code>last</code> のどちらかは指定をする必要がある(そういうエラーが返ってくる)． <code>repositoryCount</code> は検索でヒットしたリポジトリの総数で，<code>edges</code> のところはリポジトリの <code>nameWithOwner</code> を返すように指定している． このように <code>{}</code> の中ではカンマ区切りで，返す JSON の形を指定できる． 具体的に何が指定できるかは <a href="https://developer.github.com/v4/query/">GitHub API v4 のドキュメント</a>を見ると良い． 試しに curl で叩いてみる(クエリ内の <code>&quot;</code> をエスケープすることを忘れずに):</p>
<pre><code>$ curl -H &quot;Authorization: bearer XXX&quot; -X POST -d &quot;{ \&quot;query\&quot;: \&quot; ... \&quot; }&quot; https://api.github.com/graphql
{&quot;data&quot;:{&quot;search&quot;:{&quot;repositoryCount&quot;:76,&quot;edges&quot;:[{&quot;node&quot;:{&quot;nameWithOwner&quot;:&quot;Azure/AzureStack-QuickStart-Templates&quot;}},{&quot;node&quot;:{&quot;nameWithOwner&quot;:&quot;commercialhaskell/stack-templates&quot;}}]}}}</code></pre>
<p>Connection とか Fields とかの用語については自分もよくわかってないので自分で調べてください． 今のところ，雰囲気で使ってる(笑)</p>
<h3 id="ファイルを集める">ファイルを集める</h3>
<p>さて，前述した結果(リポジトリ名)だけが欲しいなら GitHub API v3 でも十分だ． さらに，ファイルも取得してみよう． <a href="https://developer.github.com/v4/object/repository/">Repository のドキュメント</a> を眺めると <code>object</code> という Field がある． 察するに，リポジトリの任意のブランチ(<code>expression</code> で指定したもの)のコミットオブジェクトを返してくれるのだろう． (たぶん)stack-templates は全部 master が前提なので，master のコミットオブジェクトを取ってくる．</p>
<pre><code>... on Repository{
  nameWithOwner,
  object(expression:&quot;master&quot;){
    ... on Commit { }
  }
}</code></pre>
<p>ちなみに <code>... on Commit</code> というのは Inline Fragments と呼ばれるもので，object の型(サブタイプ？)が <code>Commit</code> だった場合に <code>Commit{}</code> 以下の Field を返すそうだ． git オブジェクトなので他にも <code>Tree</code> や <code>Blob</code> がある．</p>
<p>さて，あとは git オブジェクトの知識があれば簡単にかける． コミットオブジェクトにはツリーオブジェクト，要するにトップレベルのディレクトリのハッシュが記載されているので<a href="https://developer.github.com/v4/object/commit/">ドキュメント</a>からそれっぽいのを見つける． ツリーオブジェクトには，そのディレクトリに含まれるブロブオブジェクト(ファイル)とツリーオブジェクト(ディレクトリ)のハッシュが記載されてる． stack-templates は(今のところ)トップレベルに <code>*.hsfiles</code> を置かないといけないので，トップレベルのオブジェクトたちの名前を取得しよう:</p>
<pre><code>... on Repository{
  nameWithOwner,
  object(expression:&quot;master&quot;){
    ... on Commit { tree{ entries{ name, type } } }
  }
}</code></pre>
<p><code>type</code> には <code>blob</code> やら <code>tree</code> やらが入る． これで，検索にヒットした全てのリポジトリから <code>master</code> のトップレベルにあるファイルを取得するクエリが出来上がった．</p>
<h3 id="ページネーション">ページネーション</h3>
<p>今のところ，検索にヒットするリポジトリ数は76個なので <code>first: 100</code> とすれば全て取得できるが，今後ヒット数が100を超えたときようにページネーションの仕組みを整えておく． やり方は簡単で，<code>search</code> Connection のところで <a href=""><code>pageInfo</code></a> という Field を追加する．</p>
<pre><code>search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 1) {
  repositoryCount,
  pageInfo{
    endCursor,
    hasNextPage
  },
  edges{
    node{ ... on Repository{ .... } }
  }
}</code></pre>
<p><code>hasNextPage</code> は次のページが存在するかどうかを真偽値で返してくれる． <code>endCursor</code> はこのページの最後を表すハッシュ値？で，<code>search</code> Connection の引数(<code>type</code> とか <code>first</code> とかのとこ)に <code>after</code> で指定することで，それ以降の結果を取ってくる． このような <code>pageInfo</code> の情報さえあれば，プログラム内でループさせることは容易だろう．</p>
<h3 id="まとめると">まとめると</h3>
<p>次のようなクエリになった:</p>
<pre><code>query{
  search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 100) {
    repositoryCount,
    pageInfo{
      endCursor,
      hasNextPage
    },
    edges{
      node{ ... on Repository{
        nameWithOwner,
        object(expression:&quot;master&quot;){
          ... on Commit { tree{ entries{ name, type } } }
        }
      } }
    }
  }
}</code></pre>
<p>これを curl の引数に与えて叩くだけで 100 個分のリポジトリの全てのトップレベルファイル群を取得できる．</p>
<h3 id="stack-tpls">stack-tpls</h3>
<p>実際に作った CLI ツールは <a href="https://github.com/matsubara0507/stack-tpls"><code>matsubara0507/stack-tpls</code></a> というリポジトリに置いてある． 使い方は README に書いてある． 一覧を取得するには <code>stack-tpls --list</code> と打てば良い．</p>
<pre><code>$ stack-tpls --list
github:commercialhaskell/chrisdone.hsfiles
github:commercialhaskell/foundation.hsfiles
 .
 .
 .</code></pre>
<p>この結果を <code>stack new</code> の引数に与えることでそのまま利用できる． また，テンプレートの中身を確認したい場合は，<code>stack-tpls github:commercialhaskell/chrisdone.hsfiles</code> と引数に与えることで Raw を取ってきてくれる． リンクだけが欲しい場合は <code>--link</code> オプションを指定すると良い．</p>
<pre><code>$ stack-tpls --link github:commercialhaskell/rio.hsfiles
https://github.com/commercialhaskell/stack-templates/blob/master/rio.hsfiles</code></pre>
<h3 id="todo">ToDo</h3>
<p>一週間ほど前の思いつきからの突貫で作ったのでイロイロと抜けてる箇所があって:</p>
<ul>
<li>エラーハンドリングが雑</li>
<li>GitLab と BitBucket には対応していない</li>
<li>GraphQL の使い方がエレガントじゃない</li>
</ul>
<p>特に最後のがすごい気になっていて，現状は完全に文字列を埋め込んでいるだけなのだ． できれば，強力な型システムを利用した GitHub GraphQL Client ライブラリを作りたい(なんか昔に Haskell-jp で話題に上がったなぁ)．</p>
<h2 id="おしまい">おしまい</h2>
<p>GraphQL，クライアント側に取ってすごい便利．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell Servant で GitHub Webhook</title>
    <link href="https://matsubara0507.github.io/posts/2018-08-18-haskell-github-webhook.html" />
    <id>https://matsubara0507.github.io/posts/2018-08-18-haskell-github-webhook.html</id>
    <published>2018-08-18T00:00:00Z</published>
    <updated>2018-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell Servant で GitHub Webhook</h1>
    <p class="post-meta">
      <time datetime="2018-08-18" itemprop="datePublished">
        Aug 18, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/rio.html">rio</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>久々の投稿． とある事情で GitHub Webhook 用のサーバーを Haskell で書いたのでそのメモ書きです．</p>
<h2 id="やったこと">やったこと</h2>
<ul>
<li><a href="http://hackage.haskell.org/package/rio">rio</a> のロガーを Servant で使う</li>
<li><a href="http://hackage.haskell.org/package/servant-github-webhook">servant-github-webhook</a> を使って Webhook 用の Servant サーバーの構築</li>
</ul>
<p>実際に書いたコードは<a href="https://github.com/matsubara0507/git-plantation/commit/b93ed3398b30dbba105a580d58e947f131cf1a9a">この辺り</a>を見ると良いかな． 色々と途中のうえ，そもそも GitHub Webhook がメインではないリポジトリなので見にくい気がするけど．</p>
<h2 id="servant-で-rio-モナド">Servant で rio モナド</h2>
<p>これはまぁおまけですね． rio はロギングとかが便利なので，先に紹介して以降で利用する．</p>
<h3 id="ロガーの準備">ロガーの準備</h3>
<p>まずはロギング用のモナドを定義する．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds        #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeOperators    #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="ch">&#39;[ &quot;logger&quot; &gt;: LogFunc</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">   ]</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">HasLogFunc</span> <span class="dt">Env</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  logFuncL <span class="fu">=</span> lens (view <span class="fu">#</span>logger) (\x y <span class="ot">-&gt;</span> x <span class="fu">&amp;</span> <span class="fu">#</span>logger <span class="ot">`set`</span> y)</a></code></pre></div>
<p>いわゆる Has パターンというやつ． これで <code>RIO Env</code> というのがロガーを扱えるモナドとなる．</p>
<h3 id="servant-でカスタムモナド">Servant でカスタムモナド</h3>
<p>Servent Server のメイン関数は下記のように定義できる．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.Wai.Handler.Warp</span> <span class="kw">as</span> <span class="dt">Warp</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  logOpts <span class="ot">&lt;-</span> logOptionsHandle stdout <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  withLogFunc logOpts <span class="fu">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>logger <span class="fu">@=</span> logger</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">           <span class="fu">&lt;:</span><span class="ot"> nil ::</span> <span class="dt">Env</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    hPutBuilder stdout <span class="st">&quot;Listening on port 8080&quot;</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    Warp.run <span class="dv">8080</span> <span class="fu">$</span> app env</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">app <span class="fu">=</span> undefined</a></code></pre></div>
<p>さて，問題はこの <code>app</code> 関数だ． 普通は <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#t:Server"><code>Server</code></a> 型と <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#v:serve"><code>serve</code></a> 関数を用いて次のように書く．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">api <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">server <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="ot">app ::</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">app <span class="fu">=</span>  serve api server</a></code></pre></div>
<p><code>Server</code> 型の代わりに，カスタムモナドを利用するには <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#t:ServerT"><code>ServerT</code></a> 型と <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#v:hoistServer"><code>hoistServer</code></a> 関数を用いる． それぞれの型定義は次のようになっている．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Server</span> api <span class="fu">=</span> <span class="dt">ServerT</span> api <span class="dt">Handler</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">serve ::</span> <span class="dt">HasServer</span> api <span class="ch">&#39;[] =&gt; Proxy api -&gt; Server api -&gt; Application</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">hoistServer ::</span> <span class="dt">HasServer</span> api <span class="ch">&#39;[] =&gt; Proxy api -&gt; (forall x. m x -&gt; n x) -&gt; ServerT api m -&gt; ServerT api n</span></a></code></pre></div>
<p>さぁあとは型パズルだ！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">server <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">app env <span class="fu">=</span> serve api <span class="fu">$</span> hoistServer api (runRIO env) server</a></code></pre></div>
<p>これで　<code>server</code> 関数で呼び出す， API ごとの関数で <code>logInfo</code> のような rio のロギング関数を呼ぶことができる．</p>
<h2 id="servant-で-github-webhhok">Servant で GitHub Webhhok</h2>
<p>さて色々準備ができたので，いよいよ GitHub Webhook の方に話を移す． Haskell Servant で GitHub Webhook を使うには <a href="http://hackage.haskell.org/package/servant-github-webhook">servant-github-webhook</a>というパッケージを使う． 意外と，このパッケージの使い方を書いた記事がなく手間取ったのでまとめる．</p>
<h3 id="ping-api-を作る">ping API を作る</h3>
<p>ping API は GitHub Webhook の設定がうまくできてるかを確認する API だ．</p>
<p><img src="/assets/haskell-github-webhook/ping-event.jpg" /></p>
<p>ping API は次のように設定すれば良い．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">GitHub.Data.Webhooks.Events</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Servant.GitHub.Webhook</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;hook&quot;</span> <span class="fu">:&gt;</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">type</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      <span class="fu">=</span> <span class="dt">GitHubEvent</span> <span class="ch">&#39;[ &#39;</span><span class="dt">WebhookPingEvent</span> ]</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> <span class="ch">&#39;[JSON] PublicEvent</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        <span class="fu">:&gt;</span> <span class="dt">Post</span> <span class="ch">&#39;[JSON] ()</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">server <span class="fu">=</span> pingWebhook</a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="ot">pingWebhook ::</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">  <span class="dt">RepoWebhookEvent</span> <span class="ot">-&gt;</span> ((), <span class="dt">PublicEvent</span>) <span class="ot">-&gt;</span> <span class="dt">Plant</span> ()</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">pingWebhook _ (_, ev) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  logInfo <span class="fu">$</span> <span class="st">&quot;Hook Ping Event: &quot;</span> <span class="fu">&lt;&gt;</span> displayShow ev</a></code></pre></div>
<p>GitHub Webhook を使うには Servant の Context 機能でシークレットキーを渡す必要がある．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">System.Environment</span>       (getEnv)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    <span class="kw">let</span> key <span class="fu">=</span> gitHubKey <span class="fu">$</span> fromString <span class="fu">&lt;$&gt;</span> getEnv <span class="st">&quot;GH_SECRET&quot;</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    Warp.run <span class="dv">8080</span> <span class="fu">$</span> app env key</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span> <span class="dt">PublicEvent</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">app env key <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  serveWithContext api (key <span class="fu">:.</span> <span class="dt">EmptyContext</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    hoistServerWithContext api context (runRIO env) server</a>
<a class="sourceLine" id="cb7-13" data-line-number="13"></a>
<a class="sourceLine" id="cb7-14" data-line-number="14"><span class="ot">context ::</span> <span class="dt">Proxy</span> <span class="ch">&#39;[ GitHubKey PublicEvent ]</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">context <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>実行するときは <code>GH_SECRET</code> 環境変数に設定した文字列を GitHub Webhook の設定の Secret に書き込む．</p>
<h3 id="push-api-を加える">push API を加える</h3>
<p>もう一個 API を生やしてみよう．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">type</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">      <span class="fu">=</span> <span class="dt">GitHubEvent</span> <span class="ch">&#39;[ &#39;</span><span class="dt">WebhookPingEvent</span> ]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> <span class="ch">&#39;[JSON] PublicEvent</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">        <span class="fu">:&gt;</span> <span class="dt">Post</span> <span class="ch">&#39;[JSON] ()</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">   <span class="fu">:&lt;|&gt;</span> <span class="dt">GitHubEvent</span> <span class="ch">&#39;[ &#39;</span><span class="dt">WebhookPushEvent</span> ]</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> <span class="ch">&#39;[JSON] PushEvent</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        <span class="fu">:&gt;</span> <span class="dt">Post</span> <span class="ch">&#39;[JSON] ()</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">server <span class="fu">=</span> pingWebhook <span class="fu">:&lt;|&gt;</span> pushWebhook</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="ot">pushWebhook ::</span> <span class="dt">RepoWebhookEvent</span> <span class="ot">-&gt;</span> ((), <span class="dt">PushEvent</span>) <span class="ot">-&gt;</span> <span class="dt">Plant</span> ()</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">pushWebhook _ (_, ev) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">  logInfo <span class="fu">$</span> <span class="st">&quot;Hook Push Event: &quot;</span> <span class="fu">&lt;&gt;</span> displayShow ev</a></code></pre></div>
<p>これでビルドすると次のようなエラーが出てくる．</p>
<pre><code>Main.hs:38:3: error:
    • No instance for (HasContextEntry &#39;[] (GitHubKey&#39; () PushEvent))
        arising from a use of ‘serveWithContext’
    • In the expression: serveWithContext api (key :. EmptyContext)
      In the expression:
        serveWithContext api (key :. EmptyContext)
          $ hoistServerWithContext api context (runRIO env) server
      In an equation for ‘app’:
          app env key
            = serveWithContext api (key :. EmptyContext)
                $ hoistServerWithContext api context (runRIO env) server
   |
38 |   serveWithContext api (key :. EmptyContext) $ hoistServerWithContext api context (runRIO env) server
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
<p><a href="https://github.com/tsani/servant-github-webhook/issues/13#issuecomment-408463124">ググった結果</a>，こうするといいらしい．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Servant.GitHub.Webhook</span>    <span class="kw">hiding</span> (<span class="dt">GitHubKey</span>, gitHubKey)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Servant.GitHub.Webhook</span>   (<span class="dt">GitHubKey</span>, gitHubKey)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">app env key <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">context ::</span> <span class="dt">Proxy</span> <span class="ch">&#39;[ GitHubKey ]</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">context <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="co">-- HACK</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="kw">newtype</span> <span class="dt">GitHubKey</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">  <span class="dt">GitHubKey</span> (forall result<span class="fu">.</span> <span class="dt">Servant.GitHub.Webhook.GitHubKey</span> result)</a>
<a class="sourceLine" id="cb10-15" data-line-number="15"></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"><span class="ot">gitHubKey ::</span> <span class="dt">IO</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">gitHubKey k <span class="fu">=</span> <span class="dt">GitHubKey</span> (Servant.GitHub.Webhook.gitHubKey k)</a>
<a class="sourceLine" id="cb10-18" data-line-number="18"></a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="kw">instance</span> <span class="dt">HasContextEntry</span> <span class="ch">&#39;[GitHubKey] (Servant.GitHub.Webhook.GitHubKey result) where</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  getContextEntry (<span class="dt">GitHubKey</span> x <span class="fu">:.</span> _) <span class="fu">=</span> x</a></code></pre></div>
<h1 id="おしまい">おしまい</h1>
<p>ちなみに，手元で試すときには ngrok を使った． 便利．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Ruby Hack Challenge ＃4 に参加してきた</title>
    <link href="https://matsubara0507.github.io/posts/2018-07-01-join-ruby-hack-challenge4.html" />
    <id>https://matsubara0507.github.io/posts/2018-07-01-join-ruby-hack-challenge4.html</id>
    <published>2018-07-01T00:00:00Z</published>
    <updated>2018-07-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Ruby Hack Challenge ＃4 に参加してきた</h1>
    <p class="post-meta">
      <time datetime="2018-07-01" itemprop="datePublished">
        Jul 1, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Ruby.html">Ruby</a> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>先週 <a href="https://cookpad.connpass.com/event/88471/">Ruby Hack Cavalage #4</a> に参加してきたので，そのメモ書きです．</p>
<p>ちなみに，Ruby は自分が最初に触ったスクリプト言語で，現在仕事で使っているメインの言語です． 推し言語(Haskell)とは異なり，動的型付けではありますが，「<a href="http://i.loveruby.net/ja/rhg/book/">Rubyソースコード完全解説</a>」や「<a href="https://tatsu-zine.com/books/ruby-under-a-microscope-ja">Rubyのしくみ</a>」のような処理系内部を紹介してる読み物も多く，かなり好きな方な言語です.</p>
<h2 id="ruby-hack-challenge">Ruby Hack Challenge</h2>
<p>Ruby 処理系をハックしようというイベントで，コアコミッタの <a href="https://github.com/mame">mame</a> 氏と <a href="https://github.com/ko1">ko1</a> 氏が講師として企画してくれている． ふたりが在籍しているということで，会場はクックパッドで行っている．</p>
<p>毎回，前半に講義的なものがあり，後半で実際に手を動かして Ruby にコミットするといった感じらしい． ただし，2日開催だったり，半日だったり時間はまちまち(今回は半日だった)． イベント名的に Ruby のハッカソンみたいだが，Ruby 処理系はC言語で書かれているためC言語を書くことになる(笑)</p>
<h3 id="カバレッジ特別会">カバレッジ特別会</h3>
<p>しかし，4回目(となっているが3回目が見当たらないので3回目かも？？)となる今回は，カバレッジ特別会ということで多くの人たちが Ruby を読み書きしていた． なぜかというと，標準ライブラリは Ruby で書かれており，今回は標準ライブラリのテストカバレッジをあげても良かったからだ． というか，C で書かれているコア部分は mame 氏が昔に大分カバレッジをあげてしまったため，そっちをやるのは難しいと言っていた．</p>
<h2 id="section"></h2>
<p>C言語の部分で残っているとすれば本質的に難しい部分(副作用とか並行並列とか)か最近追加された部分か(JITとか？)だそうだ．</p>
<h3 id="資料">資料</h3>
<p>今までのも含め，資料は(いくつか？)公開されているので誰でも見れる．</p>
<ul>
<li><a href="https://github.com/ko1/rubyhackchallenge">ko1/rubyhackchallenge - GitHub</a></li>
<li><a href="https://www.slideshare.net/mametter/ruby-hack-challenge-4">Ruby Hack Challenge #4 カバレッジ特別回 資料 - SlideShare</a></li>
</ul>
<p>また Gitter で連絡を取り合っており，実は誰でも参加できる(たぶん)．</p>
<ul>
<li><a href="https://gitter.im/rubyhackchallenge/Lobby">rubyhackchallenge/Lobby - Gitter</a></li>
</ul>
<h2 id="section-1"></h2>
<p>ちなみに，ボクはもともとこのイベントは参加したいなぁと思っていた(言語好きなので)．</p>
<h2 id="ruby-のテストカバレッジ">Ruby のテストカバレッジ</h2>
<p>Ruby のテストカバレッジは Web から確認できる．</p>
<ul>
<li><a href="https://rubyci.s3.amazonaws.com/debian8-coverage/ruby-trunk/lcov/index.html">LCOV - code coverage report</a></li>
</ul>
<p>これを見てカバレッジの低いところにねらい目を付けてテストを追加する(ないしは不要な実装なら削る)． 標準ライブラリのいくつかは個別に GitHub で管理されているので，GitHub で管理されてる場合はそっちに PR を投げれば良いようだ(今回は事情が共有されてたせいかすぐマージされた)．</p>
<h2 id="section-2"></h2>
<p>ちなみに，<a href="https://github.com/ruby/ruby/blob/trunk/doc/maintainers.rdoc">ココ</a>を見ると誰がメンテナーで，どこに報告すれば良いかが書いてある．</p>
<h3 id="環境構築">環境構築</h3>
<p>は事前にやっとくと，当日はすんなりコミットできた(構築方法はスライドに書いてある)． 事前にって言ってもぼくは行きの電車でやったけど(笑)</p>
<p>Windows と Mac を持ってるけど，どっちも素でやるのは難しいので，Debian の Docker コンテナの上で構築した． Docker ありがとう！ ビルドがめっちゃ遅いけどね！</p>
<h2 id="当日やったこと">当日やったこと</h2>
<p>すっっっごい簡単にカバレッジをあげれそうなのがあったのサクッと直して PR をだした．</p>
<ul>
<li><a href="https://github.com/ruby/cmath/pull/2">Add test for coverage by matsubara0507 · Pull Request #2 · ruby/cmath</a></li>
</ul>
<p><code>CMath</code> モジュールは <code>Math</code> モジュールをラップして複素数(Complex number)にまで対応させたものだ． そのため，虚数を含む複素数に関するテストしかなく，実数に関するテストが無かったためカバレッジが低かった． 愚直に全部書いたら100%まで行きましたちゃんちゃんってだけです．</p>
<h2 id="section-3"></h2>
<p>ちなみに，他にも4,5個ほど PR が出ていた． すごいね！</p>
<h2 id="もくもく会">もくもく会</h2>
<p>あと，Ruby Hack Challenge もくもく会というのがあるらしいので行ってみたい(<a href="https://connpass.com/event/93131/">次回はこれ</a>)． MJIT のコードとか読んでみたいよね． それと型検査(はどうなるかまだ分からないらしいけど)．</p>
<h2 id="おしまい">おしまい</h2>
<p>そういえば，ko1 氏がお子さんと奥さんを連れてきていた(たぶん)． そういう事に理解のある会社っていいなぁと感じた．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>rust-reversi やってみた</title>
    <link href="https://matsubara0507.github.io/posts/2018-06-21-challenge-rust-reversi.html" />
    <id>https://matsubara0507.github.io/posts/2018-06-21-challenge-rust-reversi.html</id>
    <published>2018-06-21T00:00:00Z</published>
    <updated>2018-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">rust-reversi やってみた</h1>
    <p class="post-meta">
      <time datetime="2018-06-21" itemprop="datePublished">
        Jun 21, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Rust.html">Rust</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>現在，会社の同期と週一で Rust の勉強会をやっていまして，普段は <a href="https://y-yu.github.io/trpl-2nd-pdf/book.pdf">The Rust Programming Language: 2nd Edition の日本語版</a> を輪読しているのですが，3月ぐらいにあった <a href="https://internship.cookpad.com/2018/spring/">Cookpad Spring 1day Internship 2018</a> の Rust コースの資料が公開されたため，皆でハッカソンしてみました．</p>
<ul>
<li><a href="https://github.com/KOBA789/rust-reversi">KOBA789/rust-reversi: Cookpad Spring 1day Internship 2018 Rust プログラミングコースで使用された講義資料 - GitHub</a></li>
</ul>
<p>今回は実際にやってみてのメモ書きです． 主に躓いたとこのメモです．</p>
<h2 id="section"></h2>
<p>ちなみに，ぼくの Rust の経験値は上記の本を17章まで読んだだけで，ほとんど書いたことないですね(輪読は7章，自分で少し先を読んでいる)． あと，<a href="https://github.com/matsubara0507/rust-reversi/tree/reversi-impl">回答はフォークしてあげてあります</a>．</p>
<h3 id="躓いたところ">躓いたところ</h3>
<p>めちゃくちゃしょーーーーもないところばっかです(笑)</p>
<ol type="1">
<li>固定長配列の map</li>
<li>パターンマッチの変数</li>
<li>index の x と y が逆</li>
<li>既に置いてあるかの検査</li>
</ol>
<h3 id="何を作っているか">何を作っているか</h3>
<p>そもそも課題は何かというと，オセロ(リバーシ)です． 試しに実行してみるとこんな感じ．</p>
<pre><code>$ cargo run
   Compiling reversi v0.1.0 (file:///Users/nobutada.matsubara/git/rust/rust-reversi)
     Running `target/debug/reversi`
  a b c d e f g h
 +-+-+-+-+-+-+-+-+
1| | | | | | | | |
 +-+-+-+-+-+-+-+-+
2| | | | | | | | |
 +-+-+-+-+-+-+-+-+
3| | | | | | | | |
 +-+-+-+-+-+-+-+-+
4| | | |O|X| | | |
 +-+-+-+-+-+-+-+-+
5| | | |X|O| | | |
 +-+-+-+-+-+-+-+-+
6| | | | | | | | |
 +-+-+-+-+-+-+-+-+
7| | | | | | | | |
 +-+-+-+-+-+-+-+-+
8| | | | | | | | |
 +-+-+-+-+-+-+-+-+

B 2 - 2 W
Turn: Black
  a b c d e f g h
 +-+-+-+-+-+-+-+-+
1| | | | | | | | |
 +-+-+-+-+-+-+-+-+
2| | | | | | | | |
 +-+-+-+-+-+-+-+-+
3| | | | | | | | |
 +-+-+-+-+-+-+-+-+
4| | |X|X|X| | | |
 +-+-+-+-+-+-+-+-+
5| | | |X|O| | | |
 +-+-+-+-+-+-+-+-+
6| | | | | | | | |
 +-+-+-+-+-+-+-+-+
7| | | | | | | | |
 +-+-+-+-+-+-+-+-+
8| | | | | | | | |
 +-+-+-+-+-+-+-+-+

B 4 - 1 W
Turn: White
0) c3
1) c5
2) e3</code></pre>
<p>全部一から作れではなく，リポジトリをクローンして <code>src/coord.rs</code> と <code>src/board.rs</code> の <code>unimplemented!();</code> となっている個所の実装を与えるだけ． ご丁寧なことにテストも用意してあるので，<code>cargo test</code> を実行しまくってオールグリーンになれば出来上がり(たぶん)．</p>
<h2 id="section-1"></h2>
<p>ちなみに，クライアントの同期が <code>unimplemented();</code> に感動していたので，調子に乗って <a href="https://matthew.brecknell.net/post/hole-driven-haskell/">Hole driven Programming</a> について語ってしまった．</p>
<h3 id="関数が呼べない">0. 関数が呼べない</h3>
<p>ゼロ引数関数は <code>xxx.method</code> はダメで，<code>xxx.method()</code> しなきゃいけないってのが何度もあった(笑) 普段は Haskell を書いているせいですね．</p>
<h3 id="固定長配列の-map">1. 固定長配列の map</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">/// 指定の色の石を指定の位置に置いたとき、指定の方向へひっくり返せる石の数を返す</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">fn</span> get_flip(&amp;<span class="kw">self</span>, piece: Piece, <span class="kw">mut</span> pos: Coord, dir: Coord) -&gt; <span class="dt">u8</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    ...</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">/// 指定の色の石を指定の位置に置いたときの `Move` を返す</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co">/// 戻り値の `Move` には8方向分の `get_flip` の結果が含まれる</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">fn</span> get_move(&amp;<span class="kw">self</span>, piece: Piece, pos: Coord) -&gt; Move <span class="op">{</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    <span class="pp">unimplemented!</span>();</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="op">}</span></a></code></pre></div>
<p>とあり</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">pub</span> <span class="kw">struct</span> Move <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="kw">pub</span> pos: Coord,</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    flips: <span class="op">[</span><span class="dt">u8</span>; <span class="dv">8</span><span class="op">]</span>,</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">const</span> DIRECTIONS: <span class="op">[</span>Coord; <span class="dv">8</span><span class="op">]</span> = <span class="op">[</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    Coord(-<span class="dv">1</span>, -<span class="dv">1</span>), <span class="co">//左上</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    Coord(<span class="dv">0</span>, -<span class="dv">1</span>),  <span class="co">//真上</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    Coord(<span class="dv">1</span>, -<span class="dv">1</span>),  <span class="co">//右上</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    Coord(-<span class="dv">1</span>, <span class="dv">0</span>),  <span class="co">//真左</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    Coord(<span class="dv">1</span>, <span class="dv">0</span>),   <span class="co">//真右</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    Coord(-<span class="dv">1</span>, <span class="dv">1</span>),  <span class="co">//左下</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    Coord(<span class="dv">0</span>, <span class="dv">1</span>),   <span class="co">//真下</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    Coord(<span class="dv">1</span>, <span class="dv">1</span>),   <span class="co">//右下</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="op">]</span>;</a></code></pre></div>
<p>なので，<code>move.flips = DIRECTIONS.map (|dir| self.get_flip(piece, pos, dir))</code> って具合にいけそうだと思ったのだ． しかし，悲しいことに組み込みでは <strong>固定長配列に対するこのような操作はないようだ</strong>(間違っていたらゴメンナサイ…)． なので結局諦めて for 文を回した…</p>
<p>何か良い方法があったら教えて欲しい.</p>
<h3 id="パターンマッチの変数">2. パターンマッチの変数</h3>
<p>すごい間抜けな話です．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">/// 指定の色の石を指定の位置に置いたとき、指定の方向へひっくり返せる石の数を返す</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">///</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">/// * `piece` - 置く石の色</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">/// * `pos` - 石を置く位置</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">/// * `dir` - ひっくり返せる石を探す方向。`DIRECTIONS` の要素のいずれかが渡される</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="kw">fn</span> get_flip(&amp;<span class="kw">self</span>, piece: Piece, <span class="kw">mut</span> pos: Coord, dir: Coord) -&gt; <span class="dt">u8</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="kw">let</span> opponent = piece.opponent();</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="kw">let</span> <span class="kw">mut</span> cnt = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">        pos += dir;</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">        <span class="kw">match</span> <span class="kw">self</span>.matrix<span class="op">[</span>pos<span class="op">]</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">            <span class="cn">None</span>           =&gt; <span class="kw">return</span> <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">            <span class="cn">Some</span>(piece)    =&gt; <span class="kw">return</span> cnt,</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">            <span class="cn">Some</span>(opponent) =&gt; cnt += <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">        <span class="op">}</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17"><span class="op">}</span></a></code></pre></div>
<p>とか書いていたが，全然テストが通らない． それもそのはずで <strong>パターンマッチの中の変数は代入になる</strong> だけで，<code>if self.matrix[target] == Some(piece) { ... }</code> とは異なる． シャーディングぅぅぅぅぅとか思ったけど，きっと警告出てたよね…</p>
<pre><code>warning: unreachable pattern
   --&gt; src/board.rs:165:17
    |
165 |                 Some(opponent) =&gt; cnt += 1,
    |                 ^^^^^^^^^^^^^^
    |
    = note: #[warn(unreachable_patterns)] on by default

warning: unused variable: `opponent`
   --&gt; src/board.rs:158:13
    |
158 |         let opponent = piece.opponent();
    |             ^^^^^^^^ help: consider using `_opponent` instead
    |
    = note: #[warn(unused_variables)] on by default

warning: unused variable: `piece`
   --&gt; src/board.rs:164:22
    |
164 |                 Some(piece)    =&gt; return cnt,
    |                      ^^^^^ help: consider using `_piece` instead

warning: unused variable: `opponent`
   --&gt; src/board.rs:165:22
    |
165 |                 Some(opponent) =&gt; cnt += 1,
    |                      ^^^^^^^^ help: consider using `_opponent` instead</code></pre>
<p>出てたね…</p>
<h3 id="index-の-x-と-y-が逆">3. index の x と y が逆</h3>
<p>普段二重配列とかやんないからさ…</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">/// ベクトルを表現する構造体</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">pub</span> <span class="kw">struct</span> Coord(<span class="kw">pub</span> <span class="dt">i8</span>, <span class="kw">pub</span> <span class="dt">i8</span>);</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co">/// `[]` 演算子のオーバーロード</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">impl</span> Index&lt;Coord&gt; <span class="kw">for</span> Matrix <span class="op">{</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">type</span> Output = <span class="dt">Option</span>&lt;Piece&gt;;</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="co">/// 第一引数に与えられた座標の状態を返す</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="co">/// 座標が盤面の範囲外であった場合は None が返る。</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="kw">fn</span> index(&amp;<span class="kw">self</span>, index: Coord) -&gt; &amp;<span class="kw">Self</span>::Output <span class="op">{</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        <span class="kw">if</span> <span class="kw">self</span>.is_in_range(index) <span class="op">{</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">            &amp;<span class="kw">self</span>.<span class="dv">0</span><span class="op">[</span>index.<span class="dv">0</span> <span class="kw">as</span> <span class="dt">usize</span><span class="op">][</span>index.<span class="dv">1</span> <span class="kw">as</span> <span class="dt">usize</span><span class="op">]</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">            &amp;<span class="cn">None</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">        <span class="op">}</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    <span class="op">}</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16"><span class="op">}</span></a></code></pre></div>
<p>とか最初書いていた． <code>Coord</code> 型はひとつ目が X 座標でふたつ目が Y 座標． <code>&amp;self.0[index.0 as usize][index.1 as usize]</code> のところが逆ですね…</p>
<h3 id="既に置いてあるかの検査">4. 既に置いてあるかの検査</h3>
<p><code>moves</code> のテストが何故かとおらない． <code>moves</code> は盤上の全ての合法手，“手” を表す <code>Move</code> 型は手を打つ場所(<code>Coord</code> 型)と各方向のひっくり返す数を持っている，を列挙する関数．</p>
<pre><code>---- board::tests::test_board_moves stdout ----
	thread &#39;board::tests::test_board_moves&#39; panicked at &#39;assertion failed: `(left == right)`
  left: `6`,
 right: `37`&#39;, src/board.rs:366:9</code></pre>
<p>めちゃくちゃ多い． テストを読んでイロイロと出力させてみたところ，既にピースが置いてある場合のチェックを忘れていた(バカ)．</p>
<h3 id="オールグリーン">オールグリーン</h3>
<pre><code>$ cargo test
   Compiling reversi v0.1.0 (file:///Users/nobutada.matsubara/git/rust/rust-reversi)
    Finished dev [unoptimized + debuginfo] target(s) in 1.27 secs
     Running target/debug/deps/reversi-ae2013b8997f878b

running 12 tests
test board::tests::test_board_count_mut ... ok
test board::tests::test_board_get_move ... ok
test board::tests::test_board_get_flip ... ok
test board::tests::test_board_do_move ... ok
test board::tests::test_do_flip ... ok
test board::tests::test_matrix_index ... ok
test board::tests::test_board_moves ... ok
test board::tests::test_matrix_index_mut ... ok
test board::tests::test_matrix_is_in_range ... ok
test board::tests::test_move_is_legal ... ok
test coord::tests::test_coord_add ... ok
test coord::tests::test_coord_add_assign ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code></pre>
<h2 id="感想">感想</h2>
<p>基本構文を覚えてないので，とりあえず雑に書いてビルドして怒られたら直す，的なことをしながら，静的検査さいこ～とか言いながらやってた(疲れてる)． おかげで <code>&amp;</code> とか <code>*</code> を雑にあつかってて良くないですね． まぁ楽しかったからいいけど．</p>
<h2 id="おまけ">おまけ</h2>
<p><code>get_flip</code> 関数のところ，関数型プログラマーらしく(?)再帰にして見た. 速度は変わるんかな？</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">fn</span> get_flip(&amp;<span class="kw">self</span>, piece: Piece, pos: Coord, dir: Coord) -&gt; <span class="dt">u8</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="kw">self</span>.go_get_flip(piece, pos, dir).unwrap_or(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">fn</span> go_get_flip(&amp;<span class="kw">self</span>, piece: Piece, pos: Coord, dir: Coord) -&gt; <span class="dt">Option</span>&lt;<span class="dt">u8</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="kw">let</span> target = pos + dir;</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    <span class="kw">if</span> <span class="kw">self</span>.matrix<span class="op">[</span>target<span class="op">]</span> == <span class="cn">Some</span>(piece.opponent()) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">        <span class="kw">self</span>.go_get_flip(piece, target, dir).map(|x| x + <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="kw">self</span>.matrix<span class="op">[</span>target<span class="op">]</span> == <span class="cn">Some</span>(piece) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="cn">Some</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">        <span class="cn">None</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14"><span class="op">}</span></a></code></pre></div>
<h2 id="おしまい">おしまい</h2>
<p>Haskell 版でも作ってみようかしらん．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Earlang ＆ Elixir Fest 2018 に参加してきた</title>
    <link href="https://matsubara0507.github.io/posts/2018-06-18-join-elixir-festa-2108.html" />
    <id>https://matsubara0507.github.io/posts/2018-06-18-join-elixir-festa-2108.html</id>
    <published>2018-06-18T00:00:00Z</published>
    <updated>2018-06-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Earlang ＆ Elixir Fest 2018 に参加してきた</h1>
    <p class="post-meta">
      <time datetime="2018-06-18" itemprop="datePublished">
        Jun 18, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Elixir.html">Elixir</a> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>先日(6/16)，<a href="https://elixir-fest.jp/">Earlang &amp; Elixir Fest 2018</a> に参加してきたので，そのメモ書きです． ちなみに，Elixir は普段たいして使ってないけど LT もしてきました．</p>
<h4 id="追記2018.06.21">追記(2018.06.21)</h4>
<p>本稿公開後に公開してくださった発表スライドのリンクを追記しました．</p>
<h2 id="section"></h2>
<p>今年で2回目らしく，去年は Elixir の作者の <a href="https://twitter.com/josevalim">Jose Valim</a> 氏を呼んで Keynote してもらい，全体のセッション内容としては Elixir を導入し始めた・挑戦中という話がメインだったようだ． 今年はどっちかっていうとプロダクトに実践導入・運用してみてどうだったかという話がメインだそうだ． また，並行してハンズオンがあったらしいが，行ってないのでそっちは良く分からない． ハンズオンの資料は GitHub に公開してあるので，いずれやってみたい(同期とかとハンズオンしてみてもいいかも)．</p>
<ul>
<li><a href="https://github.com/ohr486/ErlangElixirFestHandsOn">ohr486/ErlangElixirFestHandsOn - GitHub</a></li>
</ul>
<p>あと <a href="https://togetter.com/li/1238110">Togetter にまとめてみました</a>．</p>
<h2 id="メモ">メモ</h2>
<p>各企業での導入した話が多かったので簡単なメモばっかです．</p>
<h4 id="らくらく連絡網が-elixir-でリアルタイムメッセージング基盤を刷新した話">「らくらく連絡網」が Elixir でリアルタイムメッセージング基盤を刷新した話</h4>
<p>(ネットワーク設定にバタバタしてたのでメモが少ない)</p>
<ul>
<li><a href="https://github.com/rinosamakanata">rinosamakanata</a> 氏の発表</li>
<li><a href="https://eole-repos.github.io/public/elixirfest/2018/elixirfest2018-eole-rinosamakanata.pdf">発表スライドはコチラ</a></li>
<li>もともとは RoR らしい</li>
<li>技術的課題
<ul>
<li>分散の問題</li>
<li>長い目で見たときの保守・運用</li>
</ul></li>
<li>フロントエンドは Elm
<ul>
<li>「関数型良いよね」</li>
</ul></li>
<li>負荷テストのために不可掛けの Docker コンテナを作った</li>
<li>Elixir のバージョンアップが多い(リリースしてから9回もあった)
<ul>
<li><a href="https://github.com/asdf-vm/asdf-elixir">asdf</a> で難なく</li>
<li>Ruby や RoR よりぜんぜん簡単</li>
</ul></li>
<li>実質的にメンテナンスフリー</li>
<li>Erlang は書けなくても導入できる
<ul>
<li>ただし BEAM の知識はいる</li>
<li><a href="https://github.com/happi/theBeamBook">The BEAM Book</a> おすすめ</li>
</ul></li>
</ul>
<p>最近 Ruby や Ruby のライブラリのバージョンアップで苦しんでいるのを見てたのでバージョンアップがシームレスなの羨ましい．</p>
<h4 id="初めてのerlangサーバ開発と運用">初めてのErlangサーバ開発と運用</h4>
<ul>
<li><a href="https://github.com/mookjp">mookjp</a> 氏の発表</li>
<li><a href="https://speakerdeck.com/mookjp/chu-metefalseerlangsahakai-fa-toyun-yong?slide=1">発表スライドはコチラ</a></li>
<li>Erlang をどう勉強したかや失敗談などの話</li>
<li>Node.js から Erlang へ (たぶん)</li>
<li><a href="http://erlang.org/doc/man/observer.html">observer</a> という Erlang プロセスの可視化ツールが便利</li>
<li>Erlang サーバーをプロダクションに導入するときの設定
<ul>
<li>思想の記事ばっか！</li>
<li>実際の設定に関する記事が少ない！！</li>
</ul></li>
<li>不必要なプロセスやその監視プロセスが微妙に残ってじわじわ CPU 使用率が上がってしまった</li>
<li><a href="https://www.erlang-in-anger.com/">Erlang in Anger</a> を絶対に読む
<ul>
<li>運用に役立ちそうなことがたくさん書いてある</li>
</ul></li>
<li><a href="https://erlang-slack.herokuapp.com/">Erlang の Slack ワークスペース</a>がおススメ！
<ul>
<li>紹介した監視の VMStats もここで教えてもらった</li>
</ul></li>
</ul>
<p>思想の記事が多い話，なんとなく Haskell にも似たようなところがあって笑った</p>
<h4 id="keep-phoenix-app-productivity">Keep Phoenix App Productivity</h4>
<ul>
<li><a href="https://twitter.com/kanmo_ak">kanmo_ak</a> 氏の発表</li>
<li><a href="https://speakerdeck.com/kanmo/keep-phoenix-app-productivity?slide=1">発表スライドはコチラ</a></li>
<li>Phoenix Application 開発1年・運用1年してみた結果の話</li>
<li><a href="https://elixirschool.com/en/lessons/advanced/umbrella-projects/">Umbrella</a> によって Project を分割
<ul>
<li>肥大化してきた</li>
<li>複数のサービスをひとつのリポジトリで別々に開発</li>
<li>サービス間でコードを共有できる</li>
</ul></li>
<li>ひとつのファイルを書き換えるだけでコンパイル対象が膨大…
<ul>
<li>ファイル間の依存関係がひどいので切っていく</li>
<li>マクロを変更するとやり直し</li>
<li>構造体を変更するとやばい</li>
<li>プロトコルも依存がある</li>
<li><a href="https://hexdocs.pm/mix/Mix.Tasks.Xref.html"><code>mix xref</code></a> タスクが便利</li>
<li>モジュール名を動的に組み立てて依存を無理やり切る黒魔術(使わない方がいい)</li>
</ul></li>
<li>Erlang プロセスだと remsh で起動中のプロセスに接続して調査できる</li>
<li>Elixir バージョンアップは追いやすい
<ul>
<li>RoR に比べて(笑)</li>
</ul></li>
<li>Type Spec を書いておくとドキュメントになる
<ul>
<li>Dializer は使ってない(時間が無かった)</li>
<li>spec ないとつらいと感じたの私自身です</li>
</ul></li>
</ul>
<p>昔 Type Spec が書いてあったが間違ってるおかげで痛い目にあったので書いたやつを静的にチェックしたいですよね…</p>
<h4 id="from-python-to-elixir">from Python to Elixir</h4>
<ul>
<li><a href="https://github.com/kenichirow">kenichirow</a> 氏の発表</li>
<li>Python から Elixir に移行
<ul>
<li>Python 2020 年問題(2系のサポートが終わる)</li>
</ul></li>
<li>Phoenix は最初は使わないつもりだった
<ul>
<li>Django からだと暗黙的な何某が多い印象(マクロ)</li>
<li>PubSub いらない</li>
<li>なので自作 FW を作ってた</li>
</ul></li>
<li>突然 Phoenix 宣言
<ul>
<li>「お前 Dis れるほど Phoenix 知ってるのかよ」</li>
</ul></li>
<li>Ecto にはいくつかの問題</li>
<li>なのでライブラリを作った <a href="https://github.com/gumi/yacto">Yacto</a>
<ul>
<li>DB分割・XAトランザクションなど</li>
</ul></li>
<li>各ゲームの基盤を Template にしていたがバージョン管理がつらいのでライブラリに</li>
<li>Elixir のサポートチーム
<ul>
<li>ググる前に聞け</li>
<li>最近しんどいので Stack Overflow Team を導入</li>
</ul></li>
<li>言語変えて解決した問題は少しだけ
<ul>
<li>ただ整備するきっかけにはなった</li>
</ul></li>
</ul>
<p>基盤チームカッコいい</p>
<h4 id="ステートフルで大規模アクセスのあるsoft-realtimeなゲームサーバーをeasyにつくる">ステートフルで大規模アクセスのあるsoft-realtimeなゲームサーバーをeasyにつくる</h4>
<ul>
<li><a href="https://github.com/ne-sachirou">さっちゃん</a> 氏の発表</li>
<li><a href="https://speakerdeck.com/ne_sachirou/sutetohurudeda-gui-mo-akusesufalsearusoft-realtimenagemusabawoeasynitukuru">発表スライドはコチラ</a></li>
<li>Phoenix でゲーム作って運用したはなし</li>
<li>AWS + Kube + Phoenix</li>
<li>Real time PvP がメインなのに RoR は大変</li>
<li>どっちみちイロイロ知見が無いので新しい技術使っても苦労はするでしょ
<ul>
<li>Elixir の知見はある</li>
</ul></li>
<li><a href="https://hexdocs.pm/inner_cotton/readme.html">InnerCotton</a> を作った</li>
<li>FP は知ってた</li>
<li>Channel と Redis で PvP</li>
<li>ホットデプロイはあきらめた</li>
<li>優先度付きキューを自作 <a href="https://hex.pm/packages/pqueue2">queue2</a>
<ul>
<li>既存のモノは間違ってるものが多かったので</li>
<li>スタックになっているものもあった</li>
</ul></li>
<li><a href="https://hub.docker.com/r/nesachirou/elixir/">docker image</a> を作った(Elixir と Erlang の両方が指定できる)</li>
<li>Elixir の監視つらい</li>
<li>もっと publish していこうぜ</li>
</ul>
<p>社内でやったことドンドン Publish できるのいいなぁ．</p>
<h4 id="channel先生-pubsubがしたいです">Channel先生…!! PubSubがしたいです…</h4>
<ul>
<li><a href="https://github.com/ohr486">ohrdev</a> 氏の発表</li>
<li><a href="https://speakerdeck.com/ohr486/erlangelixirfest2018-ohr486-session">発表スライドはコチラ</a></li>
<li>~Erlang in Anger~ PubSub in Channel</li>
<li>「PubSub しない Phoenix はただの Rails だ」</li>
<li>Phoenix Channel + PubSub</li>
<li>PubSub は2種類ある
<ul>
<li>ローカル PubSub ・リモート PubSub</li>
</ul></li>
<li>「これカッコよくないっすか、見るたびにすごいぞくぞくする」</li>
<li>PubSub バックエンドは選択できる</li>
<li>どれだけ知っといた方がいいか？
<ul>
<li>基本は知らなくても</li>
<li>新しい Adaptar を作る場合は知ってないといけない</li>
</ul></li>
</ul>
<p>PubSub 完全に理解した(嘘)</p>
<h4 id="antikythera-framework-an-elixir-framework-for-multiple-web-services">Antikythera Framework: An Elixir framework for multiple web services</h4>
<ul>
<li><a href="https://github.com/skirino">skirino</a> 氏の発表</li>
<li><a href="https://skirino.github.io/slides/antikythera_framework.html#/">発表スライドはコチラ</a></li>
<li>社内で作ったフレームワークの紹介 : <a href="https://github.com/access-company/antikythera">antikythera</a></li>
<li>Antikythera メカニズム
<ul>
<li>ギリシャ時代のオーパーツ</li>
<li>なにかよくわからない</li>
<li>星の動き？？</li>
</ul></li>
<li>複数のサービスをひとつのフレームワークで管理</li>
<li>Gear : Webサービスの単位・他の Gear に依存しうる
<ul>
<li>instance より細かい単位</li>
</ul></li>
<li>コア機能
<ul>
<li>リソースコントロール</li>
<li>自動オペレーション(ホットデプロイなど)</li>
<li>ログなどビルドインに</li>
</ul></li>
<li>Gear はマイクロサービスで疎結合だが管理は統一</li>
<li>リソース管理は ErlangVM なので一長一短</li>
<li>DB はどうするか？
<ul>
<li>DB は知らない(Gear にしない)</li>
<li>ふつうに Ecto とかで</li>
</ul></li>
<li>なぜ Erlang じゃないか？
<ul>
<li>mix が優秀</li>
<li>mix compiler でフックできる</li>
</ul></li>
</ul>
<p>mix すごいのはよくわかる．</p>
<h4 id="任意のbeam系言語でプラグインを書ける安定したフレームワークの作りかた">任意のBEAM系言語でプラグインを書ける安定したフレームワークの作りかた</h4>
<ul>
<li><a href="https://github.com/niku">niku</a> 氏の発表</li>
<li><a href="https://niku.name/2018/06/16/slide.html">発表スライドはコチラ</a></li>
<li>BEAM系プラグインを作る上でのノウハウ</li>
<li>また PubSub の話ですいません</li>
<li>フレームワークとプラグイン</li>
<li>プラグイン機構を持つ FW には登場人物が3人
<ul>
<li>フレームワークとプラグインを使う人</li>
</ul></li>
<li>プラグインでエラーが起きたときフレームワークはどうするか</li>
<li>「絵にかくとこんな感じ」</li>
<li>Supervisor は他の言語ではあまりない
<ul>
<li>こいつのおかげで別粒度間のプロセス管理が楽</li>
</ul></li>
<li>ゆかいに学ぼうの Supervisor の章は良くできている</li>
</ul>
<p>絵に書くとこんな感じってのがじわじわ来る．</p>
<h4 id="erlang-事例紹介-メディアストリーム中継システム">Erlang 事例紹介: メディアストリーム中継システム</h4>
<ul>
<li><a href="https://github.com/amutake">amutake</a> 氏の発表</li>
<li><a href="https://niconare.nicovideo.jp/watch/kn3115">発表スライドはコチラ</a>
<ul>
<li>ニコニコのスライド置き場あったんだ(笑)</li>
</ul></li>
<li>ニコ生で使われる(予定)のシステムの話(Erlang 製)</li>
<li>生放送の中継ツリー</li>
<li>生放送に求められる性質</li>
<li>ストリーム中継システム : sluicegate の作成
<ul>
<li>いつか OSS になる</li>
</ul></li>
<li>学術的に研究されたアルゴリズム(独自ではなく)
<ul>
<li>HyParView</li>
<li>Plumtree</li>
</ul></li>
<li>簡単にできるけど無駄にメッセージパッシングすると遅くなる
<ul>
<li>軽い処理をメッセージパッシングするとだめ</li>
</ul></li>
<li>Erlang クラスタは組まない</li>
<li>Plumtree の性質があれだった
<ul>
<li>なので自分たちで改造</li>
<li>根幹なので定理証明(Coq で実装)
<ul>
<li>PPLにて発表した</li>
<li>生放送ストリーム中継システムのCoqによる形式化と検証</li>
</ul></li>
</ul></li>
<li>ぱぶさぶくん(検証ツール)</li>
<li>水道局(可視化ツール)
<ul>
<li>水路という自作ライブラリを使っている</li>
</ul></li>
<li>分散アルゴリズムを書きやすい</li>
<li>調査しやすい
<ul>
<li>reduction の取得のしやすさは Erlang in Anger</li>
</ul></li>
<li>Coq のコードから Erlang に変換するものがある</li>
</ul>
<p>なんか研究の話聞いてるみたいで聞きやすかった(笑)</p>
<h3 id="lt">LT</h3>
<p>自分も LT したので細かいメモは無い</p>
<ul>
<li>NOC の話
<ul>
<li>朝にアクシデントがあったようで…</li>
</ul></li>
<li>個人で Elixir してきた話(日本一 Elixir 本を書いている)</li>
<li>Elixir 完全に理解した(ちょっとできる人がいればいい)</li>
<li>Elixir Programming with Type checking (自分)</li>
<li>ElixirScript の話</li>
<li>PubSub Redis
<ul>
<li>phoenix_pubusu_redis_z</li>
</ul></li>
<li>Dialyzer のすすめ</li>
<li>Erlang on ARM サーバー
<ul>
<li>未発表のもの</li>
<li>秒間40まんリクエストをさばいてる</li>
<li>ミドルウェアの世界に来い</li>
</ul></li>
</ul>
<p>どうやら MVP は「Elixirを2週間で完全に理解した」新卒の子．</p>
<h3 id="keynote">Keynote</h3>
<h4 id="共有からメッセージパッシングへ-erlangotpやelixirと歩んだこの10年">共有からメッセージパッシングへ: Erlang/OTPやElixirと歩んだこの10年</h4>
<ul>
<li><a href="https://twitter.com/jj1bdx">力武健次</a>氏</li>
<li><a href="https://speakerdeck.com/jj1bdx/erlang-and-elixir-fest-2018-keynote?slide=1">発表資料はコチラ</a></li>
<li>BIND ??? 脆弱性の多い DNS サーバーについて昔やってた
<ul>
<li>1000行マクロ</li>
</ul></li>
<li>Erlang に出会う
<ul>
<li>うるう秒の修正パッチを送る</li>
<li>SSH のセキュリティの研究</li>
</ul></li>
<li>ICFP’11 の Erlang Workshop の実行委員長</li>
<li>Erlang in Anger のサイン本もらった</li>
<li>Elixir のロゴは商標登録されている</li>
<li>Catalyze Changes
<ul>
<li>Erlang は読みにくい！</li>
<li>レコードが難しい！</li>
<li>ドキュメントがない！</li>
<li>何とかっしようぜ！</li>
<li>by Dave Tomas</li>
<li>大変だった…(jose)</li>
<li>有言実行しててElixir本を7冊も出版している</li>
</ul></li>
<li>Ruby コミュニティをちらほら見かけるようになった</li>
<li>2018/2 大事件</li>
<li><a href="https://codesync.global/conferences/code-beam-sf-2018/">Code BEAM 2018</a>
<ul>
<li>Open Erlang 20周年</li>
<li>BEAM コミュニティの融合</li>
</ul></li>
<li>共通してどこがおいしいのか</li>
<li>Immutability ディープコピー 参照を使わない
<ul>
<li>自分が思う Erlang のすばらしさ</li>
</ul></li>
<li>従来は実態を共有(はやい？)</li>
<li>「安全よりも効率」</li>
<li>C++ の愚痴
<ul>
<li>参照なの？値なの？</li>
<li>const の話が大変</li>
<li>コンストラクタいつ動く？？</li>
<li>shared_ptr と unique_ptr (参照カウンタと所有権)</li>
</ul></li>
<li>例外: ETSやプロセス辞書</li>
<li>「効率より安全」
<ul>
<li>とても遅い</li>
<li>型検査は無いけど非常に厳格</li>
</ul></li>
<li>Joe (Erlang の作者)「processes messgae and links が重要な部分(gen_server は後から)」
<ul>
<li>他はどうでもいい</li>
<li>軽量並行プロセスとエラーハンドリング</li>
</ul></li>
<li>綺麗に落とすのは大変
<ul>
<li>プロセスキューが詰まると終了</li>
</ul></li>
<li>link and monitor
<ul>
<li>昔のSDの自分の記事を読み返した</li>
</ul></li>
<li>今後
<ul>
<li>基本理念 「ほどほどなのが一番良い」</li>
<li>手を抜かずに高速化</li>
</ul></li>
<li>Code BEAM で話題にあがったもの
<ul>
<li>組込み分野えの応用</li>
<li>大規模クラスタ</li>
<li><a href="https://github.com/josefs/Gradualizer">Gradual Type System</a> (ツールの発表があった)</li>
<li>Language Server Protcol</li>
</ul></li>
<li>英語圏で発表しよう
<ul>
<li>Code BEAM 2018 は日本人一人</li>
</ul></li>
</ul>
<p>クライアントの同期の子が，不変性のすばらしさの話を指して「Rust や Elixir を勉強したとに同じことを感じた！」と喜んでいた．</p>
<h2 id="自分の話">自分の話</h2>
<p>Elchemy の紹介話をしてきました． スライドはこちら</p>
<h2 id="section-1"></h2>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/ocbuQdsbw2EmG5" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen>
</iframe>
<h2 id="section-2"></h2>
<p>実は前日(6/15)に別の LT で Elchemy の Docker image を作る話をしてきた． その時のスライドはこちら．</p>
<h2 id="section-3"></h2>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/al30fSfPGB5HGN" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen>
</iframe>
<h2 id="section-4"></h2>
<p>実は以下の記事でもっと詳しくまとめてあるので，プレゼンを見る必要は無いんです(笑)</p>
<ul>
<li><a href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html">Elchemy 入門 : その１</a></li>
<li><a href="https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html">Elchemy 入門 : その２</a></li>
</ul>
<h2 id="おしまい">おしまい</h2>
<p>来年はもっと型のハナシができるといいなぁ．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Elchemy 入門 : その２</title>
    <link href="https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html" />
    <id>https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html</id>
    <published>2018-06-16T00:00:00Z</published>
    <updated>2018-06-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Elchemy 入門 : その２</h1>
    <p class="post-meta">
      <time datetime="2018-06-16" itemprop="datePublished">
        Jun 16, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Elchemy.html">Elchemy</a> <a href="/tags/Elm.html">Elm</a> <a href="/tags/Elixir.html">Elixir</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Elm から Elixir のトランスパイラ，<a href="https://github.com/wende/elmchemy">Elchemy</a> についてイロイロと調べたのでまとめていきます． <a href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html">前回はコチラ</a>． 今回は</p>
<ul>
<li><a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-2-our-own-rpg-character-module-cedbf7da138d">Tutorial その２</a>をやってみた</li>
<li>Phoenix で ToDo アプリを作る</li>
</ul>
<p>の2本立てです． ちなみに，現在のバージョンは 0.7.4 です．</p>
<h2 id="tutorial-そのをやってみた">Tutorial その２をやってみた</h2>
<p>Tutorial その２では Elchemy を利用した独自ライブラリを作成する． 以下の手順で行うそうだ．</p>
<ol type="1">
<li>エイリアス型を定義</li>
<li>ユニオン型を定義</li>
<li>関数としてエイリアスやタグを用いる</li>
<li>ユニオン型でのパターンマッチ</li>
<li>関数として演算子を使う・独自の演算子を定義する</li>
<li>別のモジュールから型やエイリアス型をインポートする</li>
</ol>
<p>基本的に Elm の書き方講座みたいなものなので，最悪っ困ったら Elm を勉強してください(丸投げ)． ちなみに，元記事の全てを細かく追従せず，ざっくりと掻い摘んで書き出している． なので細かくは元記事を読んでね．</p>
<h2 id="section"></h2>
<p>あと，<a href="https://github.com/wende/elmchemy-article-example">このコードは全て作者さんが GitHub に挙げている</a>．</p>
<h3 id="その前に">その前に</h3>
<p>テストを書こう，ということでテストを Elixir で書いている． 今回の作成するライブラリはどうやら，ゲームか何かのキャラを制御する物らしい</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># character_test.exs</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">defmodule</span> <span class="cn">CharacterTest</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="im">use</span> <span class="cn">ExUnit</span><span class="op">.</span><span class="cn">Case</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="im">use</span> <span class="cn">Elchemy</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  test <span class="st">&quot;Character has name, last name and such&quot;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">      gordon <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>new(<span class="st">&quot;Gordon&quot;</span>, <span class="st">&quot;Freemonad&quot;</span>, <span class="va">:male</span>)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      assert gordon<span class="op">.</span>name <span class="op">==</span> <span class="st">&quot;Gordon&quot;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">      assert gordon<span class="op">.</span>surname <span class="op">==</span> <span class="st">&quot;Freemonad&quot;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">      assert gordon<span class="op">.</span>gender <span class="op">==</span> <span class="va">:male</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  test <span class="st">&quot;Has stats&quot;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    gordon <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>new(<span class="st">&quot;Gordon&quot;</span>, <span class="st">&quot;Freemonad&quot;</span>, <span class="va">:male</span>)</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    stats <span class="op">=</span> [<span class="va">:strength</span>, <span class="va">:intelligence</span>, <span class="va">:vitality</span>]</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    <span class="kw">for</span> s <span class="op">&lt;-</span> stats <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">      assert is_integer(gordon<span class="op">.</span>stats[s]), <span class="st">&quot;No </span><span class="ot">#{</span>s<span class="ot">}</span><span class="st"> stat in </span><span class="ot">#{</span>inspect gordon<span class="ot">}</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">    assert <span class="cn">Character</span><span class="op">.</span>set_stat(<span class="va">:vitality</span>, <span class="dv">10</span>, gordon)<span class="op">.</span>stats<span class="op">.</span>vitality <span class="op">==</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"></a>
<a class="sourceLine" id="cb1-25" data-line-number="25">  test <span class="st">&quot;Boosting visality boosts health&quot;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">    gordon <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>new(<span class="st">&quot;Gordon&quot;</span>, <span class="st">&quot;Freemonad&quot;</span>, <span class="va">:male</span>)</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">    { hp, packed_gordon_max } <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>set_stat(<span class="va">:vitality</span>, <span class="dv">10</span>, gordon)<span class="op">.</span>health</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">    { _, weak_gordon_max }    <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>set_stat(<span class="va">:vitality</span>, <span class="dv">0</span>, gordon)<span class="op">.</span>health</a>
<a class="sourceLine" id="cb1-30" data-line-number="30"></a>
<a class="sourceLine" id="cb1-31" data-line-number="31">    assert packed_gordon_max <span class="op">&gt;</span> weak_gordon_max</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">    assert hp <span class="op">==</span> packed_gordon_max</a>
<a class="sourceLine" id="cb1-33" data-line-number="33">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-34" data-line-number="34"></a>
<a class="sourceLine" id="cb1-35" data-line-number="35">  test <span class="st">&quot;Can equip weapon only if intelligence is enough&quot;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-36" data-line-number="36">    gordon <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>new(<span class="st">&quot;Gordon&quot;</span>, <span class="st">&quot;Freemonad&quot;</span>, <span class="va">:male</span>)</a>
<a class="sourceLine" id="cb1-37" data-line-number="37">    weapon <span class="op">=</span> <span class="cn">Weapon</span><span class="op">.</span>new(<span class="st">&quot;Sci fi blaster thingy&quot;</span>, <span class="dv">9</span> ,<span class="dv">100</span>)</a>
<a class="sourceLine" id="cb1-38" data-line-number="38"></a>
<a class="sourceLine" id="cb1-39" data-line-number="39">    dumb_gordon <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>set_stat(<span class="va">:intelligence</span>, <span class="dv">0</span>, gordon)</a>
<a class="sourceLine" id="cb1-40" data-line-number="40">    smart_gordon <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>set_stat(<span class="va">:intelligence</span>, <span class="dv">10</span>, gordon)</a>
<a class="sourceLine" id="cb1-41" data-line-number="41"></a>
<a class="sourceLine" id="cb1-42" data-line-number="42">    assert {<span class="va">:error</span>, <span class="st">&quot;Too dumb&quot;</span>} <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>equip(weapon, dumb_gordon)</a>
<a class="sourceLine" id="cb1-43" data-line-number="43">    assert {<span class="va">:ok</span>, equipped_gordon} <span class="op">=</span> <span class="cn">Character</span><span class="op">.</span>equip(weapon, smart_gordon)</a>
<a class="sourceLine" id="cb1-44" data-line-number="44">    assert equipped_gordon<span class="op">.</span>arm <span class="op">==</span> {weapon}</a>
<a class="sourceLine" id="cb1-45" data-line-number="45">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-46" data-line-number="46"><span class="kw">end</span></a></code></pre></div>
<h3 id="キャラクターを定義">キャラクターを定義</h3>
<h4 id="型エイリアス">1. 型エイリアス</h4>
<p>関数型なのでまずはドメインモデルの型を定義する． テストより，<code>name</code> <code>surname</code> <code>gender</code> をフィールドとして持っているのが分かるので次のような型を定義した．</p>
<pre class="elm"><code>module Character exposing (..)

type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    }</code></pre>
<p>何故エイリアスなのかというと，構造的サブタイピイングが出来るようにだと思う(たぶん)．</p>
<h4 id="ユニオン型">2. ユニオン型</h4>
<p><code>Gender</code> 型が無いので定義する． こっちは列挙型みたいなのが欲しいので、ユニオン型を用いる．</p>
<pre class="elm"><code>type Gender
    = Male
    | Female
    | Other</code></pre>
<h4 id="関数としての型エイリアス">3. 関数としての型エイリアス</h4>
<p>Elixir っぽい <code>new</code> 関数を定義してやろう． Elm の場合，エイリアス型を定義すれば同名の値コンストラクタができるので，それをラップすればよい</p>
<pre class="elm"><code>new : String -&gt; String -&gt; Gender -&gt; Character
new name surname gender =
    Character
      name
      surname
      gender</code></pre>
<h3 id="キャラクターにステータスを持たせる">キャラクターにステータスを持たせる</h3>
<p>キャラクターにいくつかのステータスを持たせよう．</p>
<pre class="elm"><code>type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    , health : (Int, Int)
    , stats : Stats
    }

type alias Stats =
    { strength : Int
    , intelligence : Int
    , vitality : Int
    }

new : String -&gt; String -&gt; Gender -&gt; Character
new name surname gender =
    Character
      name
      surname
      gender
      (100,100)
      (Stats 0 0 0)</code></pre>
<p><code>health</code> はどうやら HP みたいなものらしい(現在のHPと上限)．</p>
<h3 id="パターンマッチ">4. パターンマッチ</h3>
<p>ステータスを更新する関数を定義しよう．</p>
<pre class="elm"><code>type Stat
    = Strength
    | Intelligence
    | Vitality

setStat : Stat -&gt; Int -&gt; Character -&gt; Character
setStat stat value character =
    let
      stats = character.stats
    in
    case stat of
        Strength -&gt;
            { character | stats = { stats | strength = value } }
        Intelligence -&gt;
            { character | stats = { stats | intelligence = value } }
        Vitality -&gt;
            { character | stats = { stats | vitality = value } }        </code></pre>
<p>残念ながらこの <code>setStat</code> は正しくない． テストを見ればわかるが <code>Vitality</code> を更新した場合は <code>health</code> も更新する必要がある．</p>
<h4 id="演算子">5. 演算子</h4>
<p><code>health</code> はタプル型だ． タプルの更新をいい感じにするために，カスタム演算子を定義してみよう．</p>
<pre class="elm"><code>(&lt;$) : (a, b) -&gt; (a -&gt; c) -&gt; (c, b)
(&lt;$) tuple f = Tuple.mapFirst f tuple

($&gt;) : (a, b) -&gt; (b -&gt; c) -&gt; (a, c)
($&gt;) tuple f = Tuple.mapSecond f tuple</code></pre>
<p>これを使って <code>setStat</code> の <code>Vitality</code> の部分を正しく修正する．</p>
<pre class="elm"><code>setStat : Stat -&gt; Int -&gt; Character -&gt; Character
setStat stat value character =
    let
      stats = character.stats
    in
    case stat of
        ...
        Vitality -&gt;
            { character
                | stats = { stats | vitality = value }
                , health =
                    character.health
                      &lt;$ (+) ((value - stats.vitality) * 10)
                      $&gt; always (100 + 10 * value)
            }                </code></pre>
<h3 id="ウェポンを持たせる">ウェポンを持たせる</h3>
<h4 id="インポート">インポート</h4>
<p>新しく <code>Weapon.elm</code> ファイルを作り，新しいモジュール定義する．</p>
<pre class="elm"><code>module Weapon exposing (..)

type alias Weapon =
    { name : String
    , level : Int
    , damage : Int
    }

new : String -&gt; Int -&gt; Int -&gt; Weapon
new name level damage = Weapon name level damage</code></pre>
<p>このモジュールをインポートして <code>Character</code> 型を拡張しよう</p>
<pre class="elm"><code>import Weapon exposing (Weapon)

type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    , health : (Int, Int)
    , stats : Stats
    , arm : Maybe Weapon
    }

new : String -&gt; String -&gt; Gender -&gt; Character
new name surname gender =
    Character
      name
      surname
      gender
      (100,100)
      (Stats 0 0 0)
      Nothing</code></pre>
<p>最後に <code>equip</code> 関数を作って完成． これで全てのテストが通るはずだ．</p>
<pre class="elm"><code>equip : Weapon -&gt; Character -&gt; Result String Character
equip weapon character =
    if weapon.level &lt; character.status.intelligence then
        Ok { character | arm = Just weapon }
    else
        Err &quot;Too dumb&quot;</code></pre>
<p>「頭悪すぎ」ってひどい(笑)</p>
<h2 id="phoenix-で-todo-アプリを作る">Phoenix で ToDo アプリを作る</h2>
<p>Elchemy が実際にどの程度有用かを感じるために，Elchemy + Elm + Phoenix で超簡易的な Todo アプリを作ってみた．</p>
<ul>
<li><a href="https://gitlab.com/matsubara0507/elchemy_todo_app">MATSUBARA Nobutada / elchemy_todo_app · GitLab</a></li>
</ul>
<p>過去に <a href="https://github.com/matsubara0507/patissier-test">Elm + Phoenix で社内ツールを作ったり</a>，<a href="https://matsubara0507.github.io/posts/2017-12-13-elm-and-haskell-for-elmer.html">Elm + Haskell で Todo アプリを書いてみたり</a>したので，その辺りからコードや構成はパクッて来てます． GitLab に置いてるのは，モノは試しってやつ(笑)．</p>
<h3 id="phoenix-をインストール">Phoenix をインストール</h3>
<p>Elchemy (および Elixir・Elm・npm) はインストールされているとする． <a href="https://hexdocs.pm/phoenix/installation.html">Phoenix のサイト</a>にある通りにやればよい．</p>
<pre><code>$ mix archive.install https://github.com/phoenixframework/archives/raw/master/phx_new.ez</code></pre>
<h3 id="project-を作成">Project を作成</h3>
<p>こんな時のために <code>elchemy init</code> というコマンドがある(？)．</p>
<pre><code>$ mix phx.new elchemy_todo_app --no-ecto
$ cd elchemy_todo_app
$ elchemy init</code></pre>
<p><code>elchemy new</code> との違いは，<code>mix.exs</code> の Elixir のバージョンが古いのと <code>.formatter.exs</code> ぐらいかな？ 今回は DB をわざわざ使うのがめんどくさいので，ストレージっぽい GenServer を定義する(なので <code>--no-ecto</code>)．</p>
<h3 id="crud-を作る">CRUD を作る</h3>
<p>Phoenix に CRUD を追加するには，まず<code>router.ex</code> にルーティングを足す.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">defmodule</span> <span class="cn">ElchemyTodoAppWeb</span><span class="op">.</span><span class="cn">Router</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="im">use</span> <span class="cn">ElchemyTodoAppWeb</span>, <span class="va">:router</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="op">...</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  pipeline <span class="va">:api</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    plug(<span class="va">:accepts</span>, [<span class="st">&quot;json&quot;</span>])</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  scope <span class="st">&quot;/api&quot;</span>, <span class="cn">ElchemyTodoAppWeb</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    pipe_through(<span class="va">:api</span>)</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    resources(<span class="st">&quot;/todos&quot;</span>, <span class="cn">TodoController</span>, <span class="va">only:</span> [<span class="va">:index</span>, <span class="va">:create</span>, <span class="va">:update</span>, <span class="va">:delete</span>])</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="kw">end</span></a></code></pre></div>
<p>次にコントロラーを定義し，</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">defmodule</span> <span class="cn">ElchemyTodoAppWeb</span><span class="op">.</span><span class="cn">TodoController</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="im">alias</span> <span class="cn">Models</span><span class="op">.</span><span class="cn">Todo</span>, <span class="va">as:</span> <span class="cn">Todo</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="im">use</span> <span class="cn">ElchemyTodoAppWeb</span>, <span class="va">:controller</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="kw">def</span> index(conn, _params), <span class="kw">do</span>: render(conn, <span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> <span class="op">...</span> })</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">def</span> create(conn, params), <span class="kw">do</span>: render(conn, <span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> <span class="op">...</span> })</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">def</span> update(conn, params), <span class="kw">do</span>: render(conn, <span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> <span class="op">...</span> })</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">def</span> delete(conn, %{<span class="st">&quot;id&quot;</span> <span class="op">=&gt;</span> id}), <span class="kw">do</span>: render(conn, <span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> <span class="op">...</span> })</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="kw">end</span></a></code></pre></div>
<p>(<code>...</code> の部分は後で埋める) そして View を定義する。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">defmodule</span> <span class="cn">ElchemyTodoAppWeb</span><span class="op">.</span><span class="cn">TodoView</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="im">use</span> <span class="cn">ElchemyTodoAppWeb</span>, <span class="va">:view</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">def</span> render(<span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> todos}), <span class="kw">do</span>: todos</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="kw">end</span></a></code></pre></div>
<p>さてここから　Elchemy だ。 モデルを Elchemy で定義する. というかモデル以外はマクロ色が強過ぎてうまくいかなかった.</p>
<h3 id="elchemy-でモデルを">Elchemy でモデルを</h3>
<p>まずは型を定義.</p>
<pre class="elm"><code>module Data.Todo exposing (..)
import Dict

type alias Todo =
    { id : String
    , title : String
    , done : Bool
    }

type alias Todos =
    Dict.Dict String Todo</code></pre>
<p>ここはフロント共有したいので別途切り出しておく. DBをサボるために GenServer なモデルを定義する.</p>
<pre class="elm"><code>module Models.Todo exposing (..)

import Data.Todo exposing (Todo, Todos)
import Dict
import Elchemy exposing (..)

{- ex
   use GenServer

   def start_link(init \\ %{ todos: %{}, cnt: 0 }), do: GenServer.start_link(__MODULE__, init, name: :todos)

   def init(state), do: {:ok, state}

   def handle_call(:get, _client, state), do: {:reply, state, state}

   def handle_cast({:set, new_state}, _state), do: {:noreply, new_state}

   def gen_(params) do
     %{
       id: params[&quot;id&quot;],
       title: params[&quot;title&quot;],
       done: params[&quot;done&quot;]
     }
   end
-}

type alias State =
    { todos : Todos
    , cnt : Int
    }

type Name
    = Todos

type Action
    = Get
    | Set State

gen : params -&gt; Todo
gen = ffi &quot;Models.Todo&quot; &quot;gen_&quot;

getState : State
getState = call_ Todos Get

setState : State -&gt; State
setState state = cast_ Todos (Set state) |&gt; always state

call_ : Name -&gt; Action -&gt; a
call_ = ffi &quot;GenServer&quot; &quot;call&quot;

cast_ : Name -&gt; Action -&gt; a
cast_ = ffi &quot;GenServer&quot; &quot;cast&quot;</code></pre>
<p><code>Todos</code> と削除された <code>Todo</code> も含めた総数を表した <code>Int</code> を持った <code>State</code> 型を状態として GenServer に保持して欲しい． 出力した Elixir コードにだけモジュールをインポートさせたり，うまく型付けできない関数を Elixir コードに張り付けるには，コメントアウト <code>{- ex ... -}</code> 使う． この中に書いた Elixir コードはそのまま出力先に貼り付けられる(濫用厳禁！)．</p>
<p>Elixir モジュールの関数を呼び出すには <code>Elchemy</code> モジュールにある <code>ffi</code> 関数を使う． ただし，<code>ffi</code> 関数をファーストクラスには扱えない． 次のようなエラーが出る．</p>
<pre><code>Ffi inside function body is deprecated since Elchemy 0.3</code></pre>
<p><code>Name</code> 型や <code>Action</code> 型は Elchemy が代数的データ型をアトムとタプルに変換することと，GenServer の使い方を知っていれば意図するところが分かるだろう． 逆にそれらを知っていなければ読みとれないと思う…</p>
<h2 id="section-1"></h2>
<p>コントローラーから呼ばれるインターフェースは <code>getState</code> と <code>setState</code> を用いることで簡単に書けた．</p>
<pre class="elm"><code>gets : List Todo
gets = Dict.values (.todos getState)

add : Todo -&gt; List Todo
add todo =
    let
        { todos, cnt } = getState
        newId   = toString cnt
        newTodo = { todo | id = newId }
        state   = { todos = Dict.insert newId newTodo todos, cnt = cnt + 1 }
    in
    setState state
        |&gt; .todos
        |&gt; Dict.values

update : Todo -&gt; List Todo
update todo =
    let
        { todos, cnt } = getState
        state = { todos = Dict.update todo.id (Maybe.map &lt;| always todo) todos, cnt = cnt }
    in
    setState state
        |&gt; .todos
        |&gt; Dict.values

remove : String -&gt; List Todo
remove todoId =
    let
        { todos, cnt } =
            getState
        state =
            { todos = Dict.remove todoId todos, cnt = cnt }
    in
    setState state
        |&gt; .todos
        |&gt; Dict.values</code></pre>
<p>コントローラーの <code>...</code> を書き換えてやれば完成だ．</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb21-1" data-line-number="1">  <span class="kw">def</span> index(conn, _params), <span class="kw">do</span>: render(conn, <span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> <span class="cn">Todo</span><span class="op">.</span>gets()})</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="kw">def</span> create(conn, params), <span class="kw">do</span>: render(conn, <span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> <span class="cn">Todo</span><span class="op">.</span>add(<span class="cn">Todo</span><span class="op">.</span>gen(params))})</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="kw">def</span> update(conn, params), <span class="kw">do</span>: render(conn, <span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> <span class="cn">Todo</span><span class="op">.</span>update(<span class="cn">Todo</span><span class="op">.</span>gen(params))})</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="kw">def</span> delete(conn, %{<span class="st">&quot;id&quot;</span> <span class="op">=&gt;</span> id}), <span class="kw">do</span>: render(conn, <span class="st">&quot;todos.json&quot;</span>, %{<span class="va">todos:</span> <span class="cn">Todo</span><span class="op">.</span>remove(id)})</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="kw">end</span></a></code></pre></div>
<p>ちなみに出力された Elixir コードは<a href="https://gitlab.com/matsubara0507/elchemy_todo_app/blob/443777cee3e8435ee15f04ada6437e41e3af064b/lib/data/todo.elchemy.ex">ココ</a>と<a href="https://gitlab.com/matsubara0507/elchemy_todo_app/blob/443777cee3e8435ee15f04ada6437e41e3af064b/lib/models/todo.elchemy.ex">ココ</a>です． 興味がある人は見てください．</p>
<h3 id="elm-brunch">Elm Brunch</h3>
<p>Brunch 設定が難しかったので，本質的には Elchemy と関係ないけど残しておく．</p>
<p>Phoenix 1.3 系ではトップレベルに <code>assets</code> というディレクトリがあり，HTML/JS/CSS/画像 のような静的ファイルはここに置いておく． Brunch を使って複数の JS や CSS を合わせることが出来る． <a href="https://github.com/madsflensted/elm-brunch">elm-brunch</a> を使うことで Elm を JS にコンパイルしてくれる．</p>
<p>branch-config に次のような設定を書き加えてあげる． Elm のフロントコードは <code>lib/web/elm</code> に置いてある．</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="va">exports</span>.<span class="at">config</span> <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  ...</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="dt">paths</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    <span class="dt">watched</span><span class="op">:</span> [<span class="st">&quot;static&quot;</span><span class="op">,</span> <span class="st">&quot;css&quot;</span><span class="op">,</span> <span class="st">&quot;js&quot;</span><span class="op">,</span> <span class="st">&quot;vendor&quot;</span><span class="op">,</span> <span class="st">&quot;../lib/web/elm&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    <span class="dt">public</span><span class="op">:</span> <span class="st">&quot;../priv/static&quot;</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">  <span class="op">},</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7"></a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  <span class="dt">plugins</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    <span class="dt">elmBrunch</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">      <span class="dt">elmFolder</span><span class="op">:</span> <span class="st">&quot;../lib/web/elm&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">      <span class="dt">mainModules</span><span class="op">:</span> [<span class="st">&quot;Main.elm&quot;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb22-12" data-line-number="12">      <span class="dt">outputFolder</span><span class="op">:</span> <span class="st">&quot;vendor&quot;</span></a>
<a class="sourceLine" id="cb22-13" data-line-number="13">    <span class="op">},</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">  ...</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16">  ...</a>
<a class="sourceLine" id="cb22-17" data-line-number="17"><span class="op">}</span></a></code></pre></div>
<h3 id="フロント部分">フロント部分</h3>
<p>ほんの少しだがコードを再利用できる． API クライアントは以下のようになる．</p>
<pre class="elm"><code>module TodoAPI exposing (..)

import Data.Todo exposing (Todo)
import Http

getTodos : Http.Request (List Todo)
getTodos =
    Http.request
        { method =
            &quot;GET&quot;
        , headers =
            []
        , url =
            String.join &quot;/&quot;
                [ baseUrl
                , &quot;todos&quot;
                ]
        , body =
            Http.emptyBody
        , expect =
            Http.expectJson (list decodeTodo)
        , timeout =
            Nothing
        , withCredentials =
            False
        }</code></pre>
<p>ホントはこの当たりも Elchemy を使って生成できるとよいのだが… もしかして <a href="https://github.com/saschatimme/elm-phoenix">elm-phoenix</a> なるものを使えばよかったのかな？ また，The Elm Architecture 部分は長いので割愛．</p>
<h2 id="section-2"></h2>
<p>ホントは assets 回りが他にもたくさんあるが,本質的な部分はこれで完成． あとはモロモロインストールして <code>mix phx.server</code> とすれば動作するはずだ．</p>
<h3 id="感想">感想</h3>
<ul>
<li><strong>うれしみ</strong>
<ul>
<li>静的検査は神</li>
<li>フロントとコードを共有できる</li>
</ul></li>
<li><strong>つらみ</strong>
<ul>
<li>Phoenix のいくつかは型付けできない
<ul>
<li>ルーティングの引数</li>
<li>へテロリストのようなモノ</li>
<li>結局ここで良く分からんエラーに…</li>
</ul></li>
<li>コンパイルが遅い</li>
</ul></li>
</ul>
<h2 id="おしまい">おしまい</h2>
<p>今度は処理系の中身でも追ってみようかな．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Elchemy 入門 : その１</title>
    <link href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html" />
    <id>https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html</id>
    <published>2018-06-15T00:00:00Z</published>
    <updated>2018-06-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Elchemy 入門 : その１</h1>
    <p class="post-meta">
      <time datetime="2018-06-15" itemprop="datePublished">
        Jun 15, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Elchemy.html">Elchemy</a> <a href="/tags/Elm.html">Elm</a> <a href="/tags/Elixir.html">Elixir</a> <a href="/tags/Haskell.html">Haskell</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Elm から Elixir のトランスパイラ，<a href="https://github.com/wende/elmchemy">Elchemy</a> についてイロイロと調べたのでまとめていきます． 今回は</p>
<ul>
<li><a href="https://github.com/wende/elchemy/blob/9184d758dc1d5d5d3209302f9742c11fe01aa92c/README.md">README</a> の意訳</li>
<li>Dockerイメージ作成</li>
<li>Tutorial その１をやってみた</li>
</ul>
<p>の3本立てです． ちなみに，現在のバージョンは 0.7.4 です．</p>
<h2 id="readme-意訳">README 意訳</h2>
<p>Elchemy は，Elixir の強力なエコシステムと Elm の型安全によって，より簡潔に高速に高品質で型安全なコードを記述するために作られた処理系です．</p>
<ul>
<li><a href="http://elchemy-live.herokuapp.com">Elchemy のオンライン環境</a></li>
<li><a href="https://wende.gitbooks.io/elchemy/content/">Elchemy の公式ドキュメント</a></li>
<li><a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-1-introduction-8968b76d721d">Elchemy のチュートリアル</a> (今のところ Part1 と Part2 がある)</li>
</ul>
<p>なにか質問がある場合は <a href="https://github.com/wende/elchemy/labels/Q%26A"><code>Q&amp;A</code> ラベルを付けて Issue を書いて</a>，だそうだ．</p>
<h3 id="features">Features</h3>
<ul>
<li><strong>型推論:</strong> 強力な型推論によって型注釈を付けることはめったにない． コンパイラによって全て検査される．</li>
<li><strong>簡単で型安全な呼び出し:</strong> 余計なボイラープレートなしに Elixir/Erlang のプログラムを呼び出すことが出来る． Elixir の typespec に基づいて可能な限り徹底的に型安全の観点から全ての呼び出しを検査する．</li>
<li><strong>Elm と Elixir のいいとこどり:</strong> Elchemy は Elm の型安全性と強力な型推論，素晴らしい表現力を継承し，Elixir の Doc-test とツール群，そして BEAM プラットフォームを継承している．</li>
<li><strong>ほとんどないランタイムエラー:</strong> Elchemy の型システムは <strong>ほぼ全てのランタイムエラーを排除する</strong> ． エッジケースが少なくなることで，Elchemy のコードそのものは安全になる． ランタイムエラーが発生した場合，おそらく Elixir のところが起こしているのだろう．</li>
<li><strong>美しくて可読性の高い出力:</strong> 生成されたコードは慣習的で効率的で元のコードが無くとも読みやすく分析可能である．</li>
</ul>
<h3 id="faq">FAQ</h3>
<h4 id="どういう人にお勧めか">どういう人にお勧めか？</h4>
<ul>
<li>型が好きな人</li>
<li>実行時エラーよりコンパイルエラーの方が好みな人</li>
<li><code>defp add(a, b), do: b + c</code> より <code>add b c = b + c</code> な書き方の方が好みな人</li>
<li>カリー化が好きな人</li>
<li>さっさと失敗させるより全て失敗しない方が賢いと思う人</li>
</ul>
<h4 id="どういう人にお勧めじゃないか">どういう人にお勧めじゃないか？</h4>
<ul>
<li>もしあなたのプロジェクトが徹底的にテストされたライブラリに依存しておりかつ，あなたが 0 から始まるバージョンを嫌う場合</li>
<li>モナドを学ぶことで口ひげが伸び視力が弱くなることを恐れる場合</li>
</ul>
<h4 id="既にある-elixir-プロジェクトを置き換えるのは可能か">既にある Elixir プロジェクトを置き換えるのは可能か？</h4>
<p>可能です． しかし，ナイスでダンディーなコンパイルツールは開発中です．</p>
<h4 id="上司に-elchemy-に現を抜かしていることがばれるだろうか">上司に Elchemy に現を抜かしていることがばれるだろうか？</h4>
<p>Elchemy の出力はコードの可読性を第一級市民として扱っている． コードは適切にインデントされ，コメントは省略されず，できるだけ最適化されている(例えば，case 節は関数のオーバーロードになる)．</p>
<h4 id="elchemy-1.0.0-はまだ">Elchemy 1.0.0 はまだ？</h4>
<p>終わったらね．</p>
<h4 id="コントリビュートしてもいい">コントリビュートしてもいい？</h4>
<p>絶対にしてください．</p>
<h4 id="型はどのように表される">型はどのように表される？</h4>
<p>Elchemy の全ての値コンストラクタはスネークケースのアトムとして表現され，コンストラクタの引数はタプルで表わされる． つまり，Elchemy で <code>MyType 42 &quot;Forty two&quot; Error</code> という値は <code>{:my_type, 42, &quot;Forty two&quot;, :error}</code> という Elixir の値となる．</p>
<p>(Type constructor と書いてあるが正しくは Data constructor あるいは value constructor のはずで，Type application も間違いだと思われる)</p>
<h4 id="elm-の既存のライブラリを-elchemy-で使えるの">Elm の既存のライブラリを Elchemy で使えるの？</h4>
<p>Native モジュールや Port，Elm ランタイムを使わない限りは，それらを安全にインポートして使うことが出来る．</p>
<h4 id="elixir-の既存のライブラリを-elchemy-で使えるの">Elixir の既存のライブラリを Elchemy で使えるの？</h4>
<p>使える． 任意のモジュールの任意の関数を FFI 呼び出しすることが出来る． Elixir モジュール，Erlang モジュール，あるいはマクロであってしても自身の Elchemy コードに含むことが出来る． FFI 呼び出しは Elchemy 内で特別扱いされる． そして，<code>@spec</code> に基づいた型の解析を行うテストが生成されるため，Elixir コードの型安全性を損なうことは無い． 可読性を向上させるためにも FFI 呼び出しは可能な限り避け，常にドキュメント化と <code>doctest</code> をすることをお勧めする．</p>
<h4 id="テストのような-elixir-のマクロは使えるの">テストのような Elixir のマクロは使えるの？</h4>
<p>残念ながら，<code>do...end</code> ブロックのような任意のマクロを書くことはまだできない． 替わりとして，任意の関数に対して次のような Elixir のインラインコードを書くことが出来る．</p>
<pre class="elm"><code>{- ex
  code_here
-}</code></pre>
<p>しかし，それは最後の手段であり，乱用すべきではない．</p>
<h4 id="elchemy-の-.elm-ファイルをコンパイルするのに-elm-処理系をインストールする必要がある">Elchemy の <code>.elm</code> ファイルをコンパイルするのに Elm 処理系をインストールする必要がある？</h4>
<p>(なんとなく解答的に Elixir 処理系だけで完結できないの？という意味っぽい)</p>
<p>あなたは Elm のようなコードを書いて Elixir のコードを生成したいのに， Elixir コードの生成を Elixir コードを書いて作りたいですか？</p>
<h4 id="elchemy-プロジェクト">Elchemy プロジェクト</h4>
<p>作者はこの Elchemy プロジェクトそのものを可能な限り Elm で構築したいらしい． <a href="https://github.com/wende/elchemy#maturity-of-the-project">README にはその達成度が書かれている</a>． 処理系そのものは，ほとんど Elm になっているようだ(結果として世にも珍しい Elm で書かれたコンパイラが出来ている)． エフェクトや ErlangVM 回りが厳しいらしい．</p>
<h2 id="dockerイメージ作成">Dockerイメージ作成</h2>
<p>ココからが本題．</p>
<p>新しい言語を軽く試すのに最適なのはやはり Docker だ． Elchemy の Docker イメージは見当たらなかったので作った．</p>
<ul>
<li><a href="https://hub.docker.com/r/matsubara0507/elchemy">matsubara0507/elchemy - Docker Hub</a></li>
</ul>
<h3 id="できるまで">できるまで</h3>
<p>本家の README を読むとわかるように Elchemy でビルドするのに必要なモノは以下の4つ．</p>
<ul>
<li>Node (npm)</li>
<li>Elixir (ErlangVM)</li>
<li>Elm</li>
<li>elm-github-install</li>
</ul>
<p>これらのうち，もっともめんどくさいのは Elixir もとい ErlangVM だと思う． なので base イメージを Elixir にし，ひとつずつ入れていった．</p>
<p>base イメージにした <a href="https://hub.docker.com/_/elixir/">Elixir の Docker イメージは公式のモノ</a>を使う． <a href="https://github.com/erlang/docker-erlang-otp/blob/99ab1e150c3708ce81bc08073cf5793ef67c6a1c/20/Dockerfile#L1">OSは Debian9 だ</a>．</p>
<p>Debian への Node のインストールには以下の記事を参考にした．</p>
<ul>
<li><a href="http://atomiyama.com/linux/page/debian-9-2-node-npm/">debian9.2にNode.jsとnpmをインストールする｜atominux</a></li>
</ul>
<p>こんな感じ</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">RUN</span> curl -sL https://deb.nodesource.com/setup_${NODE_VERSION} | bash - \</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  &amp;&amp; apt-get update &amp;&amp; apt-get install -y nodejs \</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  &amp;&amp; apt-get clean \</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  &amp;&amp; rm -rf /var/lib/apt/lists/*</a></code></pre></div>
<p>後は簡単で Elm，elm-github-install，Elchemy は npm からインストールできる． ただし，Elm と elm-github-install には <code>--unsafe-perm=true --allow-root</code> という<a href="https://github.com/gdotdesign/elm-github-install/issues/21#issuecomment-332827661">オプションを付けないといけない</a>．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">RUN</span> npm i -g elm@${ELM_VERSION} --unsafe-perm=true --allow-root</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">RUN</span> npm i -g elm-github-install@${ELM_GITHUB_INSTALL_VERSION} --unsafe-perm=true --allow-root</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">RUN</span> npm i -g elchemy@${ELCHEMY_VERSION}</a></code></pre></div>
<h3 id="auto-build">Auto Build</h3>
<p>Elchemy のリリースを眺めてると想像より開発スピードが速かったので，Elchemy の更新を観測して自動ビルドしてくれる仕組みを作ることにした． シェル芸を駆使すればなんとかなりそうだったが，サクッと Haskell 芸をかまして CLI を作った．</p>
<ul>
<li><a href="https://github.com/matsubara0507/dockwright">matsubara0507/dockwright - GitHub</a></li>
</ul>
<p>(船大工が <code>shipwright</code> なので Dockerfile 大工ってことで <code>dockwright</code>)</p>
<p>以下のような設定を書いておくと <code>dockwright</code> ってコマンドで GitHub の <code>release</code> API を叩いてリリースタグを取ってきてくれる． それを Docker 内の環境変数としてテンプレートに書き込む．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">env:</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">elchemy_version:</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="fu">github:</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">      <span class="fu">repo:</span><span class="at"> wende/elchemy</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">      <span class="fu">hook:</span><span class="at"> release</span></a></code></pre></div>
<p>あとは git diff で更新をみて更新があればコミットする(コミットさえすれば Docker Hub が自動ビルドしてくれる)． 定期実行は例の如く TravisCI で回す．</p>
<h2 id="tutorial-そのをやってみた">Tutorial その１をやってみた</h2>
<p>以下の記事をやってみる．</p>
<ul>
<li><a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-1-introduction-8968b76d721d">Elmchemy — Write type-safe Elixir code with Elm’s syntax — part 1 — Introduction</a></li>
</ul>
<p>まずは <code>article_example_elchemy</code> というプロジェクトを作る． 記事内では <code>mix new</code> をして <code>elchemy init</code> をしろと書いてあるが，最新の Elchemy では <code>elchemy new</code> をすることで一気にやってくれる．</p>
<pre><code>$ elchemy new article_example_elchemy</code></pre>
<p>Elchemy をコンパイルするためには，<code>mix.exs</code> を次のように<a href="https://wende.gitbooks.io/elchemy/content/INSTALLATION.html">書き換える必要がある</a>．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">defmodule</span> <span class="cn">MyProject</span><span class="op">.</span><span class="cn">Mixfile</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="im">use</span> <span class="cn">Mix</span><span class="op">.</span><span class="cn">Project</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">def</span> project <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    [</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      <span class="va">app:</span> <span class="va">:my_project</span>,</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">      <span class="va">version:</span> <span class="st">&quot;0.1.0&quot;</span>,</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      <span class="va">elixir:</span> <span class="st">&quot;~&gt; 1.5&quot;</span>,</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      <span class="va">start_permanent:</span> <span class="cn">Mix</span><span class="op">.</span>env <span class="op">==</span> <span class="va">:prod</span>,</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      <span class="va">deps:</span> deps()</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    ] <span class="op">|&gt;</span> <span class="cn">Code</span><span class="op">.</span>eval_file(<span class="st">&quot;elchemy.exs&quot;</span>)<span class="op">.</span>init <span class="co"># ココ!</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="op">...</span></a></code></pre></div>
<p><code>|&gt; Code.eval_file(&quot;elchemy.exs&quot;).ini</code> の部分を書き加えている．</p>
<h3 id="ディレクトリ構成">ディレクトリ構成</h3>
<p><code>elchemy new</code> した結果はこんな感じ(バージョンによっては違うかもしれない)．</p>
<pre><code>projrct_name
  |- .elchemy.exs
  |- .formatter.exs
  |- .gitignore
  |- README.md
  |- config
  |   \- config.exs
  |- elm
  |   \- Hello.elm
  |- elm-package.json
  |- lib
  |   \- project_name.ex
  |- mix.exs
  \- test
      |- elchemy_test.exs
      |- project_name_test.exs
      \- test_helper.exs</code></pre>
<p><code>.elchemy.exs</code> は <code>mix</code> コマンドを Elchemy で上書きするための <code>mix</code> 設定ファイルで，残りは Elixir と Elm のプロジェクトファイルが混ざっている． ちなみに <code>.formatter.exs</code> は Elixir 1.6 で追加された Elixir のフォーマッターの設定ファイルだ．</p>
<h3 id="関数を定義してみる">関数を定義してみる</h3>
<p>試しに，総和を求める <code>sum</code> 関数を書いてみる． <code>elm/Hello.elm</code> に書き加えるとして，まずはユニットテストを <code>test\elchemy_test.exs</code> に Elixir の文脈で書き加えてみる．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">defmodule</span> <span class="cn">ElchemyTest</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="im">use</span> <span class="cn">ExUnit</span><span class="op">.</span><span class="cn">Case</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="im">use</span> <span class="cn">Elchemy</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  doctest <span class="cn">Hello</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  test <span class="st">&quot;Hello&quot;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    assert <span class="cn">Hello</span><span class="op">.</span>hello() <span class="op">==</span> <span class="st">&quot;world!&quot;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  test <span class="st">&quot;Sum of lists&quot;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">     assert <span class="cn">Hello</span><span class="op">.</span>sum([]) <span class="op">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">     assert <span class="cn">Hello</span><span class="op">.</span>sum([<span class="dv">2</span>]) <span class="op">==</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">     assert <span class="cn">Hello</span><span class="op">.</span>sum([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">-1</span>, <span class="dv">-2</span>, <span class="dv">-3</span>]) <span class="op">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="kw">end</span></a></code></pre></div>
<p>次に <code>elm/Hello.elm</code> に以下の関数を書き加える．</p>
<pre class="elm"><code>sum : List a -&gt; Int
sum list =
    case list of
        first :: rest -&gt;
            first + sum rest

        [] -&gt;
            0</code></pre>
<p>とりあえずビルドしてみる．</p>
<pre><code>$ mix test
warning: redefining module ElchemyInit (current version defined in memory)
  elchemy.exs:1

==&gt; elchemy
Compiling 24 files (.ex)
warning: unused alias XMaybe
  lib/Elchemy/XRegex.elchemy.ex:28

warning: unused import Elchemy.XBasics
  lib/Elchemy/XChar.elchemy.ex:25

warning: unused import Elchemy.XBasics
  lib/Elchemy/XBitwise.elchemy.ex:6

warning: unused import Elchemy.Macros
  lib/Elchemy/Plugins/Ex_unit.elchemy.ex:7

warning: unused import Elchemy.Macros
  lib/Elchemy/Tests/Ex_unit_test.elchemy.ex:7

Generated elchemy app
==&gt; article_example_elchemy
/usr/bin/elchemy
-- Copying Elixir native files --
-- Compiling Elm files --
----------
Type Checking elm/Hello.elm
-- TYPE MISMATCH ------------------------------------------------- elm/Hello.elm

The left argument of (+) is causing a type mismatch.

21|             first + sum rest
                ^^^^^
(+) is expecting the left argument to be a:

    number

But the left argument is:

    a

Hint: Your type annotation uses type variable `a` which means any type of value
can flow through. Your code is saying it CANNOT be anything though! Maybe change
your type annotation to be more specific? Maybe the code has a problem? More at:
&lt;https://github.com/elm-lang/elm-compiler/blob/0.18.0/hints/type-annotations.md&gt;

Detected errors in 1 module.
Type Check failed
** (Mix) Elchemy failed the compilation with an error</code></pre>
<p>いろいろ出ているが重要なのは <code>The left argument of (+) is causing a type mismatch.</code> の部分． 型検査した結果，型が合わなかったのだ． 念のため型検査器の言い分を補足しておくと，<code>sum</code> 関数の引数として <code>List a</code> 型の値 <code>list</code> の要素である <code>first</code> は <code>a</code> 型と推論されるが，加算 <code>(+)</code> は <code>number</code> 型じゃないといけない，ということだ(<code>number</code> 型は加算や乗算が実装されている多相型)．</p>
<p>言われた通りに変えてみよう．</p>
<pre class="elm"><code>sum : List number -&gt; Int
sum list = ...</code></pre>
<p>ビルドする．</p>
<pre><code>$ mix test
...
Type Checking elm/Hello.elm
-- TYPE MISMATCH ------------------------------------------------- elm/Hello.elm

The right side of (+) is causing a type mismatch.

21|             first + sum rest
                        ^^^^^^^^
(+) is expecting the right side to be a:

    number

But the right side is:

    Int

Hint: Your type annotation uses type variable `number` which means any type of
value can flow through. Your code is saying it CANNOT be anything though! Maybe
change your type annotation to be more specific? Maybe the code has a problem?
More at:
&lt;https://github.com/elm-lang/elm-compiler/blob/0.18.0/hints/type-annotations.md&gt;

Hint: With operators like (+) I always check the left side first. If it seems
fine, I assume it is correct and check the right side. So the problem may be in
how the left and right arguments interact.

Detected errors in 1 module.
Type Check failed
** (Mix) Elchemy failed the compilation with an error</code></pre>
<p><code>(+) is expecting the right side to be a</code> というエラーメッセージに変わった． これは <code>sum</code> 関数の返り値の型が <code>Int</code> なので <code>sum rest</code> の型は <code>Int</code> と推論されたが，<code>first</code> の型が <code>number</code> なので <code>(+)</code> 演算子の左右の型が合わない，ということだ． なので， <code>sum : List Int -&gt; Int</code> とすると無事ビルドが通る．</p>
<h3 id="変換された-elixir-コード">変換された Elixir コード</h3>
<p>ちなみに，次のような Elixir コードに変換されている．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">defmodule</span> <span class="cn">Hello</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="im">use</span> <span class="cn">Elchemy</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="op">...</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="ot">@spec</span> sum(list(integer)) :: integer</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  curry sum<span class="op">/</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  <span class="kw">def</span> sum(list) <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="kw">case</span> list <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">      [first <span class="op">|</span> rest] <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">        (first <span class="op">+</span> sum(rest))</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">      [] <span class="op">-&gt;</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">        <span class="dv">0</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="kw">end</span></a></code></pre></div>
<h3 id="doctest">doctest</h3>
<p>また，次のように書くことで doctest も変換してくれる．</p>
<pre class="elm"><code>{-| Returns a sum of every integer int the function

    sum [1,2,3] == 6
    sum [10] == 10
    sum [] == 0

-}
sum : List Int -&gt; Int
sum list = ...</code></pre>
<p>変換先はこうだ．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb15-1" data-line-number="1">  <span class="ot">@doc &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">  Returns a sum of every integer int the function</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="co">      iex&gt; import Hello</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="co">      iex&gt; sum([1, 2, 3])</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co">      6</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="co">      iex&gt; import Hello</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="co">      iex&gt; sum([10])</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="co">      10</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11"></a>
<a class="sourceLine" id="cb15-12" data-line-number="12"><span class="co">      iex&gt; import Hello</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13"><span class="co">      iex&gt; sum([])</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="co">      0</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15"></a>
<a class="sourceLine" id="cb15-16" data-line-number="16"></a>
<a class="sourceLine" id="cb15-17" data-line-number="17"><span class="co">  </span><span class="ot">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb15-18" data-line-number="18">  <span class="ot">@spec</span> sum(list(integer)) :: integer</a>
<a class="sourceLine" id="cb15-19" data-line-number="19">  curry sum<span class="op">/</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb15-20" data-line-number="20">  <span class="kw">def</span> sum(list) <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-21" data-line-number="21">    <span class="op">...</span></a></code></pre></div>
<h2 id="おしまい">おしまい</h2>
<p>次はアプリケーションを作りたい．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell で型安全に YAML ファイルをビルド時に埋め込む</title>
    <link href="https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html" />
    <id>https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html</id>
    <published>2018-05-13T00:00:00Z</published>
    <updated>2018-05-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell で型安全に YAML ファイルをビルド時に埋め込む</h1>
    <p class="post-meta">
      <time datetime="2018-05-13" itemprop="datePublished">
        May 13, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/extensible-package.html">extensible-package</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>ザックリ言えば「<a href="https://ryota-ka.hatenablog.com/entry/2018/02/14/103000">Template Haskell でコード中に JSON を埋め込んだりコンパイル時にファイルから型安全に読み込んだりする - ryota-ka’s blog</a>」という記事の YAML 版です．</p>
<p>ただし，ryota さんの記事では Template Haskell を解説しながら JSON を読み込む関数を定義していますが， YAML 版は <a href="https://hackage.haskell.org/package/yaml">yaml</a> パッケージに同様の関数が既にあるので特に解説はしません． あくまでも Haskell の型システムとメタプログラミングを感じてもらえたらなぁと．</p>
<h2 id="section"></h2>
<p>ソースコードは全てこの<a href="https://github.com/matsubara0507/sample-yaml-th">リポジトリ</a>にまとめてある．</p>
<h1 id="yaml-を埋め込む">YAML を埋め込む</h1>
<p>次のような設定ファイルに関する型があったとします．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  {<span class="ot"> columns ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ,<span class="ot"> languageExtensions ::</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>yaml パッケージで YAML にデコードするためには <a href="https://hackage.haskell.org/package/aeson">aeson</a> の <a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson.html#t:FromJSON"><code>FromJSON</code></a> 型クラスのインスタンスである必要がある． <code>FromJSON</code> のインスタンスに凝ってもしょうがないので，今回は <code>Generics</code> を使って適当に定義する．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">import</span> <span class="dt">GHC.Generics</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  {<span class="ot"> columns ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  ,<span class="ot"> languageExtensions ::</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Config</span></a></code></pre></div>
<p><code>Config</code> 型のデフォルト値を YAML ファイルで記述したいとする．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># template/.config.yaml</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="fu">columns:</span><span class="at"> 80</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="fu">languageExtensions:</span><span class="at"> </span><span class="kw">[]</span></a></code></pre></div>
<p>これをコンパイル時に埋め込んでかつ型検査も行いたい． そのためには Template Haskell と yaml パッケージの <a href="https://hackage.haskell.org/package/yaml-0.8.30/docs/Data-Yaml-TH.html#v:decodeFile"><code>Data.Yaml.TH.decodeFile</code></a> 関数を用いる．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">decodeFile ::</span> (<span class="dt">Lift</span> a, <span class="dt">FromJSON</span> a) <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Q</span> (<span class="dt">TExp</span> a)</a></code></pre></div>
<p><code>TExp a</code> 型というのは型付きの <code>Exp</code> 型らしいが，ぼくはあまりよく分からないので割愛． 型を見ればわかるように，<code>Lift</code> 型クラスのインスタンスにもなってなきゃいけない． <code>DerivingLift</code> 言語拡張を使えば簡単に定義できる．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveLift #-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> import <span class="dt">Language.Haskell.TH.Syntax</span> <span class="co">-- template-haskell package</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  {<span class="ot"> columns ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  ,<span class="ot"> languageExtensions ::</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>, <span class="dt">Lift</span>)</a></code></pre></div>
<p>使い方は簡単で，次のようにすればよい．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">defaultConfig ::</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">defaultConfig <span class="fu">=</span> <span class="fu">$$</span>(decodeFile <span class="st">&quot;./template/.config.yaml&quot;</span>)</a></code></pre></div>
<p>注意点として，Template Haskell の制約より <code>Config</code> 型の定義と <code>defaultConfig</code> 関数の定義は別ファイルに分けなければいけない．</p>
<h2 id="試す">試す</h2>
<pre><code>$ stack ghci
&gt;&gt; defaultConfig
Config {columns = 80, languageExtensions = []}</code></pre>
<p>試しに間違えてみよう</p>
<pre><code>$ cat template/.config.yaml
column: 80
languageExtensions: []
$ stack build
sample-yaml-th-0.1.0.0: build (lib)
Preprocessing library for sample-yaml-th-0.1.0.0..
Building library for sample-yaml-th-0.1.0.0..
[1 of 2] Compiling Sample.Config.Internal ( src\Sample\Config\Internal.hs, .stack work\dist\5c8418a7\build\Sample\Config\Internal.o )
[2 of 2] Compiling Sample.Config    ( src\Sample\Config.hs, .stack-work\dist\5c8418a7\build\Sample\Config.o )

C:\Users\hoge\haskell\sample-yaml-th\src\Sample\Config.hs:14:20: error:
    • Aeson exception:
Error in $: key &quot;columns&quot; not present
    • In the Template Haskell splice
        $$(Y.decodeFile &quot;./template/.config.yaml&quot;)
      In the expression: $$(Y.decodeFile &quot;./template/.config.yaml&quot;)
      In an equation for ‘defaultConfig’:
          defaultConfig = $$(Y.decodeFile &quot;./template/.config.yaml&quot;)
   |
14 | defaultConfig = $$(Y.decodeFile &quot;./template/.config.yaml&quot;)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
<h1 id="おまけ-with-extensible">おまけ : with Extensible</h1>
<p>さぁココからが本題！ <a href="https://hackage.haskell.org/package/extensible">extensible</a> という神パッケージを使ってリファクタリングをしてみよう！！</p>
<h2 id="問題点">問題点</h2>
<p>大した問題ではないんだけど</p>
<ol type="1">
<li>ファイルを分けなければいけないのが悲しい</li>
<li>YAML のキーがキャメルケース(<code>languageExtensions</code>)</li>
</ol>
<h2 id="extensible-パッケージ">extensible パッケージ</h2>
<p>言わずもがな，拡張可能なレコードやバリアントを提供するパッケージだ． (詳しくは，最近急ピッチで充実されている<a href="https://wiki.hask.moe/">攻略Wiki</a>を読むといいんじゃないんかな？)</p>
<p>例えば，さっきから使っている <code>Config</code> 型を <code>extensible</code> レコード型で書くと次のように書ける</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds     #-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="ch">&#39;[ &quot;root&quot; &gt;: Text</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">   , <span class="st">&quot;path-format&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">   ]</a></code></pre></div>
<p>地味にうれしいことに，extensible であれば関数名では許されないハイフンが含んだフィールド名も定義できるのだ．</p>
<h2 id="リファクタリング">リファクタリング</h2>
<p><code>Data.Yaml.TH.decodeFile</code> を使うには <code>FromJSON</code> 型クラスと <code>Lift</code> 型クラスのインスタンスにしなければいけない． でも安心して欲しい． どちらも最新の extensible-0.4.9 では定義済みだ(そして extensible のレコードは <code>type</code> 宣言なので追加でインスタンスを定義する必要は無い)．</p>
<p>ただし，extensible-0.4.9 はまだ Stackage の LTS にも nightly にも追加されていないので <code>stack.yaml</code> に追加する必要がある．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-11.9</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">-</span> extensible-0.4.9</a></code></pre></div>
<p><code>Lift</code> 型クラスのインスタンスは extensible で定義済みなので1つ目のファイルを分けるはクリアーだ． 実は2つもクリアーしている． 拡張可能レコードの <code>FromJson</code> 型クラスのインスタンスは <code>&quot;path-format&quot;</code> のようなハイフンを含んだ文字列もそのまま扱ってくれる．</p>
<p>以下が extensible 版の <code>Config</code> 型に対応する YAML ファイルだ．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co"># template/.extensible-config.yaml</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="fu">columns:</span><span class="at"> 80</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="fu">language-extensions:</span><span class="at"> </span><span class="kw">[]</span></a></code></pre></div>
<p>試しに実行してみよう！</p>
<pre><code>$ stack ghci
&gt;&gt; Sample.Extensible.Config.defaultConfig
columns @= 80 &lt;: language-extensions @= [] &lt;: nil</code></pre>
<h2 id="デフォルトで置き換える">デフォルトで置き換える</h2>
<p>最後に簡単な実行ファイルを実装してみる． 設定ファイルのパスを与えると読みに行き，足りない部分は先ほどから埋め込んでるデフォルト値に置き換えて出力するモノだ．</p>
<pre><code>$ cat &quot;./template/.example.yaml&quot;
columns: 100
$ stack exec -- pconfig &quot;./template/.example.yaml&quot;
columns @= 100 &lt;: language-extensions @= [] &lt;: nil
$ stack exec -- pconfig
columns @= 80 &lt;: language-extensions @= [] &lt;: nil</code></pre>
<p>もちろんパスにファイルが無ければデフォルトのモノを出力するだけだ．</p>
<h2 id="section-1"></h2>
<p>さてどうすれば良いだろうか？ 例えば，<code>FromJSON</code> 型クラスの <code>Meybe a</code> 型のインスタンスはフィールドが無い場合に <code>Nothing</code> を与えてくれるので， <code>Config</code> 型の各フィールドを <code>Maybe</code> でラップするというのはどうだろう．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="ch">&#39;[ &quot;root&quot; &gt;: Maybe Text</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">   , <span class="st">&quot;path-format&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">   ]</a></code></pre></div>
<p>フィールドが2つなら良いが多くなってきたら辛そうだ…</p>
<h3 id="必殺-nullable">必殺 Nullable</h3>
<p>全てを <code>Meybe</code> でラップする場合は <a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Nullable.html"><code>Nullable</code></a> を使うと良いだろう(ないしは <code>RecordOf Maybe</code>)．</p>
<p><code>Nullable h :* xs</code> も既に <code>FromJson</code> 型クラスのインスタンスになっているのでそのまま YAML を読み込める． あとは次のようなデフォルト値と <code>Nullable</code> を与えたら <code>Nothing</code> の部分だけデフォルト値で置き換えた値を返す関数を実装してやればよい．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">fromNullable ::</span> <span class="dt">RecordOf</span> h xs <span class="ot">-&gt;</span> <span class="dt">Nullable</span> (<span class="dt">Field</span> h) <span class="fu">:*</span> xs <span class="ot">-&gt;</span> <span class="dt">RecordOf</span> h xs</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">fromNullable def <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  hmapWithIndex <span class="fu">$</span> \m x <span class="ot">-&gt;</span> fromMaybe (hlookup m def) (getNullable x)</a></code></pre></div>
<p>extensible ならこうやって全てのフィールドに対し走査する関数が使える．</p>
<h2 id="section-2"></h2>
<p>あとはこんな感じ</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">{-# LANGUAGE PolyKinds         #-}</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">RIO.Directory</span>      (doesFileExist)</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"></a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Yaml</span>          <span class="kw">as</span> <span class="dt">Y</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  path <span class="ot">&lt;-</span> fromMaybe <span class="st">&quot;&quot;</span> <span class="fu">.</span> listToMaybe <span class="fu">&lt;$&gt;</span> getArgs</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">  config <span class="ot">&lt;-</span> readConfigWith defaultConfig path</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">  hPutBuilder stdout <span class="fu">$</span> encodeUtf8Builder (tshow config)</a>
<a class="sourceLine" id="cb16-19" data-line-number="19"></a>
<a class="sourceLine" id="cb16-20" data-line-number="20"><span class="ot">readConfigWith ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb16-21" data-line-number="21">readConfigWith def path <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-22" data-line-number="22">  file <span class="ot">&lt;-</span> readFileBinaryWith <span class="st">&quot;&quot;</span> path</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">  <span class="kw">if</span> Y.decodeEither file <span class="fu">==</span> <span class="dt">Right</span> <span class="dt">Y.Null</span> <span class="kw">then</span></a>
<a class="sourceLine" id="cb16-24" data-line-number="24">    pure def</a>
<a class="sourceLine" id="cb16-25" data-line-number="25">  <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-26" data-line-number="26">    config <span class="ot">&lt;-</span> either (error <span class="fu">.</span> show) pure <span class="fu">$</span> Y.decodeEither&#39; file</a>
<a class="sourceLine" id="cb16-27" data-line-number="27">    pure <span class="fu">$</span> fromNullable def config</a>
<a class="sourceLine" id="cb16-28" data-line-number="28"></a>
<a class="sourceLine" id="cb16-29" data-line-number="29"><span class="ot">readFileBinaryWith ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb16-30" data-line-number="30">readFileBinaryWith def path <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-31" data-line-number="31">  doesFileExist path <span class="fu">&gt;&gt;=</span> bool (pure def) (readFileBinary path)</a></code></pre></div>
<p>いろいろとインポートするのがめんどくさくて <code>rio</code> ライブラリを使っているが，あんまり気にしないで．</p>
<h1 id="おしまい">おしまい</h1>
<p>ちなみに，<a href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html">前回の記事</a>に書いた <a href="https://github.com/matsubara0507/taskpad"><code>taskpad</code></a> にこの機能を追加してる．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>オレ的 Haskell で CLI を作る方法 2018</title>
    <link href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html" />
    <id>https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html</id>
    <published>2018-05-10T00:00:00Z</published>
    <updated>2018-05-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">オレ的 Haskell で CLI を作る方法 2018</h1>
    <p class="post-meta">
      <time datetime="2018-05-10" itemprop="datePublished">
        May 10, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/extensible-package.html">extensible-package</a> <a href="/tags/rio.html">rio</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>現在 <a href="https://github.com/matsubara0507/taskpad">TaskPad</a> という簡易的なタスク管理(編集)ツールを Haskell で作っていて，少し CLI を作るうえでのオレ的ノウハウが溜まったのでメモっとく．</p>
<h2 id="taskpad">TaskPad</h2>
<p>先に，何を作ってるかを書いておく． まだ完成していないが，気持ちは次のような Yaml ファイルを編集して自身のタスク管理をしようかなと考えている．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">memo:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="fu">tasks:</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">1:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="fu">done:</span><span class="at"> true</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="fu">children:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="fu">name:</span><span class="at"> hello</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="fu">2:</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="fu">done:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    <span class="fu">children:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    <span class="fu">name:</span><span class="at"> world</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="fu">date:</span><span class="at"> </span><span class="st">&#39;20180504&#39;</span></a></code></pre></div>
<p>現状できている CLI は次のような感じ</p>
<pre><code>$ taskpad --help
taskpad - operate daily tasks

Usage: taskpad [-v|--verbose] [-d|--date DATE] COMMAND [--version]

Available options:
  -v,--verbose             Enable verbose mode: verbosity level &quot;debug&quot;
  -d,--date DATE           Task&#39;s date
  --version                Show version
  -h,--help                Show this help text

Available commands:
  new                      Create a new task file. Note: if don&#39;t use --date
                           option then use today&#39;s date.
  add                      Add Task
  done                     Done Task
  tasks                    Show Tasks</code></pre>
<p><code>taskpad new</code> で Yaml ファイルを生成し，<code>taskpad add &quot;hoge&quot;</code> “hoge” というタスクを追加し，<code>taskpad done 1</code> で1番目のタスクを完了したことにし，<code>taskpad tasks</code> でタスクの一覧を出力する．</p>
<h2 id="ノウハウ">ノウハウ？</h2>
<p>たぶん他ではあんまり書いてない，いくつかのことを書いておく．</p>
<ul>
<li>optparse-applicative + extensible を使った CLI のオプションパーサー
<ul>
<li>特にサブコマンドをバリアントで表現しているのが面白い</li>
</ul></li>
<li>optparse-applicative でバージョンを表示</li>
<li>バリアントと型クラスを用いた分岐</li>
<li>rio + extensible で大域変数</li>
<li>rio を用いてロギング</li>
</ul>
<p>オプションパーサーに <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> を用いている． オプションパーサーには <a href="https://hackage.haskell.org/package/optparse-simple">optparse-simple</a> や <a href="https://hackage.haskell.org/package/optparse-generic">optparse-generics</a> など他にもいくつかあるが，サブコマンドのような多少込み入ったコトをしようとすると optparse-applicative が欲しくなる． <a href="https://hackage.haskell.org/package/rio">rio</a> ライブラリは，なんとなく最近使っている alt. Prelude ライブラリ(詳しくは<a href="https://github.com/commercialhaskell/rio#readme">本家の README</a> か<a href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html">前の僕の記事</a>を読んで)． <a href="https://hackage.haskell.org/package/extensible">extensible</a> は Haskell の残念なレコード構文や直和型の代わりに，拡張可能なレコード・バリアント型を提供してくれる面白いパッケージだ．</p>
<h3 id="import-と言語拡張">import と言語拡張</h3>
<p>extensible はかなり言語拡張を用いる． 以降では，めんどくさいので <code>import</code> も含め明示的に扱わない． 以下のコードが先頭にくっついてるとビルドはできるはずだ(たぶん，試してない)．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds             #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">{-# LANGUAGE FlexibleContexts      #-}</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">{-# LANGUAGE OverloadedLabels      #-}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">{-# LANGUAGE TypeApplications      #-}</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">{-# LANGUAGE TypeFamilies          #-}</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="ot">{-# LANGUAGE TypeOperators         #-}</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span>          <span class="kw">as</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">RIO.Time</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="kw">import</span>           <span class="dt">Data.Functor.Identity</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="kw">import</span>           <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17"><span class="kw">import</span>           <span class="dt">GHC.TypeLits</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="kw">import</span>           <span class="dt">Options.Applicative</span></a></code></pre></div>
<h3 id="extensible-で-optparse-applicative">extensible で optparse-applicative</h3>
<p>少しだけ <code>optparse-applicative</code> について説明しておく． optparse-applicative は CLI オプションをパースして任意の型にマッピングしてくれる． 主に次のようにして用いる．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">main <span class="fu">=</span> run <span class="fu">=&lt;&lt;</span> execParser opts</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    opts <span class="fu">=</span> info (options <span class="fu">&lt;**&gt;</span> helper)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">         <span class="fu">$</span> fullDesc</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="fu">&lt;&gt;</span> header <span class="st">&quot;taskpad - operate daily tasks&quot;</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="ot">options ::</span> <span class="dt">Parser</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">options <span class="fu">=</span> undefined</a></code></pre></div>
<p><a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:execParser"><code>execParser</code></a> 関数は <code>ParserInfo a -&gt; IO a</code> という型を持つ． <a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:helper"><code>helper :: Parser (a -&gt; a)</code></a> は <code>--help</code> オプションを与えてくれる関数だ． <code>info</code> 関数と <code>fullDesc</code> や <code>header</code> により，<code>Parser a</code> 型のパーサーに対し <code>--help</code> で出力する情報を追加して <code>ParserInfo a</code> 型に変換する．</p>
<h4 id="型の定義">型の定義</h4>
<p><code>extensible</code> で <code>optparse-applicative</code> を使うとは即ち，任意の型，ここでいう <code>Options</code> 型が拡張可能レコードや拡張可能バリアントであるというシチュエーションだ． 今回は <code>Options</code> 型をまずは次のように定義した．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Options</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ch">&#39;[ &quot;verbose&quot; &gt;: Bool</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">   , <span class="st">&quot;date&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">   , <span class="st">&quot;subcmd&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">   ]</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">type</span> <span class="dt">SubCmd</span> <span class="fu">=</span> <span class="dt">Variant</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  <span class="ch">&#39;[ &quot;new&quot;   &gt;: ()</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">   , <span class="st">&quot;add&quot;</span>   <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">   , <span class="st">&quot;done&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">   , <span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">   ]</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="kw">type</span> <span class="dt">Date</span> <span class="fu">=</span> <span class="dt">Text</span></a></code></pre></div>
<p><code>SubCmd</code> 型が拡張可能なバリアント型だ． ちなみに，Haskell のプリミティブな代数型データ構造で記述すると以下のようになる．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Options</span> <span class="fu">=</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  {<span class="ot"> verbose ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  ,<span class="ot"> date    ::</span> <span class="dt">Maybe</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  ,<span class="ot"> subcmd  ::</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">data</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="fu">=</span> <span class="dt">New</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  <span class="fu">|</span> <span class="dt">Done</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  <span class="fu">|</span> <span class="dt">Tasks</span></a></code></pre></div>
<p>自分的に，extensible を使う利点は3つある．</p>
<ol type="1">
<li>フィールド名と関数名の名前空間が別なので衝突が無い</li>
<li><code>type</code> 宣言によりレコードに対しいちいち型クラスのインスタンスを定義する必要が無い(既にあるものは)</li>
<li>型レベルリストによってフィールド全体に対する走査を行える</li>
</ol>
<p>逆にデメリットは，(2) にも関係するのだが，<code>type</code> 宣言のためインスタンスの定義が衝突することがしばしばある(これはインスタンスのスコープをコントロールできないという Haskell 全体での問題でもある)．</p>
<h4 id="拡張可能レコードのパーサー">拡張可能レコードのパーサー</h4>
<p>まずは拡張可能レコード(<code>Options</code> 型)のパーサーを書いてみる． バリアント(<code>SubCmd</code> 型)のは <code>undefined</code> としておこう． 細かい <code>optparse-applicative</code> の構文は割愛する．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">options ::</span> <span class="dt">Parser</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">options <span class="fu">=</span> hsequence</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="fu">$</span> <span class="fu">#</span>verbose <span class="fu">&lt;@=&gt;</span> switch (long <span class="st">&quot;verbose&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">&#39;v&#39;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Enable verbose mode: verbosity level \&quot;debug\&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">   <span class="fu">&lt;:</span> <span class="fu">#</span>date    <span class="fu">&lt;@=&gt;</span> optional (strOption (long <span class="st">&quot;date&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">&#39;d&#39;</span> <span class="fu">&lt;&gt;</span> metavar <span class="st">&quot;DATE&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Task&#39;s date&quot;</span>))</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">   <span class="fu">&lt;:</span> <span class="fu">#</span>subcmd  <span class="fu">&lt;@=&gt;</span> subcmdParser</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">subcmdParser <span class="fu">=</span> undefined</a></code></pre></div>
<p>拡張可能レコードの値を構築するには <code>#fieldName @= fieldValue</code> というの <code>&lt;:</code> で直列につないでいく(細かくは extensible の解説記事を読んで)． <code>&lt;@=&gt;</code> 演算子はモナドなフィールドの値を持ち上げてくれるバージョンの <code>@=</code> 演算子だ． <code>$</code> の右側は，正確には違うが，次の型のようなイメージとなる．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ch">&#39;[ Parser (&quot;verbose&quot; &gt;: Bool)</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"> , <span class="dt">Parser</span> (<span class="st">&quot;date&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Date</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"> , <span class="dt">Parser</span> (<span class="st">&quot;subcmd&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">SubCmd</span>)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"> ]</a></code></pre></div>
<p>Haskeller っであれば，後はリスト型で言う <code>sequence</code> できれば良さそうとわかるだろう． その型レベルリスト版が <code>hsequence</code> だ．</p>
<h4 id="拡張可能バリアントのパーサー">拡張可能バリアントのパーサー</h4>
<p>さて，今回の自分的なメインディッシュだ． 仮に通常の直和型であれば次のように書くだろう．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">subcmdParser <span class="fu">=</span> subparser</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">$</span> command <span class="st">&quot;new&quot;</span>   (pure <span class="dt">New</span> <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;add&quot;</span>   (<span class="dt">Add</span> <span class="fu">&lt;$&gt;</span> strArgument (metavar <span class="st">&quot;TEXT&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;done&quot;</span>  (<span class="dt">Done</span> <span class="fu">&lt;$&gt;</span> argument auto (metavar <span class="st">&quot;ID&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;tasks&quot;</span> (pure <span class="dt">Tasks</span> <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="ot">withInfo ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ParserInfo</span> a</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">withInfo opts <span class="fu">=</span> info (helper <span class="fu">&lt;*&gt;</span> opts) <span class="fu">.</span> progDesc</a></code></pre></div>
<p>この程度のサブコマンドならそこまで複雑じゃなく書けた． しかし悲しいことに，例えば <code>command &quot;tasks&quot;</code> の行が無くてもビルドは通る． 即ち，<strong>直和型に対し網羅性を型検査で保証することが出来ない</strong>．</p>
<h2 id="section"></h2>
<p>対して extensible のバリアントならどうだろうか． 理想的にはバリアントと同じフィールドを持つレコードの各要素が <code>ParserInfo a</code> であるような値から自動で導出してくれると良い． つまり次のように扱いたい．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">subcmdParser <span class="fu">=</span> variantFrom</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="fu">$</span> <span class="fu">#</span>new   <span class="fu">@=</span> (pure () <span class="ot">`withInfo`</span> <span class="st">&quot;Create a new task file. Note: if don&#39;t use --date option then use today&#39;s date.&quot;</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">   <span class="fu">&lt;:</span> <span class="fu">#</span>add   <span class="fu">@=</span> (strArgument (metavar <span class="st">&quot;TEXT&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Task contents&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;Add Task&quot;</span>)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">   <span class="fu">&lt;:</span> <span class="fu">#</span>done  <span class="fu">@=</span> (argument auto (metavar <span class="st">&quot;ID&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Done task from id&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;Done Task&quot;</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">   <span class="fu">&lt;:</span> <span class="fu">#</span>tasks <span class="fu">@=</span> (pure () <span class="ot">`withInfo`</span> <span class="st">&quot;Show Tasks&quot;</span>)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">variantFrom ::</span> <span class="dt">RecordOf</span> <span class="dt">ParserInfo</span> xs <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Variant</span> xs)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">variantFrom <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Wrapper</span> <span class="dt">ParserInfo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">  <span class="kw">type</span> <span class="dt">Repr</span> <span class="dt">ParserInfo</span> a <span class="fu">=</span> <span class="dt">ParserInfo</span> a</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">  _Wrapper <span class="fu">=</span> id</a></code></pre></div>
<p><code>@=</code> と <code>&lt;:</code> で構築したレコードが <code>Record = RecordOf Identity</code> ではなく，<code>RecordOf h</code> であるためには <code>h</code> が <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Wrapper.html#t:Wrapper"><code>Wrapper</code></a> 型クラスのインスタンスである必要がある(というかインスタンスでありさえすれば良い)．</p>
<h2 id="section-1"></h2>
<p>さてキモは <code>variantFrom</code> だ． 通常の直和型版の <code>subcmdParser</code> 関数を見ればわかるように，<code>command</code> 関数で作成した値をモノイドで畳み込めばいいので，お察しの通り(??) <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#v:hfoldMap"><code>hfoldMap</code></a> を使う． ついでに <code>command</code> の一引数目に渡すサブコマンドの文字列はフィールド名から取得するようにしよう． この場合，インデックスと <code>KnownSymbol</code> 制約を渡す必要があるので <code>hfoldMap</code> の代わりに <code>hfoldMapWithIndexFor</code> 関数を使う．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">variantFrom ::</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="dt">Forall</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>) xs <span class="ot">=&gt;</span> <span class="dt">RecordOf</span> <span class="dt">ParserInfo</span> xs <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Variant</span> xs)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">variantFrom <span class="fu">=</span> subparser <span class="fu">.</span> subcmdVariant</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    subcmdVariant <span class="fu">=</span> hfoldMapWithIndexFor (<span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>)) <span class="fu">$</span> \m x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">      <span class="kw">let</span> k <span class="fu">=</span> symbolVal (proxyAssocKey m)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">      <span class="kw">in</span> command k ((<span class="dt">EmbedAt</span> m <span class="fu">.</span> <span class="dt">Field</span> <span class="fu">.</span> pure) <span class="fu">&lt;$&gt;</span> getField x)</a></code></pre></div>
<p>結果として，<strong>extensible のバリアント版は網羅性を型検査によって検証できるようになった！</strong></p>
<h3 id="バージョンの表示">バージョンの表示</h3>
<p>バージョンの表示は他のコマンドと違い，コマンドが間違って(例えばサブコマンドが無い)いても <code>--version</code> という引数さえあれば優先的にバージョンを表示する必要がある． そのようなオプションを追加する場合には <a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:infoOption"><code>infoOption</code></a> 関数を使う．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Paths_taskpad</span>       <span class="kw">as</span> <span class="dt">Meta</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Data.Version</span>        (<span class="dt">Version</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Version</span>        <span class="kw">as</span> <span class="dt">Version</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Development.GitRev</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">main <span class="fu">=</span> run <span class="fu">=&lt;&lt;</span> execParser opts</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    opts <span class="fu">=</span> info (options <span class="fu">&lt;**&gt;</span> version Meta.version <span class="fu">&lt;**&gt;</span> helper)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">         <span class="fu">$</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="ot">version ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">version v <span class="fu">=</span> infoOption (showVersion v)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    <span class="fu">$</span> long <span class="st">&quot;version&quot;</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">   <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Show version&quot;</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17"><span class="ot">showVersion ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">showVersion v <span class="fu">=</span> unwords</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">  [ <span class="st">&quot;Version&quot;</span></a>
<a class="sourceLine" id="cb12-20" data-line-number="20">  , Version.showVersion v <span class="fu">++</span> <span class="st">&quot;,&quot;</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">  , <span class="st">&quot;Git revision&quot;</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22">  , <span class="fu">$</span>(gitHash)</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">  , <span class="st">&quot;(&quot;</span> <span class="fu">++</span> <span class="fu">$</span>(gitCommitCount) <span class="fu">++</span> <span class="st">&quot; commits)&quot;</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24">  ]</a></code></pre></div>
<p><code>&lt;**&gt;</code> 演算子はただの <code>flip (&lt;*&gt;)</code> だ． ちなみに，<code>version</code> と <code>helper</code> の適用順を入れ替えると <code>--help</code> の表示がほんの少しだけ変わる．</p>
<h3 id="バリアントと型クラス">バリアントと型クラス</h3>
<p>こっからは <code>run :: Options -&gt; IO ()</code> 関数を考える．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">run ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  date <span class="ot">&lt;-</span> maybe getTodaysDate pure <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  matchField</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    undefined <span class="co">-- ???</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>getTodaysDate</code> 関数は自身で定義しているとする． <code>--date</code> オプションを指定しなかった場合には今日の日付を取得する． 問題はサブコマンドの分岐だ．</p>
<p>バリアントの分岐には <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"><code>matchField</code></a> 関数を用いる． <code>matchField</code> 関数の型は <code>RecordOf (Match h r) xs -&gt; VariantOf h xs -&gt; r</code> となる． 一引数目のレコードと二引数目のバリアントの <code>xs</code> が等しいということから共通のフィールドを期待しているのが分かるだろう． レコード側の各フィールドに，各バリアントに対するフィールドの値を受け取り <code>r</code> 型の返り値の関数を記述するといった具合だ(この部分が <code>Match h r</code> に集約されている)．</p>
<h2 id="section-2"></h2>
<p>今回は，このレコードの構築に型クラスを用いる． 以下のような型クラスを定義する．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Run</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="ot">  run&#39; ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">Date</span> <span class="ot">-&gt;</span> <span class="dt">AssocValue</span> kv <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>実装は置いておいて，インスタンスを与えてみよう．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  run&#39; _ _ _ <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;add&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  run&#39; _ _ _ <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;done&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  run&#39; _ _ _ <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  run&#39; _ _ _ <span class="fu">=</span> undefined</a></code></pre></div>
<p><code>run</code> 関数の <code>matchField</code> 関数の引数は次のようになる．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">run ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  date <span class="ot">&lt;-</span> maybe getTodaysDate pure <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  matchField</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run&#39; m date <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>Proxy @ Run</code> の <code>@</code> の部分は <code>TypeApplications</code> 拡張のモノだ． フィールドの値は <code>Identity x</code> 型として来るので <code>runIdentity</code> 関数を用いて剥がし，<code>run' m date</code> へと適用する． もちろんサブコマンドのインスタンスを書き忘れていた場合は，ちゃんと型検査に引っかかる！</p>
<h3 id="rio-で大域変数">rio で大域変数</h3>
<p><code>rio</code> で大域変数を扱うには <code>RIO env</code> モナドを用いる． 適当なアプリケーションモナドを定義してやろう． 今回はひとつしか大域変数が無いのであんまりメリットを感じないかもしれないが…</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TaskPad</span> <span class="fu">=</span> <span class="dt">RIO</span> <span class="dt">Env</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="ch">&#39;[ &quot;date&quot; &gt;: Date</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">   ]</a></code></pre></div>
<p><code>run</code> 関数も書き直してやる．</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">run ::</span> <span class="dt">MonadUnliftIO</span> m <span class="ot">=&gt;</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  date <span class="ot">&lt;-</span> maybe getTodaysDate pure <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>date   <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">         <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  runRIO env <span class="fu">$</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    matchField</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run&#39; m <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">      (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a>
<a class="sourceLine" id="cb18-10" data-line-number="10"></a>
<a class="sourceLine" id="cb18-11" data-line-number="11"><span class="kw">class</span> <span class="dt">Run</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="ot">  run&#39; ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">AssocValue</span> kv <span class="ot">-&gt;</span> <span class="dt">TaskPad</span> ()</a></code></pre></div>
<p>試しに <code>new</code> サブコマンドを書いてみよう．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  run&#39; _ _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    date <span class="ot">&lt;-</span> asks (view <span class="fu">#</span>date)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    writeMemo <span class="fu">$</span> mkMemo date</a></code></pre></div>
<p><code>mkMemo</code> や <code>writeMemo</code> については次のように定義している． <code>Memo</code> 型も拡張可能レコードだ． 最近の extensible のアップデートで拡張可能レコードが <code>ToJson</code> 型クラスと <code>FromJson</code> 型クラスのインスタンスになったので，Yaml への変換は特にインスタンスを書くことなく行えるようになった．</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Yaml</span> <span class="kw">as</span> <span class="dt">Y</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Memo</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  <span class="ch">&#39;[ &quot;date&quot;  &gt;: Date</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">   , <span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">   , <span class="st">&quot;memo&quot;</span>  <span class="fu">&gt;:</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">   ]</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9"><span class="kw">type</span> <span class="dt">Task</span> <span class="fu">=</span> <span class="dt">Record</span> (<span class="dt">TaskFields</span> <span class="fu">++</span> <span class="ch">&#39;[&quot;children&quot; &gt;: [SubTask]])</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="kw">type</span> <span class="dt">SubTask</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="dt">TaskFields</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11"></a>
<a class="sourceLine" id="cb20-12" data-line-number="12"><span class="kw">type</span> <span class="dt">TaskFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  <span class="ch">&#39;[ &quot;name&quot; &gt;: Text</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">   , <span class="st">&quot;done&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-15" data-line-number="15">   ]</a>
<a class="sourceLine" id="cb20-16" data-line-number="16"></a>
<a class="sourceLine" id="cb20-17" data-line-number="17"><span class="ot">mkMemo ::</span> <span class="dt">Date</span> <span class="ot">-&gt;</span> <span class="dt">Memo</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18">mkMemo date</a>
<a class="sourceLine" id="cb20-19" data-line-number="19">    <span class="fu">=</span> <span class="fu">#</span>date  <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">   <span class="fu">&lt;:</span> <span class="fu">#</span>tasks <span class="fu">@=</span> mempty</a>
<a class="sourceLine" id="cb20-21" data-line-number="21">   <span class="fu">&lt;:</span> <span class="fu">#</span>memo  <span class="fu">@=</span> mempty</a>
<a class="sourceLine" id="cb20-22" data-line-number="22">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb20-23" data-line-number="23"></a>
<a class="sourceLine" id="cb20-24" data-line-number="24"><span class="ot">writeMemo ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Memo</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">writeMemo memo <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-26" data-line-number="26">  writeFileBinary (Text.unpack <span class="fu">$</span> memo <span class="fu">^.</span> <span class="fu">#</span>date <span class="fu">&lt;&gt;</span> <span class="st">&quot;.yaml&quot;</span>) (Y.encode memo)</a></code></pre></div>
<h3 id="rio-でロギング">rio でロギング</h3>
<p>ロギングは実用アプリケーションの重要な要素だろう． <code>rio</code> であればまぁまぁ簡単に書ける．</p>
<p>まずは <code>Env</code> にロギング用の関数を足してやる． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogFunc"><code>LogFunc</code></a> 型や <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:HasLogFunc"><code>HasLogFunc</code></a> 型クラスは <code>rio</code> ライブラリに定義されているものだ．</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="ch">&#39;[ &quot;date&quot;   &gt;: Date</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">   , <span class="st">&quot;logger&quot;</span> <span class="fu">&gt;:</span> <span class="dt">LogFunc</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">   ]</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">HasLogFunc</span> <span class="dt">Env</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  logFuncL <span class="fu">=</span> lens (view <span class="fu">#</span>logger) (\x y <span class="ot">-&gt;</span> x <span class="fu">&amp;</span> <span class="fu">#</span>logger <span class="ot">`set`</span> y)</a></code></pre></div>
<p>実はこれだけで <code>TaskPad</code> モナド(すなわち <code>RIO Env</code> モナド)の中で自由にロギング関数を呼べるようになる． 試しに <code>new</code> サブコマンドにロギングを足してみよう． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logInfo"><code>logInfo</code></a> 関数がロギング関数のひとつだ．</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  run&#39; _ _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    date <span class="ot">&lt;-</span> asks (view <span class="fu">#</span>date)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    writeMemo <span class="fu">$</span> mkMemo date</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    logInfo (display <span class="fu">$</span> <span class="st">&quot;create new task&#39;s file: &quot;</span> <span class="fu">&lt;&gt;</span> date <span class="fu">&lt;&gt;</span> <span class="st">&quot;.yaml&quot;</span>)</a></code></pre></div>
<p>あとは <code>run</code> 関数を書き換えよう(<code>Env</code> 型の中身が変わったので)．</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">run ::</span> <span class="dt">MonadUnliftIO</span> m <span class="ot">=&gt;</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  date    <span class="ot">&lt;-</span> maybe getTodaysDate pure <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  logOpts <span class="ot">&lt;-</span> logOptionsHandle stdout (opts <span class="fu">^.</span> <span class="fu">#</span>verbose)</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  withLogFunc logOpts <span class="fu">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>date   <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">           <span class="fu">&lt;:</span> <span class="fu">#</span>logger <span class="fu">@=</span> logger</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">           <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    runRIO env <span class="fu">$</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">      matchField</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">        (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run&#39; m <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">        (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>LogFunc</code> 型の値を得るには <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:withLogFunc"><code>withLogFunc</code></a> 関数を用いるのが良いだろう． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogOptions"><code>LogOptions</code></a> 型の値(ここでいう <code>logOpts</code>)を生成する <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logOptionsHandle"><code>logOptionsHandle</code></a> 関数の二引数目に <code>True</code> を与えることでログがデバッグ仕様になる(そういえば <code>Options</code> 型には <code>--verbose</code> オプションがあった)． ちなみに，デバッグ仕様のときにだけ表示するロギング関数として <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logDebug"><code>logDebug</code></a> 関数がある．</p>
<h2 id="おしまい">おしまい</h2>
<p>早く完成させるぞ</p>
  </div>
</div>
</article>
]]></summary>
</entry>

</feed>
