<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>ひげメモ</title>
    <link href="https://matsubara0507.github.io/feed.xml" rel="self" />
    <link href="https://matsubara0507.github.io" />
    <id>https://matsubara0507.github.io/feed.xml</id>
    <author>
        <name>MATSUBARA Nobutada</name>
        <email></email>
    </author>
    <updated>2018-12-05T00:00:00Z</updated>
    <entry>
    <title>Dhall を試して物足りない部分を補うツールを自作した</title>
    <link href="https://matsubara0507.github.io/posts/2018-12-05-create-dhall-ex.html" />
    <id>https://matsubara0507.github.io/posts/2018-12-05-create-dhall-ex.html</id>
    <published>2018-12-05T00:00:00Z</published>
    <updated>2018-12-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Dhall を試して物足りない部分を補うツールを自作した</h1>
    <p class="post-meta">
      <time datetime="2018-12-05" itemprop="datePublished">
        Dec 5, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/Dhall.html">Dhall</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>本稿は <a href="https://qiita.com/advent-calendar/2018/haskell">Haskell Advent Calendar 2018</a> 5日目の記事です．</p>
<p>Haskell Day 2018 の発表をきっかけに，兼ねてから気になっていた Dhall を試した． いくつかツールが欲しくなったので作りましたっていう話です．</p>
<p>作ったものはこれ:</p>
<ul>
<li><a href="https://github.com/matsubara0507/yaml-to-dhall">matsubara0507/yaml-to-dhall - GitHub</a></li>
<li><a href="https://github.com/matsubara0507/dhall-ex">matsubara0507/dhall-ex - GitHub</a></li>
</ul>
<p>ちなみに，今回作ったツールは現状の stack の stable resolver にある v1.5.1 を利用している．</p>
<h2 id="dhall">Dhall</h2>
<p><a href="https://github.com/dhall-lang/dhall-lang">Dhall</a> は静的型付けされた設定記述言語である． 多くの場合，プログラミング言語やアプリケーションに使われる設定ファイルには JSON や YAML が利用されている． プログラミング言語のビルドシステムのような設定ファイル一つ程度なら問題ないが，Kubernetes や Ansible のような膨大な設定ファイルが依存しあう場合，静的型付けプログラミング言語のようにコンパイルによる型検査を導入したくなるだろう． Dhall はそのための言語であり，また便利な関数が用意されているため，非常に再利用性の高い設定ファイルを記述できる．</p>
<h3 id="例">例:</h3>
<p>Dhall は静的片付け言語なので，まずは型を定義しよう:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" title="1">$ cat ./User.dhall</a>
<a class="sourceLine" id="cb1-2" title="2">{ homeDirectory : Text, privateKeyFile : Text, publicKeyFile : Text }</a></code></pre></div>
<p>このユーザ型の値はユーザ名から一意に生成されることは容易に想像できるだろう:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb2-1" title="1">$ cat ./makeUser.dhall</a>
<a class="sourceLine" id="cb2-2" title="2">  \(user_name : Text)</a>
<a class="sourceLine" id="cb2-3" title="3">-&gt;    <span class="kw">let</span> homeDirectory = <span class="st">&quot;/home/${user_name}&quot;</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="kw">in</span>  <span class="kw">let</span> privateKeyFile = <span class="st">&quot;${homeDirectory}/id_rsa&quot;</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="kw">in</span>  <span class="kw">let</span> publicKeyFile = <span class="st">&quot;${privateKeyFile}.pub&quot;</span></a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="kw">in</span>    { homeDirectory =</a>
<a class="sourceLine" id="cb2-10" title="10">            homeDirectory</a>
<a class="sourceLine" id="cb2-11" title="11">        , privateKeyFile =</a>
<a class="sourceLine" id="cb2-12" title="12">            privateKeyFile</a>
<a class="sourceLine" id="cb2-13" title="13">        , publicKeyFile =</a>
<a class="sourceLine" id="cb2-14" title="14">            publicKeyFile</a>
<a class="sourceLine" id="cb2-15" title="15">        }</a>
<a class="sourceLine" id="cb2-16" title="16">      : ./User.dhall</a></code></pre></div>
<p>この <code>./makeUser.dhall</code> は任意の文字列を与えると，それをユーザ名として <code>./User.dhall</code> 型の値を生成してくれる． さらに，高階関数を使って複数のユーザに対し一気に適用してみよう．</p>
<pre class="dhall"><code>$ cat ./users.dhall
let User = ./User.dhall

in  let map =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/0a7f596d03b3ea760a96a8e03935f4baa64274e1/Prelude/List/map

in  map Text User ./makeUser.dhall [ &quot;alice&quot;, &quot;bob&quot;, &quot;curry&quot; ] : List User</code></pre>
<p><code>map</code> には <a href="https://github.com/dhall-lang/dhall-lang/blob/master/Prelude/List/map">dhall のリポジトリにある標準パッケージの関数</a>を直接インポートしている． <code>map</code> の型は <code>∀(a : Type) → ∀(b : Type) → (a → b) → List a → List b</code> となっている． 基本的に Dhall で多相な高階関数を利用するときは，引数から直接型を与えてあげる必要がある．</p>
<p>さて，これを dhall でビルドすると次のような結果を得る:</p>
<pre class="dhall"><code>$ dhall &lt;&lt;&lt; ./users.dhall
[ { homeDirectory =
      &quot;/home/alice&quot;
  , privateKeyFile =
      &quot;/home/alice/id_rsa&quot;
  , publicKeyFile =
      &quot;/home/alice/id_rsa.pub&quot;
  }
, { homeDirectory =
      &quot;/home/bob&quot;
  , privateKeyFile =
      &quot;/home/bob/id_rsa&quot;
  , publicKeyFile =
      &quot;/home/bob/id_rsa.pub&quot;
  }
, { homeDirectory =
      &quot;/home/curry&quot;
  , privateKeyFile =
      &quot;/home/curry/id_rsa&quot;
  , publicKeyFile =
      &quot;/home/curry/id_rsa.pub&quot;
  }
]</code></pre>
<p>これは次のようなYAMLに対応し，<code>dhall-to-yaml</code> などのツールで変換可能だ:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">-</span> <span class="fu">privateKeyFile:</span><span class="at"> /home/alice/id_rsa</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">publicKeyFile:</span><span class="at"> /home/alice/id_rsa.pub</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="fu">homeDirectory:</span><span class="at"> /home/alice</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">-</span> <span class="fu">privateKeyFile:</span><span class="at"> /home/bob/id_rsa</span></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="fu">publicKeyFile:</span><span class="at"> /home/bob/id_rsa.pub</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="fu">homeDirectory:</span><span class="at"> /home/bob</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">-</span> <span class="fu">privateKeyFile:</span><span class="at"> /home/curry/id_rsa</span></a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="fu">publicKeyFile:</span><span class="at"> /home/curry/id_rsa.pub</span></a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="fu">homeDirectory:</span><span class="at"> /home/curry</span></a></code></pre></div>
<h2 id="section"></h2>
<p>また，ざっくりとしたイメージを得るには、先日あった <a href="https://wiki.haskell.jp/Workshop/HaskellDay/2018">Haskell Day 2018</a> での<a href="https://speakerdeck.com/syocy/dhall-haskellfalsexin-tanakiraapuri">発表資料</a>がわかりやすくてオススメ．</p>
<h3 id="使ってみて思うところ">使ってみて思うところ</h3>
<p>もしかしたら最新のバージョンであれば改善しているものもあるかもしれない．</p>
<ul>
<li>基本的な高階関数があり便利
<ul>
<li>map,fold,filter など</li>
</ul></li>
<li>普通のプログラミングのように式を再利用できる</li>
<li>型推論がザコい
<ul>
<li>パラメトリック多相を挟むとダメみたいですね</li>
</ul></li>
<li>結構ビルドエラーがエスパー
<ul>
<li>慣れの問題か？</li>
</ul></li>
<li>YAML のいわゆる連想配列への変換ができない</li>
<li>日本語が化ける ;;
<ul>
<li>まぁ原因はわかるので最新でも治ってなかったらPRしてみるか</li>
</ul></li>
</ul>
<h2 id="何に導入したか">何に導入したか</h2>
<p>弊社が企画してる学生向けの競技型イベントに関するシステムの設定ファイルを Dhall に置き換えてみた． そのシステムは，インフラ・スコアボード・デプロイツールの3つのリポジトリに別れており，ところどころ重複した設定が3つのリポジトリに存在する． そこで，設定用のリポジトリを作って，そこに Dhall で記述した設定を置き，そこから各リポジトリに設定を撒くような仕組みを考えることにした．</p>
<p><img src="/assets/create-dhall-ex/system-with-dhall.png" /></p>
<p>別に Dhall にしたからといって劇的に何かがよくなるわけでは無いのだが，ちょうど良いサンドボックスがあったのでイロイロと試してみる，というのが本音です（笑）</p>
<h2 id="yaml-to-dhall">yaml-to-dhall</h2>
<p>最初の方はせっせと手作業で変換していたが，何個かやって変換の仕方の勘所がわかって来た． そうなると後は作業でしか無いので，なんとかして大量にある設定ファイルを一括変換したい．</p>
<p>調べた限り，YAML から Dhall に変換するプログラムは無さそう(逆はもちろんあるけど)． なのですっごい雑なものを作った．</p>
<ul>
<li><a href="https://github.com/matsubara0507/yaml-to-dhall">matsubara0507/yaml-to-dhall - GitHub</a></li>
</ul>
<p>これは極めて単純なことしかできない． 数値は全て Float に変換されるし，Optional や空リストの書き方が間違っている． とりあえず変換して，手元のエディタで置換すればいいかなと思ったので雑なままである．</p>
<p>時間ができたらそのうち直すかも．</p>
<h2 id="dhall-ex">dhall-ex</h2>
<p>前述した通り，一組の設定ファイル群から複数のリポジトリの設定ファイルを生成したかったのでその仕組みを作った． dhall-ex は次のような設定ファイルを記述する:</p>
<pre class="dhall"><code>{ GH_TOKEN =
      [ &quot;matsubara0507:XXXX&quot; ] : Optional Text
  , root =
      &quot;configs&quot;
  , exports =
      [ { name =
            &quot;deploy-tool&quot;
        , repo =
            [ &quot;git-challenge/deploy-tool&quot; ] : Optional Text
        , paths =
            [ &quot;settings/orgs/orgs.yml&quot;
            , &quot;settings/orgs/review.yml&quot;
            ...
            ]
        }
      ...
      ]
}</code></pre>
<p>別にどっちでもよかったのだが，せっかくなので dhall-ex の設定ファイルも Dhall で記述するようにした． なので，具体例より<a href="https://github.com/matsubara0507/dhall-ex/blob/master/dhall/dhall-ex-type.dhall">型</a>を見た方が早いだろう．</p>
<pre class="dhall"><code>let Export = { name : Text, repo : Optional Text, paths : List Text }
in  { GH_TOKEN : Optional Text, root : Text, exports : List Export }</code></pre>
<p><code>root</code> は設定ファイル群を置くパスで，<code>exports</code> が設定ファイル群の更新先のリポジトリなどの情報だ． <code>repo</code> で GitHub リポジトリを指定し，<code>paths</code> で関連する設定ファイルを列挙する． 例の場合 <code>./config/settings/orgs/orgs.yml.dhall</code> を <code>./.dhall-ex/git-challenge/deploy-tool/settings/orgs/orgs.yml</code> に dhall でビルドする．</p>
<p>ちなみに Dhall のバージョンが古いので <code>Optional</code> がリストのリテラルを利用しているが，最新の Dhall には <code>Some</code> と <code>None</code> があるはず．</p>
<h3 id="機能">機能</h3>
<p>現状はこんな感じ:</p>
<pre><code>$ dhall-ex --help
dhall-ex - cli tool to support dhall

Usage: dhall-ex [-v|--verbose] [-c|--config PATH] [--only NAME] COMMAND
                [--version]

Available options:
  -v,--verbose             Enable verbose mode: verbosity level &quot;debug&quot;
  -c,--config PATH         Configuration file
  --only NAME              Exec subcommand only NAME in config
  --version                Show version
  -h,--help                Show this help text

Available commands:
  sort                     Sort record keys in dhall file
  echo                     Echo TEXT
  init                     Init dhall-ex work directory
  build                    Build Dhall file to YAML or JSON
  deploy                   Deploy builded config file to remote repository
  checkout                 Checkout repository in dhall workspace
  pull                     Pull repository in dhall workspace</code></pre>
<p><code>echo</code> は設定が正しく読み取れるかどうかにだけ使う雑機能． <code>sort</code> レコードのフィールドの順番を型に合わせて並び替えてくれるコマンドだ． 前述した <code>yaml-to-dhall</code> などを使った後に使った(並び変える必要はないんだけど，なんか読みやすいように)．</p>
<p><code>init</code> でリポジトリなどの初期化をし，<code>build</code> で設定ファイルを変換し，<code>deploy</code> でコミットとプッシュを行ってくれる． <code>checkout</code> や <code>pull</code> はただの git コマンドのラッパーだ．</p>
<p>また，<code>--only deploy-tool</code> などとすることでコマンドの実行を特定のリポジトリに限定できる．</p>
<h3 id="実装">実装</h3>
<p>実は内部実装はそこまで難しいことをしていない． Dhall のファイルを読み込み，ビルドし，それを dhall-ex の設定ファイルに則って出力するだけだ． <code>build</code> 以外のコマンドは <a href="http://hackage.haskell.org/package/shelly"><code>shelly</code></a> を使ってシェルスクリプトもどきを実行している．</p>
<h3 id="todo">ToDo</h3>
<ul>
<li>例外処理が雑なのを直す
<ul>
<li>だいたいこの部分が残る（笑）</li>
</ul></li>
<li>任意のコマンドを各リポジトリのワークスペースで実行できるようにする
<ul>
<li>なんか <code>git status</code> とか <code>git branch</code> とかしたい</li>
</ul></li>
<li>並行処理</li>
</ul>
<h1 id="おしまい">おしまい</h1>
<p>随分雑な記事になってしまった．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Stack の Docker Integration とイメージの自動更新</title>
    <link href="https://matsubara0507.github.io/posts/2018-12-02-stack-docker-travici.html" />
    <id>https://matsubara0507.github.io/posts/2018-12-02-stack-docker-travici.html</id>
    <published>2018-12-02T00:00:00Z</published>
    <updated>2018-12-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Stack の Docker Integration とイメージの自動更新</h1>
    <p class="post-meta">
      <time datetime="2018-12-02" itemprop="datePublished">
        Dec 2, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/Docker.html">Docker</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>本稿は <a href="https://qiita.com/advent-calendar/2018/haskell2">Haskell (その2) Advent Calendar 2018</a> 2日目の記事です．</p>
<p>最近よく CLI ツールを作るんですが，Haskell Stack を持ってなくても CLI ツールが使えるように，ツールを Docker イメージ化するようにしています． その流れを書き留めておこうというの本稿の趣旨です．</p>
<p>ちなみに，以下のリポジトリで実際に試しています．</p>
<ul>
<li><a href="https://github.com/matsubara0507/mdium">matsubara0507/mdium - GitHub</a></li>
<li><a href="https://github.com/matsubara0507/dhall-ex">matsubara0507/dhall-ex - GitHub</a></li>
</ul>
<h2 id="docker-integration">Docker Integration</h2>
<p>Haskell のビルドツール Stack には Dcoker Integration という機能がある（現在最新の安定版である v1.9.1 を想定しています）．</p>
<ul>
<li><a href="https://docs.haskellstack.org/en/v1.9.1/docker_integration/">Docker integration - The Haskell Tool Stack</a></li>
<li><a href="https://docs.haskellstack.org/en/v1.9.1/yaml_configuration/#image">Image - Yaml configuration - The Haskell Tool Stack</a></li>
</ul>
<p>Docker Integration として，ざっくりと次のような機能がある．</p>
<ol type="1">
<li>指定したイメージのコンテナでビルド・実行をする</li>
<li>ビルドした実行ファイルを含めた Docker イメージの作成</li>
</ol>
<p>(2 は正確には Docker Integration とは呼ばない)</p>
<p>ちなみに，Stack はワークスペース内の <code>.stack-work</code> の中に中間結果などを含むビルド結果をバージョンやビルド環境ごとに保存する． そして，<code>--docker</code> オプションでビルドすることで，ローカルではなく Docker のコンテナ内でビルドをしたり，生成したプログラムを実行したりできる． しかも，コンテナ内でビルドした場合でもビルド結果をローカルの <code>.stack-work</code> に保存するのだ．</p>
<h2 id="docker-イメージ内でビルド">Docker イメージ内でビルド</h2>
<p>まず stack.yaml に次のような設定を追加する．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">docker:</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="fu">enable:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">repo:</span><span class="at"> </span><span class="st">&quot;fpco/stack-build&quot;</span></a></code></pre></div>
<p><code>enable: true</code> にすると，以降の <code>--docker</code> オプションを省けるが，逆に普通にローカルでビルドしたい場合は <code>--no-docker</code> オプションが必要になる． <code>repo</code> でビルドするイメージを指定する． [<code>fpco/stack-build</code> はこれだ]（https://hub.docker.com/r/fpco/stack-build/）． stack.yaml の <code>resolver</code> からイメージタグを自動的に選んでくれるはずだ．</p>
<p>あとは次のコマンドでビルドできる．</p>
<pre><code># repo で指定した docker image の pull
$ stack docker pull

# docker コンテナ内でビルド
$ stack build --docker</code></pre>
<p>他にも細かい設定がかけるが割愛（上述したドキュメントを参照してください）．</p>
<h2 id="docker-イメージを作る">Docker イメージを作る</h2>
<p>stack.yaml に次の設定を追加する．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">image:</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="fu">container:</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="fu">name:</span><span class="at"> hoge</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="fu">base:</span><span class="at"> fpco/ubuntu-with-libgmp</span></a></code></pre></div>
<p><code>image.container.name</code> は生成する Docker イメージの名前で，<code>image.container.base</code> は生成する Docker イメージに使うベースイメージだ． ベースイメージは <code>docker.repo</code> などで指定したイメージのOSとあってさえいれば良い（ちなみに <code>fpco/stack-build</code> は <code>ubuntu:16.04</code>）． やってくれることは簡単で， <code>stack build --docker</code> で作成した実行ファイルをベースイメージの <code>local/bin</code> などにコピーするだけだ． なので，もし静的リンクしていない場合はリンクが含まれるベースイメージを指定すると良い(<a href="https://hub.docker.com/r/fpco/ubuntu-with-libgmp/"><code>fpco/ubuntu-with-libgmp</code></a> はそのために使っている)．</p>
<p>あとは次のコマンドでイメージの作成ができる．</p>
<pre><code># repo で指定した docker image の pull
$ stack --docker image container</code></pre>
<p><code>--docker</code> を指定しないとローカルでビルドした実行ファイルをコピーして，生成したイメージのコンテナで実行できなくなるので注意してください（もちろんローカルが ubuntu なら問題ないけど）． あと， stack によるイメージ作成方法では他に Dockerfile の <code>add</code> っぽいことと <code>entrypoints</code> っぽいことができるが，それ以上のことはできない． もっと複雑な設定をしたい場合は，生成したイメージをベースイメージにした Dockerfile を書いたり， Docker のマルチステージビルドを使って設定を上書きしたりするとと良いだろう．</p>
<h2 id="travisci-docker-hub">TravisCI + Docker Hub</h2>
<p>Docker Integration の欠点は Docker Hub の Automated build が使えない点だ． そこで，TravisCI を使って自動ビルドし，Docker Hub にプッシュするようにした． 次のような設定を travis.yml に書くと良いだろう．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">-</span> <span class="fu">stage:</span><span class="at"> push docker image</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">if:</span><span class="at"> branch = master</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="fu">script:</span></a>
<a class="sourceLine" id="cb5-4" title="4">   <span class="kw">-</span> stack docker pull</a>
<a class="sourceLine" id="cb5-5" title="5">   <span class="kw">-</span> stack --docker image container</a>
<a class="sourceLine" id="cb5-6" title="6">   <span class="kw">-</span> echo <span class="st">&quot;$DOCKER_PASSWORD&quot;</span> | docker login -u <span class="st">&quot;$DOCKER_USERNAME&quot;</span> --password-stdin</a>
<a class="sourceLine" id="cb5-7" title="7">   <span class="kw">-</span> docker push $TRAVIS_REPO_SLUG</a></code></pre></div>
<p>実は <code>stack --docker image container</code> でビルドまでしてくれる． Docker Hub には Token のようなものはないので <code>--password-stdin</code> とパイプを使って普通のパスワードでログインする． あとは <code>image.container.name</code> で指定する名前を <code>hoge</code> ではなく <code>user_name/repo_name</code> としておけば良い． もちろんこれは GitHub と Docker Hub のユーザ名が同じ場合にしか使えない． 違う場合は直接書いてね．</p>
<h1 id="おしまい">おしまい</h1>
<p>この方法なら実行ファイルしか入ってないイメージが出来上がるので軽いし， stack のビルド遅すぎて利用者側は厳しい問題も緩和するので最近のマイブームです．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell Day 2018 に参加してきた</title>
    <link href="https://matsubara0507.github.io/posts/2018-11-17-join-haskell-day-2018.html" />
    <id>https://matsubara0507.github.io/posts/2018-11-17-join-haskell-day-2018.html</id>
    <published>2018-11-17T00:00:00Z</published>
    <updated>2018-11-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell Day 2018 に参加してきた</h1>
    <p class="post-meta">
      <time datetime="2018-11-17" itemprop="datePublished">
        Nov 17, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>11月10日にあった「<a href="https://haskell-jp.connpass.com/event/92617/">Haskell Day 2018</a>」に参加してきたのでメモ書きです．</p>
<h2 id="午前中-ハンズオン">午前中 : ハンズオン</h2>
<p><a href="https://github.com/igrep">igrep</a> 氏が中心になって作成した <a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell"><code>makeMistakesToLearnHaskell</code></a> を使ったハンズオン． ぼくも少しだけコミットした．</p>
<p>当日の様子は，みなさんかなり黙々と作業してて静かだったが，Twitter 上で質問している人がチラチラいた． それらの Twitter の様子などをみてリアルタイムに修正を行なっていたのはすごい．</p>
<h2 id="午後">午後</h2>
<p>そのうちログミーが公開されるそうなので，概要と感想だけ．</p>
<h3 id="haskellを導入した話hrrの話">Haskellを導入した話/HRRの話</h3>
<p><a href="https://htmlpreview.github.io/?https://github.com/khibino/haskell-day-2018/blob/master/presentation.html">発表資料はこちら</a>．</p>
<p>10年近く職業 Haskeller をやっていた <a href="https://github.com/khibino">khibino</a> 氏が，当時 Haskell を導入するに至った話と，彼が作った <a href="https://hackage.haskell.org/package/relational-record">HRR</a> というライブラリの紹介 Perl に変わるグルー言語を求めて Haskell に行き着いたそうだ． 「GHC6.8 ですよ，GHC8.6 じゃなく，すごく無いですか？」すごい． HRRは面白そうだけど，使うタイミングがないや．</p>
<h3 id="servantで実現する高速かつ安全なapi">Servantで実現する高速かつ安全なAPI</h3>
<p><a href="https://speakerdeck.com/daishi/servantdexing-uan-quan-katugao-su-naapikai-fa">発表資料はこちら</a>．</p>
<p>同様に職業 Haskeller の <a href="https://github.com/nakaji-dayo">nakaji</a> 氏の発表． <a href="https://haskell-servant.github.io/">Servant</a> という型レベルに RSETful API を定義できるパッケージを実際にどのように使っているかという話． Servant は僕もよく使う． 「実際に依存してるパッケージの紹介」や「実運用する上で困ったこと」などもあって興味深い．</p>
<h3 id="並列並行言語haskell">並列並行言語Haskell</h3>
<p><a href="https://speakerdeck.com/syocy/bing-lie-bing-xing-yan-yu-haskell">発表資料はこちら</a>．</p>
<p>次のも含めて2本連続で <a href="https://github.com/syocy">syocy</a> 氏の発表． Haskell における並行・並列プログラミングについての紹介． 並行・並列プログラミングとして最近は Go・Elixir/Erlang・Rust などが注目されているが，Haskell は20年近く前から並行・並列に対して意識してる． おまけとして，ツールの話や並行並列系パッケージの話があって勉強になる． 余談として「<a href="https://a-tour-of-go-in-haskell.syocy.net/ja_JP/index.html">A Tour of Go in Haskell</a>」というのを作ったが，英語版も作ったところめっさ PR が来たという話をしてくれた． やっぱ分母の大きい自然言語は強い．</p>
<h3 id="dhall-haskellの新たなキラーアプリ">Dhall: Haskellの新たなキラーアプリ</h3>
<p><a href="https://speakerdeck.com/syocy/dhall-haskellfalsexin-tanakiraapuri">発表資料はこちら</a>．</p>
<p>個人的に今回一番面白かった． <a href="https://github.com/dhall-lang/dhall-lang">Dhall</a> というアプリケーションの紹介． Dhall は設定ファイルを記述するための DSL である． 設定ファイルの多くは YAML や JSON などで書かれるが，複数の YAML が複雑な依存関係を持っている場合(k8sとか)は静的解析したいよね？ しかし逆に「設定ファイルとしての領分」を守って欲しいという要求もある(汎用プログラミング言語としての役割はいらない)． そこで Dhall です！って感じの発表だった． 最後の導入事例として，自社の設定ファイル群を書き換えた話も面白かった．</p>
<h3 id="semigroupとはmonoidとは環とは">Semigroupとは？Monoidとは？環とは？</h3>
<p><a href="https://aiya000.github.io/Maid/haskell-day-2018-algebra/">発表資料はこちら</a>．</p>
<p><a href="https://github.com/aiya000">aiya</a> 氏の発表． 群や環などの代数的構造についての話． ステップバイステップに要件が増えていくのでわかりやすい説明だった．</p>
<p>ちなみに個人的な肌感として，このような数学的な素養がないと Haskell プログラミングができないかというと，そうでもないと思う． 僕自身は教養としてそのあたりを知ってはいるので微妙なところだが，普段 Haskell プログラミングしてる時に意識してはいないはず． ただ，いくつかの言語機能やライブラリは数学や論理学など学術的なバックグランドを持ってることがある． そのような場合は「なぜこのような仕様なのか」「どうしてこのような仕組みでうまくいくかのか」などは，学術論文にしか書いてないことが多い． そのため，そういう機能やライブラリの仕組みを <strong>ちゃんと</strong> 追おうとする場合は数学的素養がないと厳しいかもしれない．</p>
<h3 id="haskellで作るcli">Haskellで作るCLI</h3>
<p>僕の発表．後述します．</p>
<h3 id="gloss-動かして遊んで学ぶhaskell">gloss: 動かして遊んで学ぶHaskell</h3>
<p><a href="https://qiita.com/lotz/items/bdb04c771efc8919b79c">発表資料はこちら</a>．</p>
<p><a href="https://github.com/lotz84">lotz</a> 氏の発表． Haskell を勉強したあと何するかシリーズ，GUI 編． 作りたいものがはっきりないときは <a href="http://hackage.haskell.org/package/gloss">gloss</a> で振り子やライフゲームを作って遊んでみよう，という感じ． 僕自身はあんまり GUI に関心がないけど，実際に作りたいものがない場合はこういうので色々出力して手をうごしてみるのは正しい． 時間あるときになんか変なことできないか調べてみようかな．</p>
<h3 id="liszt-あるいは永続データ構造を真に永続させる方法">Liszt あるいは永続データ構造を真に永続させる方法</h3>
<p><a href="https://shared-assets.adobe.com/link/353213c2-281a-4a53-6cff-a52bff1314c1">発表資料はこちら</a>．</p>
<p>僕が愛用している extensible というライブラリの作者，<a href="https://github.com/fumieval">fumieval</a> 氏の発表． <a href="https://github.com/fumieval/liszt">liszt</a> を作り始めていたことは知っていたので気になっていた． Liszt は Kafka のような大量のデータを収集・配信するためのプログラムだそうだ(名前も <a href="https://ja.wikipedia.org/wiki/フランツ・カフカ">Franz Kafka</a> に対抗して <a href="https://ja.wikipedia.org/wiki/フランツ・リスト">Franz Liszt</a> らしい)． 内部のデータ構造として Skew binary random access list を要素としてもつ 2-3 木 を用いている． このあたりの詳しい話は「<a href="https://asciidwango.jp/post/160831986220/純粋関数型データ構造">純粋関数型データ構造</a>」を読むと良いとのこと(本の名前が上がった瞬間「ですよね〜」となってたw)．</p>
<h2 id="自分の話">自分の話</h2>
<p>Haskell で CLI を作るうえでの小話をした。 スライドはこれ． <iframe src="//www.slideshare.net/slideshow/embed_code/key/FQE1QxbCST8kYi" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe></p>
<p>実はどれも，既に記事におこしたことのあるネタだった．</p>
<ol type="1">
<li>コマンドライン引数
<ul>
<li><code>getArgs</code>・<code>GetOpt</code>・<code>optparse-applicative</code> について紹介</li>
<li><code>optparse-applicative</code> + <code>extensible</code> でサブコマンドも網羅性をチェック</li>
<li>「<a href="2018-05-10-make-cli-with-haskell-in-2018">オレ的 Haskell で CLI を作る方法 2018</a>」</li>
</ul></li>
<li>Alt. Prelude
<ul>
<li>Prelude 微妙だなって思ったら Alt. Prelude なパッケージを使ってみようという話</li>
<li>具体的には愛用している RIO を紹介した</li>
<li>「<a href="2018-04-13-try-rio-1">rio ライブラリを試す その１</a>」</li>
</ul></li>
<li>Stack Template
<ul>
<li>よく使う依存パッケージやアプリのインターフェースの書き方がパターン化してきたら Stack Template 化しようという話</li>
<li>Stack 1.9 から GitHub にあるテンプレートを参照できるようになった</li>
<li>GitHub にあるテンプレートを出力する stack-tpls コマンドの紹介</li>
<li>「<a href="2018-10-14-collect-stack-templates">stack-templates を集める with GraphQL</a>」</li>
</ul></li>
</ol>
<p>Haskell を知ってる人にとってはあんまり面白くない話題だったかもしれないが，まぁまぁ(発言が)ウケていたのでよかった(?)．</p>
<h2 id="おしまい">おしまい</h2>
<p>初心者がわかりやすく，玄人にもウケるネタってなんだろうね． 来年もやるかもしれないから考えておこう．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Markdownで書いたテキストをMediumへポストする(mdium)</title>
    <link href="https://matsubara0507.github.io/posts/2018-11-04-create-mdium.html" />
    <id>https://matsubara0507.github.io/posts/2018-11-04-create-mdium.html</id>
    <published>2018-11-04T00:00:00Z</published>
    <updated>2018-11-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Markdownで書いたテキストをMediumへポストする(mdium)</h1>
    <p class="post-meta">
      <time datetime="2018-11-04" itemprop="datePublished">
        Nov 4, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/application.html">application</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>完全な二番煎じです。</p>
<ul>
<li><a href="https://namaraii.com/markdownで書いたテキストをmediumへポストする-md2mid-60c6ff9efde">Markdownで書いたテキストをMediumへポストする(md2mid) – namaraii.com</a></li>
</ul>
<p>上記記事は，Go 言語で作った「Markdownで書いたテキストをMediumへポストする」CLIツールです． 弊社の技術記事置き場が Medium だったので，なんとか，ここのように Markdown で書けないかと調べていたら上記記事が出て来ました． もっといいのできないかなと車輪の再発明してみたけど，正直大して変わらなかったと思います．</p>
<h2 id="作ったもの">作ったもの</h2>
<p>md2mid と同様に Markdown で書いた記事を Medium に送信する CLI ツールを作った． 言わずもがな Haskell 製．</p>
<ul>
<li><a href="https://github.com/matsubara0507/mdium">matsubara0507/mdium - GitHub</a></li>
</ul>
<p>違いがあるとすれば:</p>
<ul>
<li>Haskell 製（しつこい）</li>
<li>環境変数を使ったトークンの管理</li>
<li><a href="https://hub.docker.com/r/matsubara0507/mdium/">Docker Image</a> 化してる</li>
</ul>
<h2 id="使い方">使い方</h2>
<p>まず CLI ツールをインストールするには，リポジトリをクローンして Haskell Stack で直接ビルド・インストールする:</p>
<pre><code>$ git clone https://github.com/matsubara0507/mdium.git
$ cd mdium
$ stack install mdium</code></pre>
<p>あるいは，Docker Image をプルしてくる:</p>
<pre><code>$ docker pull matsubara0507/mdium</code></pre>
<p>コマンドを使うには，まず Medium のトークンを<a href="https://medium.com/me/settings">設定</a>から生成する．</p>
<p><img src="/assets/create-mdium/generate-token.png" /></p>
<p>これを環境変数 <code>MEDIUM_TOKEN</code> にセットする． 直接でも良いし，<code>./.env</code> か <code>~/.env</code> に描いても良い． 下記のコマンドを実行することでトークンをチェックできる:</p>
<pre><code>$ mdium --me
Hi MATSUBARA Nobutada!!</code></pre>
<p>Docker イメージを使う場合にはこう:</p>
<pre><code>$ docker run --rm --env-file=&quot;$HOME/.env&quot; matsubara0507/mdium /bin/bash -c &quot;mdium --me&quot;</code></pre>
<p>トークンを渡すのは <code>--env-file</code> オプションでも <code>-e</code> オプションでも何でも良い． 実際に送信するには引数に送信したいファイルのパスを渡すだけ:</p>
<pre><code>$ medium example.md
post success, browse to: https://medium.com/@nobutada/e31f70013b36</code></pre>
<p>こうすることで指定した Markdown ファイルを draft として記事にしてくれる． ちなみに，<a href="https://github.com/matsubara0507/mdium/blob/master/example/example.md">これ</a>が下記のようになる．</p>
<p><img src="https://github.com/matsubara0507/mdium/raw/master/example/example.png" /></p>
<h2 id="medium-api">Medium API</h2>
<p>こっからは中身の話を少し． 中では Medium の API を使っている．</p>
<ul>
<li><a href="https://github.com/Medium/medium-api-docs#readme">Medium’s API documentation - GitHub</a></li>
</ul>
<p>その中に記事を送信する API があるのだが，驚いたことに送信できるファイルフォーマットに HTML と <strong>Markdown</strong> があったのだ． つまり，特別な処理をせずともこの API を使ってマークダウンを送信すれば良い．</p>
<h2 id="dockerise">Dockerise</h2>
<p>Haskell Stack には Docker integration というのがある（あんまりドキュメントにまとまっていない機能）． これを使うことで，指定した Docker image 内で Haskell プロジェクトをビルドしたり，ビルドした実行ファイルを突っ込んだ Docker image を作成したりできる．</p>
<p>今回は次のような設定を書き:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">docker:</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="fu">repo:</span><span class="at"> fpco/stack-build</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="fu">enable:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="fu">image:</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="fu">container:</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="fu">name:</span><span class="at"> matsubara0507/mdium</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="fu">base:</span><span class="at"> fpco/ubuntu-with-libgmp</span></a></code></pre></div>
<p>次のようなコマンドを実行することで Docker image を作成している:</p>
<pre><code>$ stack docker pull
$ stack --docker image container</code></pre>
<p>作成した Image は <code>docker push</code> コマンドでアップロードしている． また，この一連の流れを TravisCI で自動化している．</p>
<h2 id="todo">ToDo</h2>
<p>突貫で作ったのでいくつかやり残しがある．</p>
<ul>
<li>エラーハンドリング : 特に何も例外処理していないので</li>
<li>記事の更新 : 今はひたすら新しい記事を生成してしまう</li>
<li>タグやファイルフォーマットなどの細かい指定</li>
</ul>
<h1 id="おしまい">おしまい</h1>
<p>だいたい1日とちょっとでサクッと作った割にはいい感じのものができて満足． どんどん再発明していこ．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Hacktoberfest 2018 なので PR を5つ以上出してみた</title>
    <link href="https://matsubara0507.github.io/posts/2018-10-29-join-hacktoberfest-2018.html" />
    <id>https://matsubara0507.github.io/posts/2018-10-29-join-hacktoberfest-2018.html</id>
    <published>2018-10-29T00:00:00Z</published>
    <updated>2018-10-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Hacktoberfest 2018 なので PR を5つ以上出してみた</h1>
    <p class="post-meta">
      <time datetime="2018-10-29" itemprop="datePublished">
        Oct 29, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>去年に引き続き，Hacktoberfest に参加しました． 2017 は PR を4つでしたが，2018 は5つになったようです．</p>
<p>ちなみに Hacktoberfest がなんなのかや，参加方法については<a href="https://matsubara0507.github.io/posts/2017-10-11-join-hacktoberfest-2017.html">過去記事</a>を見てください（多分変わってなかったはず）．</p>
<h2 id="マイステータス">マイステータス</h2>
<p>10月29日時点のステータスはこんな感じ．</p>
<p><img src="/assets/join-hacktoberfest-2018/status.png" /></p>
<p><a href="https://hacktoberfest.digitalocean.com/stats/matsubara0507">ここから見れる</a>が，毎年同じリンクを使ってるっぽいので，2019年にこの記事を見にきた人は役に立たないリンクです(笑)</p>
<h2 id="出した-pr">出した PR</h2>
<p>自分のリポジトリに対する PR もカウントされてしまうので，それを除くと4リポジトリ7PRです．</p>
<ul>
<li><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/10">haskell-jp/makeMistakesToLearnHaskell ＃10</a></li>
<li><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/14">haskell-jp/makeMistakesToLearnHaskell ＃14</a></li>
<li><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/16">haskell-jp/makeMistakesToLearnHaskell ＃16</a></li>
<li><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/30">haskell-jp/makeMistakesToLearnHaskell ＃30</a></li>
<li><a href="https://github.com/commercialhaskell/stackage/pull/4078">commercialhaskell/stackage ＃4078</a></li>
<li><a href="https://github.com/Hacktoberfest-2018/Hello-world/pull/2483">Hacktoberfest-2018/Hello-world ＃2483</a></li>
<li><a href="https://github.com/stackbuilders/dotenv-hs/pull/101">stackbuilders/dotenv-hs ＃101</a></li>
</ul>
<p>とはいえ，haskell-jp は僕が活動しているコミュニティだし，stackage は Haskell 版 Gem の登録申請みたいなものだし，Hacktoberfest-2018/Hello-world はただの遊びだし． ちゃんと OSS に出した PR は一つだ…</p>
<h3 id="haskell-jpmakemistakestolearnhaskell">haskell-jp/makeMistakesToLearnHaskell</h3>
<p>このリポジトリは，2018/11/10 に開催予定の <a href="https://haskell-jp.connpass.com/event/92617/">Haskell Day 2018</a> の午前中で行われる予定のハンズオンで使うものです． <a href="https://github.com/igrep">igrep</a> 氏がメインで作っており，僕は CI を設定したり，Cabal から hpack に移行したり，コンテンツをいじるより環境周りをいじった．</p>
<h3 id="commercialhaskellstackage">commercialhaskell/stackage</h3>
<p>このリポジトリは Haskell のパッケージマネージャーである <a href="https://www.stackage.org/">Stackage</a> の管理リポジトリだ． <a href="http://hackage.haskell.org/">Hackage</a> というのもあるが，Hackage はパッケージストレージで，Stackage は Hackage にある各パッケージのバージョンのリゾルバを提供している（ビルド可能な組み合わせのこと）． 他の言語と異なり，リゾルバがあることで Haskell アプリケーションの作者が常に各パッケージ間のバージョンなどを細かく管理する必要はなく，特定のリゾルバを設定するだけで良い．</p>
<p>最近，Haskell のデファクトスタンダードなコンパイラ，GHC の最新バージョンである GHC 8.6 がリリースされた． それに伴い，Stackage の Nightly 版が GHC 8.6 へ移行され，多くのパッケージが disable された． 徐々にメジャーパッケージが reenable されたので，<a href="http://hackage.haskell.org/package/servant-kotlin">僕の作成したパッケージ</a>も reenable する PR を送ったのだ．</p>
<h3 id="hacktoberfest-2018hello-world">Hacktoberfest-2018/Hello-world</h3>
<p>これは Hacktoberfest が作ったお遊びリポジトリだ（多分）． いろんな言語の <code>Hello, world!</code> と出力するプログラムを集めるリポジトリのようだ．</p>
<p>僕は <a href="https://hacktoberfest.digitalocean.com/stats">Hacktoberfest のグローバルステータス</a>の「Highest Pull Request Count Repos」で見かけた（今は read-only になっているので PR は出せない）． 面白そうだったので，まだ無かった <a href="https://www.egison.org/">Egison</a> のプログラムを PR として出した．</p>
<pre class="egison"><code>(define $main
  (lambda [$args]
    (write &quot;Hello, world!\n&quot;)))</code></pre>
<p>Egison は江木さんという方が学生のころから作ってるパターンマッチ志向という独特のパラダイムを持つプログラミング言語だ． 全然関係ない話だが，今度<a href="https://connpass.com/event/102061/">ワークショップ</a>も行われる．</p>
<h3 id="stackbuildersdotenv-hs">stackbuilders/dotenv-hs</h3>
<p>唯一のまともな OSS な PR． <a href="http://hackage.haskell.org/package/dotenv">dotenv</a> という Haskell パッケージのリポジトリだ． 自分が作ってる <a href="https://github.com/matsubara0507/stack-tpls">CLI ツール</a>に使おうと思って README に書いてある通りに書いて見たら，動かなかったので，その修正 PR を出した．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Configuration.Dotenv</span> (loadFile, defaultConfig)</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">loadFile defaultConfig</a></code></pre></div>
<p>こう書くと <code>defaultConfig</code> が無いと怒られる．</p>
<pre class="shell"><code>Main.hs:17:42: error:
    Module ‘Configuration.Dotenv’ does not export ‘defaultConfig’
   |                             
17 | import           Configuration.Dotenv   (defaultConfig, loadFile)
   |                                          ^^^^^^^^^^^^^</code></pre>
<p>コードを見に行ったら <code>defaultConfig</code> を Reexport し忘れていたので，Reexport し直す PR を出した． 無事マージされ，最新バージョンでリリースされたので，もし同じバグを踏んだ人がいた場合はバージョン <code>0.6.0.3</code> 以上を試してほしい．</p>
<h2 id="t-shirt">T-shirt</h2>
<p>去年と同様に「You’ve completed the Hacktoberfest challenge!」というメールが届いた（10/27に）． メール本文にあるユニークなリンクを踏んでTシャツのリクエストを出せる． Tシャツのサイズと，自分の住所などを英語で記載するだけだ．</p>
<p>アメリカ以外はだいたいひと月ほどで届くらしい． ちなみに，去年は12月20日ぐらいに届いてた．</p>
<h3 id="おしまい">おしまい</h3>
<p>あんまり OSS っぽい PR を出せなくて残念…</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>GHC 8.6 がインストールできなかった</title>
    <link href="https://matsubara0507.github.io/posts/2018-10-28-ghc-8-6-error-no-gmp.html" />
    <id>https://matsubara0507.github.io/posts/2018-10-28-ghc-8-6-error-no-gmp.html</id>
    <published>2018-10-28T00:00:00Z</published>
    <updated>2018-10-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">GHC 8.6 がインストールできなかった</h1>
    <p class="post-meta">
      <time datetime="2018-10-28" itemprop="datePublished">
        Oct 28, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>対したことではないんだけど，日本語の記事が無っかたのでメモ． ちなみに OS は macOS Sierra (10.12.6) です．</p>
<h2 id="ghc-8.6-でビルドできない">GHC 8.6 でビルドできない</h2>
<p>現在 stackage の Nightly は最新の GHC バージョンである 8.6 がインストールされる． 結構パッケージも揃ってきたので，自分のパッケージもビルドしてみようかなと思って，resolver を Nightly に変えて <code>stack build</code> したら下記のようなエラーが出た．</p>
<pre class="shell"><code>$ stack build
Downloaded nightly-2018-10-26 build plan.    
Preparing to install GHC to an isolated location.
This will not interfere with any system-level installation.
Downloaded ghc-8.6.1.                                      
Installing GHC ...                                                                         
Received ExitFailure 2 when running
Raw command: /usr/bin/make install
Run from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/</code></pre>
<p><code>--vebose</code> を付けて詳細を見てみる．</p>
<pre class="shell"><code>$ stack build --verbose
Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0
2018-10-28 13:31:22.068195: [debug] Checking for project config at: /Users/username/git/haskell/servant-kotlin/stack.yaml
2018-10-28 13:31:22.069706: [debug] Loading project config file stack.yaml
 .
 .
 .
2018-10-28 13:32:21.355443: [debug] /Library/Developer/CommandLineTools/usr/bin/ranlib: file: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/lib/ghc-8.6.1/rts/libHSrts_thr_p.a(Select.thr_p_o) has no symbols
2018-10-28 13:32:21.621133: [debug] &quot;utils/ghc-cabal/dist-install/build/tmp/ghc-cabal-bindist&quot; copy libraries/ghc-prim dist-install &quot;strip&quot; &#39;&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/lib/ghc-8.6.1&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/share/doc/ghc-8.6.1/html/libraries&#39; &#39;v p dyn&#39;  
2018-10-28 13:32:21.841900: [debug] dyld: Library not loaded: /usr/local/opt/gmp/lib/libgmp.10.dylib
2018-10-28 13:32:21.842003: [debug]   Referenced from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/libraries/base/dist-install/build/libHSbase-4.12.0.0-ghc8.6.1.dylib
2018-10-28 13:32:21.842062: [debug]   Reason: image not found
2018-10-28 13:32:21.842273: [debug] make[1]: *** [install_packages] Abort trap: 6
2018-10-28 13:32:21.844303: [debug] make: *** [install] Error 2
Installing GHC ...
Received ExitFailure 2 when running
Raw command: /usr/bin/make install
Run from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/</code></pre>
<p>どうやら <code>/usr/local/opt/gmp/lib/libgmp.10.dylib</code> が無いみたいだ．</p>
<pre class="shell"><code>$ ls /usr/local/opt/gmp/lib/libgmp.10.dylib
ls: /usr/local/opt/gmp/lib/libgmp.10.dylib: No such file or directory</code></pre>
<p>これで検索すると，Ruby に関することだが <a href="https://stackoverflow.com/questions/34912946">StackOverflow があった</a>． 曰く，<code>gmp</code> パッケージを入れれば良いらしい（多くの人は他のどこかのタイミングで入ってるのかも）．</p>
<pre class="shell"><code>$ brew reinstall gmp
==&gt; Reinstalling gmp
==&gt; Downloading https://homebrew.bintray.com/bottles/gmp-6.1.2_2.sierra.bottle.tar.gz
######################################################################## 100.0%
==&gt; Pouring gmp-6.1.2_2.sierra.bottle.tar.gz
🍺  /usr/local/Cellar/gmp/6.1.2_2: 18 files, 3.1MB

$ ls /usr/local/opt/gmp/lib/libgmp.10.dylib
/usr/local/opt/gmp/lib/libgmp.10.dylib</code></pre>
<p>これで GHC 8.6 で <code>stack build</code> できるようになった．</p>
<h2 id="おしまい">おしまい</h2>
<p>まぁ一応ね，一応メモした．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>stack-templates を集める with GraphQL</title>
    <link href="https://matsubara0507.github.io/posts/2018-10-14-collect-stack-templates.html" />
    <id>https://matsubara0507.github.io/posts/2018-10-14-collect-stack-templates.html</id>
    <published>2018-10-14T00:00:00Z</published>
    <updated>2018-10-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">stack-templates を集める with GraphQL</h1>
    <p class="post-meta">
      <time datetime="2018-10-14" itemprop="datePublished">
        Oct 14, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/GraphQL.html">GraphQL</a> <a href="/tags/application.html">application</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Haskell Day の仕込みパート1です(2があるかは知らない)． stack の次期バージョン v1.9 で追加される namespaced template を試してみました．</p>
<p>ちなみに，現在 v1.9 はプレリリースになったので，下記コマンドで簡単にアップデートできます．</p>
<pre><code>$ stack upgrade --binary-version 1.9.0.1</code></pre>
<h2 id="namespaced-template">namespaced template</h2>
<p><code>stack new</code> で指定できるテンプレートを，GitHub などのオンラインからも取ってこれるようになった機能． 詳しくは開発段階からキャッチアップしてる e-bigmoon さんの記事を読むと良い．</p>
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html">namespaced templates - BIGMOON haskellers blog</a></li>
</ul>
<h3 id="作ってみた">作ってみた</h3>
<p>GitHub などで <code>stack-templates</code> という名前のリポジトリを作り，<code>hsfiles</code> という拡張子のテンプレートファイルをトップレベルに置く． 今回ぼくは <a href="https://github.com/matsubara0507/stack-templates">matsubara0507/stack-templates</a> というリポジトリを作り，２つ程作ってみた．</p>
<ul>
<li><code>get-opt-cli.hsfiles</code> : <a href="http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html"><code>System.Console.GetOpt</code></a> を用いたCLIのテンプレート</li>
<li><code>optparse-applicative-cli.hsfiles</code> : <a href="http://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> を用いたCLIのテンプレート</li>
</ul>
<p>どちらも，よくCLIを作るときの書き方をテンプレートとして起こしたもの． 普段は <a href="http://hackage.haskell.org/package/rio">rio</a> と <a href="http://hackage.haskell.org/package/extensible">extensible</a> を使っているので，単純に optparse-applicative などを使ったテンプレートという訳でもない．</p>
<h3 id="テストする">テストする</h3>
<p>できれば，テンプレートを <code>stack new</code> して <code>stack build</code> した時点ではコンパイルを通ってほしい． ということで <code>stack new</code> して <code>stack build</code> を試してくれるテストを <a href="https://github.com/matsubara0507/stack-templates/blob/7abc95184241c2df9f81ec1a45f9a662a98db05a/.travis.yml">TravisCI</a> に書いた．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">matrix:</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="kw">-</span> <span class="fu">env:</span><span class="at"> TEMPLATE=&quot;get-opt-cli&quot; ARGS=&quot;--resolver lts-12&quot;</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="fu">compiler:</span><span class="at"> </span><span class="st">&quot;: #stack 8.4.3&quot;</span></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="fu">addons:</span><span class="at"> </span><span class="kw">{</span><span class="fu">apt:</span><span class="at"> </span><span class="kw">{</span><span class="fu">packages:</span><span class="at"> </span><span class="kw">[</span>libgmp-dev<span class="kw">]}}</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="kw">-</span> <span class="fu">env:</span><span class="at"> TEMPLATE=&quot;optparse-applicative-cli&quot; ARGS=&quot;--resolver lts-12&quot;</span></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="fu">compiler:</span><span class="at"> </span><span class="st">&quot;: #stack 8.4.3&quot;</span></a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="fu">addons:</span><span class="at"> </span><span class="kw">{</span><span class="fu">apt:</span><span class="at"> </span><span class="kw">{</span><span class="fu">packages:</span><span class="at"> </span><span class="kw">[</span>libgmp-dev<span class="kw">]}}</span></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="fu">before_install:</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co"># install stack</span></a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="fu">install:</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="kw">-</span> stack new sample <span class="st">&quot;./$TEMPLATE&quot;</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="kw">- </span><span class="st">|</span></a>
<a class="sourceLine" id="cb2-16" title="16">  set -ex</a>
<a class="sourceLine" id="cb2-17" title="17">  cd sample</a>
<a class="sourceLine" id="cb2-18" title="18">  stack --no-terminal --install-ghc $ARGS test --bench --only-dependencies</a>
<a class="sourceLine" id="cb2-19" title="19">  set +ex</a>
<a class="sourceLine" id="cb2-20" title="20"><span class="fu">script:</span></a>
<a class="sourceLine" id="cb2-21" title="21"><span class="kw">- </span><span class="st">|</span></a>
<a class="sourceLine" id="cb2-22" title="22">  set -ex</a>
<a class="sourceLine" id="cb2-23" title="23">  stack --no-terminal $ARGS test --bench --no-run-benchmarks --no-haddock-deps</a>
<a class="sourceLine" id="cb2-24" title="24">  set +ex</a></code></pre></div>
<p><a href="https://github.com/commercialhaskell/stack-templates/blob/879f95dc44b24201bc64fcf8f4b9e2192c23dad4/test-templates.hs">commercialhaskell/stack-templates でもテストは書いてある</a>がぼくのはすごいシンプルだ．</p>
<h2 id="stack-templates-を集める">stack-templates を集める</h2>
<p>さて，これだけでは完全に e-bigmoon さんの劣化記事だ． なので，stack-templates を GitHub から集めてくる CLI ツールを作ることにした．</p>
<p>試したところ，GitHub の検索で <code>stack-template in:name</code> と検索すれば，それなりにヒットすることがわかった(間違いも多いが)． なので，ざっくりとした手順は:</p>
<ol type="1">
<li>検索系の GitHub API を叩く</li>
<li>stack-templates という名前のリポジトリの <code>*.hsfiles</code> というファイルだけ抽出</li>
<li>それらを出力</li>
</ol>
<p>ここで GitHub API v3 (RESTful API)を利用すると，リポジトリのファイル群を取得するのに検索系の API を叩いてから，各リポジトリの API を叩く必要がある． それは面倒だ． なので，ここ数年注目を集めている(？) GraphQL API (GitHub API v4)を試してみることにした．</p>
<h3 id="graphql">GraphQL</h3>
<p>ちょうどこの前に，友人から「GraphQL はいいぞ，API をなんども叩く必要がない．」と紹介されたので試してみた．</p>
<p>GitHub の API では <code>api.github.com/graphql</code> というエンドポイントに対し，POST メソッドでクエリを送信する．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">$ <span class="ex">curl</span> \</a>
<a class="sourceLine" id="cb3-2" title="2">  -H <span class="st">&quot;Authorization: bearer token&quot;</span> \</a>
<a class="sourceLine" id="cb3-3" title="3">  -X POST \</a>
<a class="sourceLine" id="cb3-4" title="4">  -d <span class="st">&quot;{ </span><span class="dt">\&quot;</span><span class="st">query</span><span class="dt">\&quot;</span><span class="st">: </span><span class="dt">\&quot;</span><span class="st"> ... </span><span class="dt">\&quot;</span><span class="st"> }&quot;</span> \</a>
<a class="sourceLine" id="cb3-5" title="5">  https://api.github.com/graphql</a></code></pre></div>
<p><code>...</code> のところにクエリを記述する． クエリは簡単な DSL のようになっており，クエリによってどんな形の JSON が返ってくるか(型のようなもの)やどんな値が返ってくるかが決まる． 例えば <code>stack-template in:name</code> 検索してヒットしたリポジトリの名前だけを取得してみよう． その場合は次のようなクエリを書く．</p>
<pre><code>query{
  search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 2) {
    repositoryCount,
    edges{
      node{ ... on Repository{ nameWithOwner } }
    }
  }
}</code></pre>
<p><code>first</code> は検索にヒットした最初の2つを返すという意味． 上限は 100 で，<code>first</code> ないしは逆の意味の <code>last</code> のどちらかは指定をする必要がある(そういうエラーが返ってくる)． <code>repositoryCount</code> は検索でヒットしたリポジトリの総数で，<code>edges</code> のところはリポジトリの <code>nameWithOwner</code> を返すように指定している． このように <code>{}</code> の中ではカンマ区切りで，返す JSON の形を指定できる． 具体的に何が指定できるかは <a href="https://developer.github.com/v4/query/">GitHub API v4 のドキュメント</a>を見ると良い． 試しに curl で叩いてみる(クエリ内の <code>&quot;</code> をエスケープすることを忘れずに):</p>
<pre><code>$ curl -H &quot;Authorization: bearer XXX&quot; -X POST -d &quot;{ \&quot;query\&quot;: \&quot; ... \&quot; }&quot; https://api.github.com/graphql
{&quot;data&quot;:{&quot;search&quot;:{&quot;repositoryCount&quot;:76,&quot;edges&quot;:[{&quot;node&quot;:{&quot;nameWithOwner&quot;:&quot;Azure/AzureStack-QuickStart-Templates&quot;}},{&quot;node&quot;:{&quot;nameWithOwner&quot;:&quot;commercialhaskell/stack-templates&quot;}}]}}}</code></pre>
<p>Connection とか Fields とかの用語については自分もよくわかってないので自分で調べてください． 今のところ，雰囲気で使ってる(笑)</p>
<h3 id="ファイルを集める">ファイルを集める</h3>
<p>さて，前述した結果(リポジトリ名)だけが欲しいなら GitHub API v3 でも十分だ． さらに，ファイルも取得してみよう． <a href="https://developer.github.com/v4/object/repository/">Repository のドキュメント</a> を眺めると <code>object</code> という Field がある． 察するに，リポジトリの任意のブランチ(<code>expression</code> で指定したもの)のコミットオブジェクトを返してくれるのだろう． (たぶん)stack-templates は全部 master が前提なので，master のコミットオブジェクトを取ってくる．</p>
<pre><code>... on Repository{
  nameWithOwner,
  object(expression:&quot;master&quot;){
    ... on Commit { }
  }
}</code></pre>
<p>ちなみに <code>... on Commit</code> というのは Inline Fragments と呼ばれるもので，object の型(サブタイプ？)が <code>Commit</code> だった場合に <code>Commit{}</code> 以下の Field を返すそうだ． git オブジェクトなので他にも <code>Tree</code> や <code>Blob</code> がある．</p>
<p>さて，あとは git オブジェクトの知識があれば簡単にかける． コミットオブジェクトにはツリーオブジェクト，要するにトップレベルのディレクトリのハッシュが記載されているので<a href="https://developer.github.com/v4/object/commit/">ドキュメント</a>からそれっぽいのを見つける． ツリーオブジェクトには，そのディレクトリに含まれるブロブオブジェクト(ファイル)とツリーオブジェクト(ディレクトリ)のハッシュが記載されてる． stack-templates は(今のところ)トップレベルに <code>*.hsfiles</code> を置かないといけないので，トップレベルのオブジェクトたちの名前を取得しよう:</p>
<pre><code>... on Repository{
  nameWithOwner,
  object(expression:&quot;master&quot;){
    ... on Commit { tree{ entries{ name, type } } }
  }
}</code></pre>
<p><code>type</code> には <code>blob</code> やら <code>tree</code> やらが入る． これで，検索にヒットした全てのリポジトリから <code>master</code> のトップレベルにあるファイルを取得するクエリが出来上がった．</p>
<h3 id="ページネーション">ページネーション</h3>
<p>今のところ，検索にヒットするリポジトリ数は76個なので <code>first: 100</code> とすれば全て取得できるが，今後ヒット数が100を超えたときようにページネーションの仕組みを整えておく． やり方は簡単で，<code>search</code> Connection のところで <a href=""><code>pageInfo</code></a> という Field を追加する．</p>
<pre><code>search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 1) {
  repositoryCount,
  pageInfo{
    endCursor,
    hasNextPage
  },
  edges{
    node{ ... on Repository{ .... } }
  }
}</code></pre>
<p><code>hasNextPage</code> は次のページが存在するかどうかを真偽値で返してくれる． <code>endCursor</code> はこのページの最後を表すハッシュ値？で，<code>search</code> Connection の引数(<code>type</code> とか <code>first</code> とかのとこ)に <code>after</code> で指定することで，それ以降の結果を取ってくる． このような <code>pageInfo</code> の情報さえあれば，プログラム内でループさせることは容易だろう．</p>
<h3 id="まとめると">まとめると</h3>
<p>次のようなクエリになった:</p>
<pre><code>query{
  search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 100) {
    repositoryCount,
    pageInfo{
      endCursor,
      hasNextPage
    },
    edges{
      node{ ... on Repository{
        nameWithOwner,
        object(expression:&quot;master&quot;){
          ... on Commit { tree{ entries{ name, type } } }
        }
      } }
    }
  }
}</code></pre>
<p>これを curl の引数に与えて叩くだけで 100 個分のリポジトリの全てのトップレベルファイル群を取得できる．</p>
<h3 id="stack-tpls">stack-tpls</h3>
<p>実際に作った CLI ツールは <a href="https://github.com/matsubara0507/stack-tpls"><code>matsubara0507/stack-tpls</code></a> というリポジトリに置いてある． 使い方は README に書いてある． 一覧を取得するには <code>stack-tpls --list</code> と打てば良い．</p>
<pre><code>$ stack-tpls --list
github:commercialhaskell/chrisdone.hsfiles
github:commercialhaskell/foundation.hsfiles
 .
 .
 .</code></pre>
<p>この結果を <code>stack new</code> の引数に与えることでそのまま利用できる． また，テンプレートの中身を確認したい場合は，<code>stack-tpls github:commercialhaskell/chrisdone.hsfiles</code> と引数に与えることで Raw を取ってきてくれる． リンクだけが欲しい場合は <code>--link</code> オプションを指定すると良い．</p>
<pre><code>$ stack-tpls --link github:commercialhaskell/rio.hsfiles
https://github.com/commercialhaskell/stack-templates/blob/master/rio.hsfiles</code></pre>
<h3 id="todo">ToDo</h3>
<p>一週間ほど前の思いつきからの突貫で作ったのでイロイロと抜けてる箇所があって:</p>
<ul>
<li>エラーハンドリングが雑</li>
<li>GitLab と BitBucket には対応していない</li>
<li>GraphQL の使い方がエレガントじゃない</li>
</ul>
<p>特に最後のがすごい気になっていて，現状は完全に文字列を埋め込んでいるだけなのだ． できれば，強力な型システムを利用した GitHub GraphQL Client ライブラリを作りたい(なんか昔に Haskell-jp で話題に上がったなぁ)．</p>
<h2 id="おしまい">おしまい</h2>
<p>GraphQL，クライアント側に取ってすごい便利．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell Servant で GitHub Webhook</title>
    <link href="https://matsubara0507.github.io/posts/2018-08-18-haskell-github-webhook.html" />
    <id>https://matsubara0507.github.io/posts/2018-08-18-haskell-github-webhook.html</id>
    <published>2018-08-18T00:00:00Z</published>
    <updated>2018-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell Servant で GitHub Webhook</h1>
    <p class="post-meta">
      <time datetime="2018-08-18" itemprop="datePublished">
        Aug 18, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/rio.html">rio</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>久々の投稿． とある事情で GitHub Webhook 用のサーバーを Haskell で書いたのでそのメモ書きです．</p>
<h2 id="やったこと">やったこと</h2>
<ul>
<li><a href="http://hackage.haskell.org/package/rio">rio</a> のロガーを Servant で使う</li>
<li><a href="http://hackage.haskell.org/package/servant-github-webhook">servant-github-webhook</a> を使って Webhook 用の Servant サーバーの構築</li>
</ul>
<p>実際に書いたコードは<a href="https://github.com/matsubara0507/git-plantation/commit/b93ed3398b30dbba105a580d58e947f131cf1a9a">この辺り</a>を見ると良いかな． 色々と途中のうえ，そもそも GitHub Webhook がメインではないリポジトリなので見にくい気がするけど．</p>
<h2 id="servant-で-rio-モナド">Servant で rio モナド</h2>
<p>これはまぁおまけですね． rio はロギングとかが便利なので，先に紹介して以降で利用する．</p>
<h3 id="ロガーの準備">ロガーの準備</h3>
<p>まずはロギング用のモナドを定義する．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE DataKinds        #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">{-# LANGUAGE TypeOperators    #-}</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb1-9" title="9">  &#39;[ <span class="st">&quot;logger&quot;</span> <span class="fu">&gt;:</span> <span class="dt">LogFunc</span></a>
<a class="sourceLine" id="cb1-10" title="10">   ]</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">instance</span> <span class="dt">HasLogFunc</span> <span class="dt">Env</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-13" title="13">  logFuncL <span class="fu">=</span> lens (view <span class="fu">#</span>logger) (\x y <span class="ot">-&gt;</span> x <span class="fu">&amp;</span> <span class="fu">#</span>logger <span class="ot">`set`</span> y)</a></code></pre></div>
<p>いわゆる Has パターンというやつ． これで <code>RIO Env</code> というのがロガーを扱えるモナドとなる．</p>
<h3 id="servant-でカスタムモナド">Servant でカスタムモナド</h3>
<p>Servent Server のメイン関数は下記のように定義できる．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.Wai.Handler.Warp</span> <span class="kw">as</span> <span class="dt">Warp</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">import</span>           <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-8" title="8">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-9" title="9">  logOpts <span class="ot">&lt;-</span> logOptionsHandle stdout <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-10" title="10">  withLogFunc logOpts <span class="fu">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>logger <span class="fu">@=</span> logger</a>
<a class="sourceLine" id="cb2-12" title="12">           <span class="fu">&lt;:</span><span class="ot"> nil ::</span> <span class="dt">Env</span></a>
<a class="sourceLine" id="cb2-13" title="13">    hPutBuilder stdout <span class="st">&quot;Listening on port 8080&quot;</span></a>
<a class="sourceLine" id="cb2-14" title="14">    Warp.run <span class="dv">8080</span> <span class="fu">$</span> app env</a>
<a class="sourceLine" id="cb2-15" title="15"></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb2-17" title="17">app <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p>さて，問題はこの <code>app</code> 関数だ． 普通は <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#t:Server"><code>Server</code></a> 型と <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#v:serve"><code>serve</code></a> 関数を用いて次のように書く．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb3-4" title="4">api <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb3-7" title="7">server <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="ot">app ::</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb3-10" title="10">app <span class="fu">=</span>  serve api server</a></code></pre></div>
<p><code>Server</code> 型の代わりに，カスタムモナドを利用するには <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#t:ServerT"><code>ServerT</code></a> 型と <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#v:hoistServer"><code>hoistServer</code></a> 関数を用いる． それぞれの型定義は次のようになっている．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">type</span> <span class="dt">Server</span> api <span class="fu">=</span> <span class="dt">ServerT</span> api <span class="dt">Handler</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">serve ::</span> <span class="dt">HasServer</span> api &#39;[] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> <span class="dt">Server</span> api <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="ot">hoistServer ::</span> <span class="dt">HasServer</span> api &#39;[] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> m x <span class="ot">-&gt;</span> n x) <span class="ot">-&gt;</span> <span class="dt">ServerT</span> api m <span class="ot">-&gt;</span> <span class="dt">ServerT</span> api n</a></code></pre></div>
<p>さぁあとは型パズルだ！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb5-2" title="2">server <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb5-5" title="5">app env <span class="fu">=</span> serve api <span class="fu">$</span> hoistServer api (runRIO env) server</a></code></pre></div>
<p>これで　<code>server</code> 関数で呼び出す， API ごとの関数で <code>logInfo</code> のような rio のロギング関数を呼ぶことができる．</p>
<h2 id="servant-で-github-webhhok">Servant で GitHub Webhhok</h2>
<p>さて色々準備ができたので，いよいよ GitHub Webhook の方に話を移す． Haskell Servant で GitHub Webhook を使うには <a href="http://hackage.haskell.org/package/servant-github-webhook">servant-github-webhook</a>というパッケージを使う． 意外と，このパッケージの使い方を書いた記事がなく手間取ったのでまとめる．</p>
<h3 id="ping-api-を作る">ping API を作る</h3>
<p>ping API は GitHub Webhook の設定がうまくできてるかを確認する API だ．</p>
<p><img src="/assets/haskell-github-webhook/ping-event.jpg" /></p>
<p>ping API は次のように設定すれば良い．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">import</span>           <span class="dt">GitHub.Data.Webhooks.Events</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">import</span>           <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">import</span>           <span class="dt">Servant.GitHub.Webhook</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;hook&quot;</span> <span class="fu">:&gt;</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">type</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb6-8" title="8">      <span class="fu">=</span> <span class="dt">GitHubEvent</span> &#39;[ <span class="dt">&#39;WebhookPingEvent</span> ]</a>
<a class="sourceLine" id="cb6-9" title="9">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">PublicEvent</span></a>
<a class="sourceLine" id="cb6-10" title="10">        <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">JSON</span>] ()</a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb6-13" title="13">server <span class="fu">=</span> pingWebhook</a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="ot">pingWebhook ::</span></a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="dt">RepoWebhookEvent</span> <span class="ot">-&gt;</span> ((), <span class="dt">PublicEvent</span>) <span class="ot">-&gt;</span> <span class="dt">Plant</span> ()</a>
<a class="sourceLine" id="cb6-17" title="17">pingWebhook _ (_, ev) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-18" title="18">  logInfo <span class="fu">$</span> <span class="st">&quot;Hook Ping Event: &quot;</span> <span class="fu">&lt;&gt;</span> displayShow ev</a></code></pre></div>
<p>GitHub Webhook を使うには Servant の Context 機能でシークレットキーを渡す必要がある．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">import</span>           <span class="dt">System.Environment</span>       (getEnv)</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-4" title="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">let</span> key <span class="fu">=</span> gitHubKey <span class="fu">$</span> fromString <span class="fu">&lt;$&gt;</span> getEnv <span class="st">&quot;GH_SECRET&quot;</span></a>
<a class="sourceLine" id="cb7-7" title="7">    Warp.run <span class="dv">8080</span> <span class="fu">$</span> app env key</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span> <span class="dt">PublicEvent</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb7-10" title="10">app env key <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-11" title="11">  serveWithContext api (key <span class="fu">:.</span> <span class="dt">EmptyContext</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-12" title="12">    hoistServerWithContext api context (runRIO env) server</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="ot">context ::</span> <span class="dt">Proxy</span> &#39;[ <span class="dt">GitHubKey</span> <span class="dt">PublicEvent</span> ]</a>
<a class="sourceLine" id="cb7-15" title="15">context <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>実行するときは <code>GH_SECRET</code> 環境変数に設定した文字列を GitHub Webhook の設定の Secret に書き込む．</p>
<h3 id="push-api-を加える">push API を加える</h3>
<p>もう一個 API を生やしてみよう．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">type</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb8-2" title="2">      <span class="fu">=</span> <span class="dt">GitHubEvent</span> &#39;[ <span class="dt">&#39;WebhookPingEvent</span> ]</a>
<a class="sourceLine" id="cb8-3" title="3">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">PublicEvent</span></a>
<a class="sourceLine" id="cb8-4" title="4">        <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">JSON</span>] ()</a>
<a class="sourceLine" id="cb8-5" title="5">   <span class="fu">:&lt;|&gt;</span> <span class="dt">GitHubEvent</span> &#39;[ <span class="dt">&#39;WebhookPushEvent</span> ]</a>
<a class="sourceLine" id="cb8-6" title="6">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">PushEvent</span></a>
<a class="sourceLine" id="cb8-7" title="7">        <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">JSON</span>] ()</a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb8-10" title="10">server <span class="fu">=</span> pingWebhook <span class="fu">:&lt;|&gt;</span> pushWebhook</a>
<a class="sourceLine" id="cb8-11" title="11"></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="ot">pushWebhook ::</span> <span class="dt">RepoWebhookEvent</span> <span class="ot">-&gt;</span> ((), <span class="dt">PushEvent</span>) <span class="ot">-&gt;</span> <span class="dt">Plant</span> ()</a>
<a class="sourceLine" id="cb8-13" title="13">pushWebhook _ (_, ev) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-14" title="14">  logInfo <span class="fu">$</span> <span class="st">&quot;Hook Push Event: &quot;</span> <span class="fu">&lt;&gt;</span> displayShow ev</a></code></pre></div>
<p>これでビルドすると次のようなエラーが出てくる．</p>
<pre><code>Main.hs:38:3: error:
    • No instance for (HasContextEntry &#39;[] (GitHubKey&#39; () PushEvent))
        arising from a use of ‘serveWithContext’
    • In the expression: serveWithContext api (key :. EmptyContext)
      In the expression:
        serveWithContext api (key :. EmptyContext)
          $ hoistServerWithContext api context (runRIO env) server
      In an equation for ‘app’:
          app env key
            = serveWithContext api (key :. EmptyContext)
                $ hoistServerWithContext api context (runRIO env) server
   |
38 |   serveWithContext api (key :. EmptyContext) $ hoistServerWithContext api context (runRIO env) server
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
<p><a href="https://github.com/tsani/servant-github-webhook/issues/13#issuecomment-408463124">ググった結果</a>，こうするといいらしい．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">import</span>           <span class="dt">Servant.GitHub.Webhook</span>    <span class="kw">hiding</span> (<span class="dt">GitHubKey</span>, gitHubKey)</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Servant.GitHub.Webhook</span>   (<span class="dt">GitHubKey</span>, gitHubKey)</a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb10-7" title="7">app env key <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="ot">context ::</span> <span class="dt">Proxy</span> &#39;[ <span class="dt">GitHubKey</span> ]</a>
<a class="sourceLine" id="cb10-10" title="10">context <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb10-11" title="11"></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="co">-- HACK</span></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="kw">newtype</span> <span class="dt">GitHubKey</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-14" title="14">  <span class="dt">GitHubKey</span> (<span class="kw">forall</span> result<span class="fu">.</span> <span class="dt">Servant.GitHub.Webhook.GitHubKey</span> result)</a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16"><span class="ot">gitHubKey ::</span> <span class="dt">IO</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span></a>
<a class="sourceLine" id="cb10-17" title="17">gitHubKey k <span class="fu">=</span> <span class="dt">GitHubKey</span> (Servant.GitHub.Webhook.gitHubKey k)</a>
<a class="sourceLine" id="cb10-18" title="18"></a>
<a class="sourceLine" id="cb10-19" title="19"><span class="kw">instance</span> <span class="dt">HasContextEntry</span> &#39;[<span class="dt">GitHubKey</span>] (<span class="dt">Servant.GitHub.Webhook.GitHubKey</span> result) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-20" title="20">  getContextEntry (<span class="dt">GitHubKey</span> x <span class="fu">:.</span> _) <span class="fu">=</span> x</a></code></pre></div>
<h1 id="おしまい">おしまい</h1>
<p>ちなみに，手元で試すときには ngrok を使った． 便利．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Ruby Hack Challenge ＃4 に参加してきた</title>
    <link href="https://matsubara0507.github.io/posts/2018-07-01-join-ruby-hack-challenge4.html" />
    <id>https://matsubara0507.github.io/posts/2018-07-01-join-ruby-hack-challenge4.html</id>
    <published>2018-07-01T00:00:00Z</published>
    <updated>2018-07-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Ruby Hack Challenge ＃4 に参加してきた</h1>
    <p class="post-meta">
      <time datetime="2018-07-01" itemprop="datePublished">
        Jul 1, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Ruby.html">Ruby</a> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>先週 <a href="https://cookpad.connpass.com/event/88471/">Ruby Hack Cavalage #4</a> に参加してきたので，そのメモ書きです．</p>
<p>ちなみに，Ruby は自分が最初に触ったスクリプト言語で，現在仕事で使っているメインの言語です． 推し言語(Haskell)とは異なり，動的型付けではありますが，「<a href="http://i.loveruby.net/ja/rhg/book/">Rubyソースコード完全解説</a>」や「<a href="https://tatsu-zine.com/books/ruby-under-a-microscope-ja">Rubyのしくみ</a>」のような処理系内部を紹介してる読み物も多く，かなり好きな方な言語です.</p>
<h2 id="ruby-hack-challenge">Ruby Hack Challenge</h2>
<p>Ruby 処理系をハックしようというイベントで，コアコミッタの <a href="https://github.com/mame">mame</a> 氏と <a href="https://github.com/ko1">ko1</a> 氏が講師として企画してくれている． ふたりが在籍しているということで，会場はクックパッドで行っている．</p>
<p>毎回，前半に講義的なものがあり，後半で実際に手を動かして Ruby にコミットするといった感じらしい． ただし，2日開催だったり，半日だったり時間はまちまち(今回は半日だった)． イベント名的に Ruby のハッカソンみたいだが，Ruby 処理系はC言語で書かれているためC言語を書くことになる(笑)</p>
<h3 id="カバレッジ特別会">カバレッジ特別会</h3>
<p>しかし，4回目(となっているが3回目が見当たらないので3回目かも？？)となる今回は，カバレッジ特別会ということで多くの人たちが Ruby を読み書きしていた． なぜかというと，標準ライブラリは Ruby で書かれており，今回は標準ライブラリのテストカバレッジをあげても良かったからだ． というか，C で書かれているコア部分は mame 氏が昔に大分カバレッジをあげてしまったため，そっちをやるのは難しいと言っていた．</p>
<h2 id="section"></h2>
<p>C言語の部分で残っているとすれば本質的に難しい部分(副作用とか並行並列とか)か最近追加された部分か(JITとか？)だそうだ．</p>
<h3 id="資料">資料</h3>
<p>今までのも含め，資料は(いくつか？)公開されているので誰でも見れる．</p>
<ul>
<li><a href="https://github.com/ko1/rubyhackchallenge">ko1/rubyhackchallenge - GitHub</a></li>
<li><a href="https://www.slideshare.net/mametter/ruby-hack-challenge-4">Ruby Hack Challenge #4 カバレッジ特別回 資料 - SlideShare</a></li>
</ul>
<p>また Gitter で連絡を取り合っており，実は誰でも参加できる(たぶん)．</p>
<ul>
<li><a href="https://gitter.im/rubyhackchallenge/Lobby">rubyhackchallenge/Lobby - Gitter</a></li>
</ul>
<h2 id="section-1"></h2>
<p>ちなみに，ボクはもともとこのイベントは参加したいなぁと思っていた(言語好きなので)．</p>
<h2 id="ruby-のテストカバレッジ">Ruby のテストカバレッジ</h2>
<p>Ruby のテストカバレッジは Web から確認できる．</p>
<ul>
<li><a href="https://rubyci.s3.amazonaws.com/debian8-coverage/ruby-trunk/lcov/index.html">LCOV - code coverage report</a></li>
</ul>
<p>これを見てカバレッジの低いところにねらい目を付けてテストを追加する(ないしは不要な実装なら削る)． 標準ライブラリのいくつかは個別に GitHub で管理されているので，GitHub で管理されてる場合はそっちに PR を投げれば良いようだ(今回は事情が共有されてたせいかすぐマージされた)．</p>
<h2 id="section-2"></h2>
<p>ちなみに，<a href="https://github.com/ruby/ruby/blob/trunk/doc/maintainers.rdoc">ココ</a>を見ると誰がメンテナーで，どこに報告すれば良いかが書いてある．</p>
<h3 id="環境構築">環境構築</h3>
<p>は事前にやっとくと，当日はすんなりコミットできた(構築方法はスライドに書いてある)． 事前にって言ってもぼくは行きの電車でやったけど(笑)</p>
<p>Windows と Mac を持ってるけど，どっちも素でやるのは難しいので，Debian の Docker コンテナの上で構築した． Docker ありがとう！ ビルドがめっちゃ遅いけどね！</p>
<h2 id="当日やったこと">当日やったこと</h2>
<p>すっっっごい簡単にカバレッジをあげれそうなのがあったのサクッと直して PR をだした．</p>
<ul>
<li><a href="https://github.com/ruby/cmath/pull/2">Add test for coverage by matsubara0507 · Pull Request #2 · ruby/cmath</a></li>
</ul>
<p><code>CMath</code> モジュールは <code>Math</code> モジュールをラップして複素数(Complex number)にまで対応させたものだ． そのため，虚数を含む複素数に関するテストしかなく，実数に関するテストが無かったためカバレッジが低かった． 愚直に全部書いたら100%まで行きましたちゃんちゃんってだけです．</p>
<h2 id="section-3"></h2>
<p>ちなみに，他にも4,5個ほど PR が出ていた． すごいね！</p>
<h2 id="もくもく会">もくもく会</h2>
<p>あと，Ruby Hack Challenge もくもく会というのがあるらしいので行ってみたい(<a href="https://connpass.com/event/93131/">次回はこれ</a>)． MJIT のコードとか読んでみたいよね． それと型検査(はどうなるかまだ分からないらしいけど)．</p>
<h2 id="おしまい">おしまい</h2>
<p>そういえば，ko1 氏がお子さんと奥さんを連れてきていた(たぶん)． そういう事に理解のある会社っていいなぁと感じた．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>rust-reversi やってみた</title>
    <link href="https://matsubara0507.github.io/posts/2018-06-21-challenge-rust-reversi.html" />
    <id>https://matsubara0507.github.io/posts/2018-06-21-challenge-rust-reversi.html</id>
    <published>2018-06-21T00:00:00Z</published>
    <updated>2018-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">rust-reversi やってみた</h1>
    <p class="post-meta">
      <time datetime="2018-06-21" itemprop="datePublished">
        Jun 21, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Rust.html">Rust</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>現在，会社の同期と週一で Rust の勉強会をやっていまして，普段は <a href="https://y-yu.github.io/trpl-2nd-pdf/book.pdf">The Rust Programming Language: 2nd Edition の日本語版</a> を輪読しているのですが，3月ぐらいにあった <a href="https://internship.cookpad.com/2018/spring/">Cookpad Spring 1day Internship 2018</a> の Rust コースの資料が公開されたため，皆でハッカソンしてみました．</p>
<ul>
<li><a href="https://github.com/KOBA789/rust-reversi">KOBA789/rust-reversi: Cookpad Spring 1day Internship 2018 Rust プログラミングコースで使用された講義資料 - GitHub</a></li>
</ul>
<p>今回は実際にやってみてのメモ書きです． 主に躓いたとこのメモです．</p>
<h2 id="section"></h2>
<p>ちなみに，ぼくの Rust の経験値は上記の本を17章まで読んだだけで，ほとんど書いたことないですね(輪読は7章，自分で少し先を読んでいる)． あと，<a href="https://github.com/matsubara0507/rust-reversi/tree/reversi-impl">回答はフォークしてあげてあります</a>．</p>
<h3 id="躓いたところ">躓いたところ</h3>
<p>めちゃくちゃしょーーーーもないところばっかです(笑)</p>
<ol type="1">
<li>固定長配列の map</li>
<li>パターンマッチの変数</li>
<li>index の x と y が逆</li>
<li>既に置いてあるかの検査</li>
</ol>
<h3 id="何を作っているか">何を作っているか</h3>
<p>そもそも課題は何かというと，オセロ(リバーシ)です． 試しに実行してみるとこんな感じ．</p>
<pre><code>$ cargo run
   Compiling reversi v0.1.0 (file:///Users/nobutada.matsubara/git/rust/rust-reversi)
     Running `target/debug/reversi`
  a b c d e f g h
 +-+-+-+-+-+-+-+-+
1| | | | | | | | |
 +-+-+-+-+-+-+-+-+
2| | | | | | | | |
 +-+-+-+-+-+-+-+-+
3| | | | | | | | |
 +-+-+-+-+-+-+-+-+
4| | | |O|X| | | |
 +-+-+-+-+-+-+-+-+
5| | | |X|O| | | |
 +-+-+-+-+-+-+-+-+
6| | | | | | | | |
 +-+-+-+-+-+-+-+-+
7| | | | | | | | |
 +-+-+-+-+-+-+-+-+
8| | | | | | | | |
 +-+-+-+-+-+-+-+-+

B 2 - 2 W
Turn: Black
  a b c d e f g h
 +-+-+-+-+-+-+-+-+
1| | | | | | | | |
 +-+-+-+-+-+-+-+-+
2| | | | | | | | |
 +-+-+-+-+-+-+-+-+
3| | | | | | | | |
 +-+-+-+-+-+-+-+-+
4| | |X|X|X| | | |
 +-+-+-+-+-+-+-+-+
5| | | |X|O| | | |
 +-+-+-+-+-+-+-+-+
6| | | | | | | | |
 +-+-+-+-+-+-+-+-+
7| | | | | | | | |
 +-+-+-+-+-+-+-+-+
8| | | | | | | | |
 +-+-+-+-+-+-+-+-+

B 4 - 1 W
Turn: White
0) c3
1) c5
2) e3</code></pre>
<p>全部一から作れではなく，リポジトリをクローンして <code>src/coord.rs</code> と <code>src/board.rs</code> の <code>unimplemented!();</code> となっている個所の実装を与えるだけ． ご丁寧なことにテストも用意してあるので，<code>cargo test</code> を実行しまくってオールグリーンになれば出来上がり(たぶん)．</p>
<h2 id="section-1"></h2>
<p>ちなみに，クライアントの同期が <code>unimplemented();</code> に感動していたので，調子に乗って <a href="https://matthew.brecknell.net/post/hole-driven-haskell/">Hole driven Programming</a> について語ってしまった．</p>
<h3 id="関数が呼べない">0. 関数が呼べない</h3>
<p>ゼロ引数関数は <code>xxx.method</code> はダメで，<code>xxx.method()</code> しなきゃいけないってのが何度もあった(笑) 普段は Haskell を書いているせいですね．</p>
<h3 id="固定長配列の-map">1. 固定長配列の map</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/// 指定の色の石を指定の位置に置いたとき、指定の方向へひっくり返せる石の数を返す</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">fn</span> get_flip(&amp;<span class="kw">self</span>, piece: Piece, <span class="kw">mut</span> pos: Coord, dir: Coord) -&gt; <span class="dt">u8</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">    ...</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co">/// 指定の色の石を指定の位置に置いたときの `Move` を返す</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">/// 戻り値の `Move` には8方向分の `get_flip` の結果が含まれる</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">fn</span> get_move(&amp;<span class="kw">self</span>, piece: Piece, pos: Coord) -&gt; Move <span class="op">{</span></a>
<a class="sourceLine" id="cb2-9" title="9">    <span class="pp">unimplemented!</span>();</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>とあり</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">pub</span> <span class="kw">struct</span> Move <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">pub</span> pos: Coord,</a>
<a class="sourceLine" id="cb3-3" title="3">    flips: <span class="op">[</span><span class="dt">u8</span>; <span class="dv">8</span><span class="op">]</span>,</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">const</span> DIRECTIONS: <span class="op">[</span>Coord; <span class="dv">8</span><span class="op">]</span> = <span class="op">[</span></a>
<a class="sourceLine" id="cb3-7" title="7">    Coord(-<span class="dv">1</span>, -<span class="dv">1</span>), <span class="co">//左上</span></a>
<a class="sourceLine" id="cb3-8" title="8">    Coord(<span class="dv">0</span>, -<span class="dv">1</span>),  <span class="co">//真上</span></a>
<a class="sourceLine" id="cb3-9" title="9">    Coord(<span class="dv">1</span>, -<span class="dv">1</span>),  <span class="co">//右上</span></a>
<a class="sourceLine" id="cb3-10" title="10">    Coord(-<span class="dv">1</span>, <span class="dv">0</span>),  <span class="co">//真左</span></a>
<a class="sourceLine" id="cb3-11" title="11">    Coord(<span class="dv">1</span>, <span class="dv">0</span>),   <span class="co">//真右</span></a>
<a class="sourceLine" id="cb3-12" title="12">    Coord(-<span class="dv">1</span>, <span class="dv">1</span>),  <span class="co">//左下</span></a>
<a class="sourceLine" id="cb3-13" title="13">    Coord(<span class="dv">0</span>, <span class="dv">1</span>),   <span class="co">//真下</span></a>
<a class="sourceLine" id="cb3-14" title="14">    Coord(<span class="dv">1</span>, <span class="dv">1</span>),   <span class="co">//右下</span></a>
<a class="sourceLine" id="cb3-15" title="15"><span class="op">]</span>;</a></code></pre></div>
<p>なので，<code>move.flips = DIRECTIONS.map (|dir| self.get_flip(piece, pos, dir))</code> って具合にいけそうだと思ったのだ． しかし，悲しいことに組み込みでは <strong>固定長配列に対するこのような操作はないようだ</strong>(間違っていたらゴメンナサイ…)． なので結局諦めて for 文を回した…</p>
<p>何か良い方法があったら教えて欲しい.</p>
<h3 id="パターンマッチの変数">2. パターンマッチの変数</h3>
<p>すごい間抜けな話です．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" title="1"><span class="co">/// 指定の色の石を指定の位置に置いたとき、指定の方向へひっくり返せる石の数を返す</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">///</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">/// * `piece` - 置く石の色</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">/// * `pos` - 石を置く位置</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">/// * `dir` - ひっくり返せる石を探す方向。`DIRECTIONS` の要素のいずれかが渡される</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">fn</span> get_flip(&amp;<span class="kw">self</span>, piece: Piece, <span class="kw">mut</span> pos: Coord, dir: Coord) -&gt; <span class="dt">u8</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="kw">let</span> opponent = piece.opponent();</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="kw">let</span> <span class="kw">mut</span> cnt = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-10" title="10">        pos += dir;</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">match</span> <span class="kw">self</span>.matrix<span class="op">[</span>pos<span class="op">]</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-12" title="12">            <span class="cn">None</span>           =&gt; <span class="kw">return</span> <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb4-13" title="13">            <span class="cn">Some</span>(piece)    =&gt; <span class="kw">return</span> cnt,</a>
<a class="sourceLine" id="cb4-14" title="14">            <span class="cn">Some</span>(opponent) =&gt; cnt += <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb4-15" title="15">        <span class="op">}</span></a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="op">}</span></a></code></pre></div>
<p>とか書いていたが，全然テストが通らない． それもそのはずで <strong>パターンマッチの中の変数は代入になる</strong> だけで，<code>if self.matrix[target] == Some(piece) { ... }</code> とは異なる． シャーディングぅぅぅぅぅとか思ったけど，きっと警告出てたよね…</p>
<pre><code>warning: unreachable pattern
   --&gt; src/board.rs:165:17
    |
165 |                 Some(opponent) =&gt; cnt += 1,
    |                 ^^^^^^^^^^^^^^
    |
    = note: #[warn(unreachable_patterns)] on by default

warning: unused variable: `opponent`
   --&gt; src/board.rs:158:13
    |
158 |         let opponent = piece.opponent();
    |             ^^^^^^^^ help: consider using `_opponent` instead
    |
    = note: #[warn(unused_variables)] on by default

warning: unused variable: `piece`
   --&gt; src/board.rs:164:22
    |
164 |                 Some(piece)    =&gt; return cnt,
    |                      ^^^^^ help: consider using `_piece` instead

warning: unused variable: `opponent`
   --&gt; src/board.rs:165:22
    |
165 |                 Some(opponent) =&gt; cnt += 1,
    |                      ^^^^^^^^ help: consider using `_opponent` instead</code></pre>
<p>出てたね…</p>
<h3 id="index-の-x-と-y-が逆">3. index の x と y が逆</h3>
<p>普段二重配列とかやんないからさ…</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb6-1" title="1"><span class="co">/// ベクトルを表現する構造体</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">pub</span> <span class="kw">struct</span> Coord(<span class="kw">pub</span> <span class="dt">i8</span>, <span class="kw">pub</span> <span class="dt">i8</span>);</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">/// `[]` 演算子のオーバーロード</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">impl</span> Index&lt;Coord&gt; <span class="kw">for</span> Matrix <span class="op">{</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">type</span> Output = <span class="dt">Option</span>&lt;Piece&gt;;</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="co">/// 第一引数に与えられた座標の状態を返す</span></a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="co">/// 座標が盤面の範囲外であった場合は None が返る。</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="kw">fn</span> index(&amp;<span class="kw">self</span>, index: Coord) -&gt; &amp;<span class="kw">Self</span>::Output <span class="op">{</span></a>
<a class="sourceLine" id="cb6-10" title="10">        <span class="kw">if</span> <span class="kw">self</span>.is_in_range(index) <span class="op">{</span></a>
<a class="sourceLine" id="cb6-11" title="11">            &amp;<span class="kw">self</span>.<span class="dv">0</span><span class="op">[</span>index.<span class="dv">0</span> <span class="kw">as</span> <span class="dt">usize</span><span class="op">][</span>index.<span class="dv">1</span> <span class="kw">as</span> <span class="dt">usize</span><span class="op">]</span></a>
<a class="sourceLine" id="cb6-12" title="12">        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-13" title="13">            &amp;<span class="cn">None</span></a>
<a class="sourceLine" id="cb6-14" title="14">        <span class="op">}</span></a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="op">}</span></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="op">}</span></a></code></pre></div>
<p>とか最初書いていた． <code>Coord</code> 型はひとつ目が X 座標でふたつ目が Y 座標． <code>&amp;self.0[index.0 as usize][index.1 as usize]</code> のところが逆ですね…</p>
<h3 id="既に置いてあるかの検査">4. 既に置いてあるかの検査</h3>
<p><code>moves</code> のテストが何故かとおらない． <code>moves</code> は盤上の全ての合法手，“手” を表す <code>Move</code> 型は手を打つ場所(<code>Coord</code> 型)と各方向のひっくり返す数を持っている，を列挙する関数．</p>
<pre><code>---- board::tests::test_board_moves stdout ----
	thread &#39;board::tests::test_board_moves&#39; panicked at &#39;assertion failed: `(left == right)`
  left: `6`,
 right: `37`&#39;, src/board.rs:366:9</code></pre>
<p>めちゃくちゃ多い． テストを読んでイロイロと出力させてみたところ，既にピースが置いてある場合のチェックを忘れていた(バカ)．</p>
<h3 id="オールグリーン">オールグリーン</h3>
<pre><code>$ cargo test
   Compiling reversi v0.1.0 (file:///Users/nobutada.matsubara/git/rust/rust-reversi)
    Finished dev [unoptimized + debuginfo] target(s) in 1.27 secs
     Running target/debug/deps/reversi-ae2013b8997f878b

running 12 tests
test board::tests::test_board_count_mut ... ok
test board::tests::test_board_get_move ... ok
test board::tests::test_board_get_flip ... ok
test board::tests::test_board_do_move ... ok
test board::tests::test_do_flip ... ok
test board::tests::test_matrix_index ... ok
test board::tests::test_board_moves ... ok
test board::tests::test_matrix_index_mut ... ok
test board::tests::test_matrix_is_in_range ... ok
test board::tests::test_move_is_legal ... ok
test coord::tests::test_coord_add ... ok
test coord::tests::test_coord_add_assign ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code></pre>
<h2 id="感想">感想</h2>
<p>基本構文を覚えてないので，とりあえず雑に書いてビルドして怒られたら直す，的なことをしながら，静的検査さいこ～とか言いながらやってた(疲れてる)． おかげで <code>&amp;</code> とか <code>*</code> を雑にあつかってて良くないですね． まぁ楽しかったからいいけど．</p>
<h2 id="おまけ">おまけ</h2>
<p><code>get_flip</code> 関数のところ，関数型プログラマーらしく(?)再帰にして見た. 速度は変わるんかな？</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">fn</span> get_flip(&amp;<span class="kw">self</span>, piece: Piece, pos: Coord, dir: Coord) -&gt; <span class="dt">u8</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="kw">self</span>.go_get_flip(piece, pos, dir).unwrap_or(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb9-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">fn</span> go_get_flip(&amp;<span class="kw">self</span>, piece: Piece, pos: Coord, dir: Coord) -&gt; <span class="dt">Option</span>&lt;<span class="dt">u8</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="kw">let</span> target = pos + dir;</a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="kw">if</span> <span class="kw">self</span>.matrix<span class="op">[</span>target<span class="op">]</span> == <span class="cn">Some</span>(piece.opponent()) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-8" title="8">        <span class="kw">self</span>.go_get_flip(piece, target, dir).map(|x| x + <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-9" title="9">    <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="kw">self</span>.matrix<span class="op">[</span>target<span class="op">]</span> == <span class="cn">Some</span>(piece) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-10" title="10">        <span class="cn">Some</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb9-11" title="11">    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-12" title="12">        <span class="cn">None</span></a>
<a class="sourceLine" id="cb9-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb9-14" title="14"><span class="op">}</span></a></code></pre></div>
<h2 id="おしまい">おしまい</h2>
<p>Haskell 版でも作ってみようかしらん．</p>
  </div>
</div>
</article>
]]></summary>
</entry>

</feed>
