<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>ひげメモ</title>
    <link href="https://matsubara0507.github.io/feed.xml" rel="self" />
    <link href="https://matsubara0507.github.io" />
    <id>https://matsubara0507.github.io/feed.xml</id>
    <author>
        <name>MATSUBARA Nobutada</name>
        <email></email>
    </author>
    <updated>2021-01-01T00:00:00Z</updated>
    <entry>
    <title>rules_haskell でパッケージの依存関係がうまく解決できない時</title>
    <link href="https://matsubara0507.github.io/posts/2021-01-01-missing-dependencies-with-rules_haskell.html" />
    <id>https://matsubara0507.github.io/posts/2021-01-01-missing-dependencies-with-rules_haskell.html</id>
    <published>2021-01-01T00:00:00Z</published>
    <updated>2021-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>ちょっとした rules_haskell で起きたエラーに関するメモ書きです（Bazel の話）．</p>
<h2 id="起きたエラー">起きたエラー</h2>
<p>具体的には「<a href="/posts/2021-01-01-mdium-with-gist.html">MarkdownをMediumへポストするときにコードブロックをGistのリンクにする</a>」をやっていたときに起きたエラー：</p>
<pre><code>$ bazel build //:mdium
...
ERROR: /.../external/stackage/BUILD.bazel:1277:22: HaskellCabalLibrary @stackage//:hslua failed (Exit 1) cabal_wrapper failed: error executing command bazel-out/host/bin/external/rules_haskell/haskell/cabal_wrapper lib:hslua hslua-1.3.0 true external/stackage/hslua-1.3.0/Setup.hs external/stackage/hslua-1.3.0 ... (remaining 9 argument(s) skipped)

Use --sandbox_debug to see verbose messages from the sandbox
Setup.hs: Encountered missing dependencies:
base-compat &gt;=0.10
...</code></pre>
<p>base-compat はバージョン 0.11.2 が入ってるはずなので，この依存関係は満たしているはずなのに…？？？</p>
<h2 id="原因">原因</h2>
<p>hslua-1.3.0 の Cabal ファイルを読んでたら気づいた：</p>
<pre class="cabal"><code>  if impl(ghc &lt; 8.8)
    build-depends:       base-compat          &gt;= 0.10
    hs-source-dirs:      prelude
    other-modules:       Prelude</code></pre>
<p><code>if impl(ghc &lt; 8.8)</code> の部分． もしかして，Bazel の依存パッケージを解決してるときにこの分岐がうまくいってない？つまり GHC のバージョンが間違ってる？</p>
<p>正解でした．</p>
<h2 id="対処">対処</h2>
<p>GHC のバージョンは rules_haskell の <code>rules_haskell_toolchains</code> の <code>version</code> 引数で指定できる． 指定しない場合は デフォルトで 8.6.5 が利用される． 決して，<code>stack_snapshot</code> で指定した LTS から自動で解決されない（はず）． 僕はこの仕様をすっかり忘れており，LTS では GHC 8.8 系を利用しているのに GHC 8.6 でビルドをしていた． 結果として，依存パッケージの解決がめちゃくちゃになっていたのだ．</p>
<p>対処法は簡単で，<code>rules_haskell_toolchains</code> で <code>version</code> を指定すれば良い：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>http_archive(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;rules_haskell&quot;</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    strip_prefix <span class="op">=</span> <span class="st">&quot;rules_haskell-3b8182ca5287cf93687fff1cefd98910f683b679&quot;</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    urls <span class="op">=</span> [<span class="st">&quot;https://github.com/tweag/rules_haskell/archive/3b8182ca5287cf93687fff1cefd98910f683b679.tar.gz&quot;</span>],</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    sha256 <span class="op">=</span> <span class="st">&quot;85f269adfecfc5760fae6017608f7efebfccb719c22c7e71af03c4887f54b08e&quot;</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>load(</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    <span class="st">&quot;@rules_haskell//haskell:toolchain.bzl&quot;</span>,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    <span class="st">&quot;rules_haskell_toolchains&quot;</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>rules_haskell_toolchains(version <span class="op">=</span> <span class="st">&quot;8.8.4&quot;</span>)</span></code></pre></div>
<p>ちなみに，rules_haskell の現在の最新のバージョンタグである v0.13 を使わずに，直接最新のコミットハッシュを指定しているのは，v0.13 では LTS で利用している 8.8.4 が無いからだ．</p>
<h2 id="おしまい">おしまい</h2>
<p>本当にちょっとしたことだけど念のため記事にしておいた． rules_haskell が流行ったあかつきにはきっと助かる人が出るはず笑</p>
  </div>]]></summary>
</entry>
<entry>
    <title>MarkdownをMediumへポストするときにコードブロックをGistのリンクにする</title>
    <link href="https://matsubara0507.github.io/posts/2021-01-01-mdium-with-gist.html" />
    <id>https://matsubara0507.github.io/posts/2021-01-01-mdium-with-gist.html</id>
    <published>2021-01-01T00:00:00Z</published>
    <updated>2021-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>「<a href="/posts/2018-11-04-create-mdium.html">Markdownで書いたテキストをMediumへポストする(mdium)</a>」で作った Markdown で書いたテキストを Medium へポストするツールですが，ちょくちょく改良を続けてます． 今回は Pandoc を利用して、コードブロックを Gist のリンクに置き換える機能を追加したので，そのことについてのメモ書きです．</p>
<h2 id="medium-のシンタックスハイライト">Medium のシンタックスハイライト</h2>
<p>Medium は普通にコードブロックを記述するとシンタックハイライトされずダサい：</p>
<p><img src="/assets/mdium-with-gist/medium-code-block.jpg"></img></p>
<p>これをなんとかする方法の一つに Gist のリンクを貼って埋め込みにするというのがある：</p>
<p><img src="/assets/mdium-with-gist/medium-code-block-using-gist.jpg"></img></p>
<p>ただし，一つの Gist に一つのファイルを設定しないといけないのでコスパが最悪で，1つの記事に対してこんな感じに大量の Gist を作る必要がある：</p>
<p><img src="/assets/mdium-with-gist/many-gists-for-medium.jpg"></img></p>
<p>最近はその Gist を使った方法をとっているが，いちいち Gist に手で置き換えるのはめんどいよね． ってことで，自作ツールの mdium が自動でやってくれるようにした．</p>
<h2 id="作る">作る</h2>
<p>作業 PR はこれです：</p>
<ul>
<li><a href="https://github.com/matsubara0507/mdium/pull/9">Add gist option · #9 · matsubara0507/mdium</a></li>
</ul>
<h3 id="gist-を作成する-api">Gist を作成する API</h3>
<p><a href="https://docs.github.com/rest/reference/gists#create-a-gist">GitHub API には Gist を作成するものがある</a>． しかし，私がよく使う <a href="https://hackage.haskell.org/package/github">Haskell の GitHub クライアント</a>には Gist を作成する関数が作られてなかった． ので，作成してとりあえず PR を出した：</p>
<ul>
<li><a href="https://github.com/phadej/github/pull/455">Add endpoint to create gist · #455 · phadej/github</a></li>
</ul>
<p>実は（リファレンスからは分かりにくい？）注意点があって：</p>
<ol type="1">
<li><code>files</code> は <code>{&quot;hoge.txt&quot;: {&quot;content&quot;: &quot;abc&quot;}}</code> って感じのJSONオブジェクト</li>
<li><code>description</code> パラメーターや <code>files</code> の <code>content</code> は <code>null</code> を渡せない</li>
<li><code>public</code> を <code>null</code> にした場合レスポンスの <code>public</code> も <code>null</code> になる</li>
</ol>
<p>aeson で <code>Maybe</code> を使ってオプショナルなパラメーターを表現した場合は強制的に <code>null</code> が渡される． <del>そのため，<code>description</code> はオプショナルなパラメーターだが型を <code>Text</code> にした</del> が，レビューで次のようにやればいいよって返ってきた：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">NewGist</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    toJSON <span class="dt">NewGist</span> { <span class="op">...</span> } <span class="ot">=</span> object <span class="op">$</span> <span class="fu">filter</span> notNull</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>                   [ <span class="st">&quot;description&quot;</span> <span class="op">.=</span> newGistDescription</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>                   , <span class="st">&quot;files&quot;</span>       <span class="op">.=</span> newGistFiles</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>                   , <span class="st">&quot;public&quot;</span>      <span class="op">.=</span> newGistPublic</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>                   ]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>      <span class="kw">where</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        notNull (_, <span class="dt">Null</span>) <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>        notNull (_, _)    <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>なるほど，レビュー感謝． で，<code>public</code> は，すでにある <code>Gist</code> 型（レスポンスに使いたい）の <code>public</code> が <code>Maybe Bool</code> ではなく <code>Bool</code> なので (3) の挙動が困る． そのため，<code>public</code> パラメーターの型も <code>Bool</code> にしたが，<code>description</code> 同様に <code>filter notNull</code> 効かせたので普通に <code>Maybe Bool</code> で良くなった． ちなみに，デフォルトは <code>false</code>．</p>
<h3 id="pandoc-で書き換える">Pandoc で書き換える</h3>
<p>少しオーバースペックのような気がするが，Pandoc を利用して Markdown をパースする：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">customizeContent ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">RIO</span> <span class="dt">Env</span> <span class="dt">Text</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>customizeContent content <span class="ot">=</span> liftIO <span class="op">.</span> Pandoc.runIOorExplode <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  p0 <span class="ot">&lt;-</span> Pandoc.readCommonMark Pandoc.def content</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  Pandoc.writeCommonMark Pandoc.def p0</span></code></pre></div>
<p><code>readMarkdown</code> というのもあるが，GFM などを使う場合は <code>readCommonMark</code> の方を使う． <code>p0</code> というのが <code>Pandoc</code> 型の値で，<code>Walkable</code> を利用することで任意のブロックに対してのみ変換を適用したりできる：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">customizeContent ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">RIO</span> <span class="dt">Env</span> <span class="dt">Text</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>customizeContent content <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  p0 <span class="ot">&lt;-</span> liftIO <span class="op">$</span> Pandoc.runIOorExplode (Pandoc.readCommonMark Pandoc.def content)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  p1 <span class="ot">&lt;-</span> Pandoc.walkPandocM replaceCodeBlockToGistLink p0</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  liftIO <span class="op">$</span> Pandoc.runIOorExplode (Pandoc.writeCommonMark Pandoc.def p1)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="ot">replaceCodeBlockToGistLink ::</span> <span class="dt">Pandoc.Block</span> <span class="ot">-&gt;</span> <span class="dt">RIO</span> <span class="dt">Env</span> <span class="dt">Pandoc.Block</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>replaceCodeBlockToGistLink <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>  <span class="dt">Pandoc.CodeBlock</span> attr txt <span class="ot">-&gt;</span> <span class="fu">undefined</span> <span class="co">-- 書き換える</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>  block <span class="ot">-&gt;</span> <span class="fu">pure</span> block</span></code></pre></div>
<p>Gist がよしなにプログラミング言語を特定してシンタックスハイライトするにはファイルの拡張子が必要だ． コードブロックのバッククオートの後ろに指定している拡張子を取得するために <code>attr</code> を見てみると <code>(&quot;&quot;, [&quot;hs&quot;], [])</code> となっていた（プログラミング言語名も指定できるけど，拡張子だけを指定してるとする）． なので，これを利用する：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">replaceCodeBlockToGistLink ::</span> <span class="dt">Pandoc.Block</span> <span class="ot">-&gt;</span> <span class="dt">RIO</span> <span class="dt">Env</span> <span class="dt">Pandoc.Block</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>replaceCodeBlockToGistLink <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="dt">Pandoc.CodeBlock</span> (_, [ext], _) txt <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    gist <span class="ot">&lt;-</span> lift <span class="op">$</span> createGist ext txt</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Pandoc.Plain</span> [<span class="dt">Pandoc.Str</span> (GitHub.getUrl <span class="op">$</span> GitHub.gistHtmlUrl gist)]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  block <span class="ot">-&gt;</span> <span class="fu">pure</span> block</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="ot">createGist ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">RIO</span> <span class="dt">Env</span> <span class="dt">GitHub.Gist</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>createGist ext txt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="kw">let</span> files <span class="ot">=</span> HM.fromList [(<span class="st">&quot;sample.&quot;</span> <span class="op">&lt;&gt;</span> ext, <span class="dt">GitHub.NewGistFile</span> txt)]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>  <span class="co">-- とりあえずエラーハンドリングは適当に throwM する</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  <span class="fu">either</span> throwM <span class="fu">pure</span> <span class="op">=&lt;&lt;</span> MixGitHub.fetch (GitHub.createGistR <span class="op">$</span> <span class="dt">GitHub.NewGist</span> <span class="st">&quot;&quot;</span> files <span class="dt">True</span>)</span></code></pre></div>
<p><code>MixGitHub.fetch</code> というのは<a href="https://github.com/matsubara0507/mix.hs/tree/master/mix-plugin-github">これ</a>です． 便利です．</p>
<p>これでとりあえず，コードブロックから Gist を作ってリンクに置き換えることができるようになった．</p>
<h3 id="gist-のファイル名を工夫する">Gist のファイル名を工夫する</h3>
<p>現状だと全ての Gist ファイルが <code>sample.hs</code> みたいに拡張子以外は一緒になってしまう． なのでプレフィックスを指定できるようにするのと，何個目のコードブロックかで <code>sample1.hs</code> や <code>sample2.hs</code> みたいにできるようにしたい． そのために <code>State</code> モナドを利用する：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">customizeContent ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">RIO</span> <span class="dt">Env</span> <span class="dt">Text</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>customizeContent content <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  p0 <span class="ot">&lt;-</span> liftIO <span class="op">$</span> Pandoc.runIOorExplode (Pandoc.readCommonMark Pandoc.def content)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  p1 <span class="ot">&lt;-</span> <span class="fu">fst</span> <span class="op">&lt;$&gt;</span> runStateT (Pandoc.walkPandocM replaceCodeBlockToGistLink p0) <span class="dv">1</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  liftIO <span class="op">$</span> Pandoc.runIOorExplode (Pandoc.writeCommonMark Pandoc.def p1)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ot">replaceCodeBlockToGistLink ::</span>  <span class="dt">Pandoc.Block</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">Int</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">Pandoc.Block</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>replaceCodeBlockToGistLink <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>  <span class="dt">Pandoc.CodeBlock</span> (_, [ext], _) txt <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    cnt  <span class="ot">&lt;-</span> State.get</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>    gist <span class="ot">&lt;-</span> lift <span class="op">$</span> createGist (tshow cnt) ext txt</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    State.modify (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Pandoc.Plain</span> [<span class="dt">Pandoc.Str</span> (GitHub.getUrl <span class="op">$</span> GitHub.gistHtmlUrl gist)]</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>  block <span class="ot">-&gt;</span> <span class="fu">pure</span> block</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a><span class="ot">createGist ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">RIO</span> <span class="dt">Env</span> <span class="dt">GitHub.Gist</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>createGist suffix ext txt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>  <span class="kw">let</span> files <span class="ot">=</span> HM.fromList [(<span class="st">&quot;sample&quot;</span> <span class="op">&lt;&gt;</span> suffix <span class="op">&lt;&gt;</span> <span class="st">&quot;.&quot;</span> <span class="op">&lt;&gt;</span> ext, <span class="dt">GitHub.NewGistFile</span> txt)]</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>  <span class="fu">either</span> throwM <span class="fu">pure</span> <span class="op">=&lt;&lt;</span> MixGitHub.fetch (GitHub.createGistR <span class="op">$</span> <span class="dt">GitHub.NewGist</span> <span class="st">&quot;&quot;</span> files <span class="dt">True</span>)</span></code></pre></div>
<p>プレフィックスはコマンドのオプションから指定して，適当に <code>createGist</code> まで持ってくるだけなので割愛． これで完全に手作業してたのが自動化された．</p>
<h2 id="おしまい">おしまい</h2>
<p>Pandoc パッケージのビルドがゲキオモなのがネックだけどね．</p>
  </div>]]></summary>
</entry>
<entry>
    <title>外部ツールのバージョンアップを GitHub Actions で検知する</title>
    <link href="https://matsubara0507.github.io/posts/2020-12-14-check-release-using-github-actions.html" />
    <id>https://matsubara0507.github.io/posts/2020-12-14-check-release-using-github-actions.html</id>
    <published>2020-12-14T00:00:00Z</published>
    <updated>2020-12-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>GitHub Actions のアクションや Bazel ルールを書いたりすると，外部のアプリケーションのアップデートを検知したいときがしばしばあります． いろいろ試行錯誤した結果，GitHub Actions を使って実現することにしたので，本記事はそのメモ書きです．</p>
<h1 id="section"></h1>
<p>ちなみに，本記事は「<a href="https://qiita.com/advent-calendar/2020/github-actions">GitHub Actions Advent Calendar 2020</a>」の14日目の記事です．</p>
<h2 id="github-actions-を設定する">GitHub Actions を設定する</h2>
<p>実際に導入した PR がこちら：</p>
<ul>
<li><a href="https://github.com/matsubara0507/rules_yq/pull/1">Add GitHub Action to check new yq version by matsubara0507 · Pull Request #1 · matsubara0507/rules_yq</a></li>
</ul>
<p><a href="https://github.com/mikefarah/yq">yq</a> と言うツールのリリースを検知しようとしている． ちなみに，最新のバージョンは中の処理のデフォルト値として利用している．</p>
<h3 id="デフォルト値を取り出す">デフォルト値を取り出す</h3>
<p>まずは，現在のデフォルトのバージョンを参照しやすいように別ファイル（yq/default.bzl）にしておく：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>YQ_DEFAULT_VERSION <span class="op">=</span> <span class="st">&quot;3.4.1&quot;</span></span></code></pre></div>
<p>これを sed でいい感じに取り出して GitHub Actions の output に入れていく：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="at">  </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="at">    </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build new version commit</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-latest</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="at">    </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="at">      </span><span class="fu">DEFAULT_FILE_PATH</span><span class="kw">:</span><span class="at"> yq/default.bzl</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="at">    ...</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Set default version</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="at">      </span><span class="fu">id</span><span class="kw">:</span><span class="at"> default</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> echo &quot;::set-output name=version::$(sed -e s/YQ_DEFAULT_VERSION\ =\ //g $DEFAULT_FILE_PATH | sed -e s/\&quot;//g)&quot;</span></span></code></pre></div>
<p><code>::set-output</code> というのは GitHub Actions の記法で， step 毎の結果を同じ job 間で共有するために使う．以降の step で <code>steps.default.outputs.version</code> という形で <code>sed</code> の結果を参照できるようになる．</p>
<h3 id="最新のリリースバージョンを取り出す">最新のリリースバージョンを取り出す</h3>
<p>最新のリリースは <a href="https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#get-the-latest-release">GitHub のリリースから API</a> を使って取得する． API のレスポンスからバージョンの情報を <code>jq</code> でいい感じに取り出して，また output に入れておく：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="at">  </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="at">    </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build new version commit</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-latest</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="at">    </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="at">      </span><span class="fu">DEFAULT_FILE_PATH</span><span class="kw">:</span><span class="at"> yq/default.bzl</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="at">      </span><span class="fu">LATEST_LINK</span><span class="kw">:</span><span class="at"> https://api.github.com/repos/mikefarah/yq/releases/latest</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="at">    ...</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Set latest version</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="at">      </span><span class="fu">id</span><span class="kw">:</span><span class="at"> latest</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> echo &quot;::set-output name=version::$(curl -s $LATEST_LINK | jq .tag_name | sed -e s/\&quot;//g)&quot;</span></span></code></pre></div>
<p>以降の step で <code>steps.latest.outputs.version</code> という形で <code>jq</code> の結果を参照できるようになる．</p>
<h3 id="デフォルト値を更新する">デフォルト値を更新する</h3>
<p>これら2つのバージョンが異なるときにだけデフォルト値を更新するようにする：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="at">  </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="at">    </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build new version commit</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-latest</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="at">    </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="at">      </span><span class="fu">DEFAULT_FILE_PATH</span><span class="kw">:</span><span class="at"> yq/default.bzl</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="at">      </span><span class="fu">LATEST_LINK</span><span class="kw">:</span><span class="at"> https://api.github.com/repos/mikefarah/yq/releases/latest</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="at">    ...</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Update new version default.bzl</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="at">      </span><span class="fu">if</span><span class="kw">:</span><span class="at"> ${{ steps.latest.outputs.version != steps.default.outputs.version }}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="at">      </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="at">        </span><span class="fu">NEW_VERSION</span><span class="kw">:</span><span class="at"> ${{ steps.latest.outputs.version }}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> echo &quot;YQ_DEFAULT_VERSION = \&quot;$NEW_VERSION\&quot;&quot; &gt; $DEFAULT_FILE_PATH    </span></span></code></pre></div>
<p>ただ切り出しておいたファイルを上書きしているだけ．</p>
<h3 id="prを作成する">PRを作成する</h3>
<p><a href="https://github.com/peter-evans/create-pull-request">peter-evans/create-pull-request</a> という GitHub Actions を利用する：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="at">  </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="at">    </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build new version commit</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-latest</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="at">    </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="at">      </span><span class="fu">DEFAULT_FILE_PATH</span><span class="kw">:</span><span class="at"> yq/default.bzl</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="at">      </span><span class="fu">LATEST_LINK</span><span class="kw">:</span><span class="at"> https://api.github.com/repos/mikefarah/yq/releases/latest</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="at">    ...</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Create Pull Request</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="at">      </span><span class="fu">if</span><span class="kw">:</span><span class="at"> ${{ steps.latest.outputs.version != steps.default.outputs.version }}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> peter-evans/create-pull-request@v3.5.1</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a><span class="at">        </span><span class="fu">token</span><span class="kw">:</span><span class="at"> ${{ secrets.GITHUB_TOKEN }}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a><span class="at">        </span><span class="fu">commit-message</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;Feat: update default yq version&#39;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a><span class="at">        </span><span class="fu">title</span><span class="kw">:</span><span class="at"> Release new yq version ${{ steps.latest.outputs.version }}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a><span class="fu">        body</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>         @matsubara0507</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>         - [x] update default version in yq</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>         - [ ] add new checksums to yq/toolchain.bzl</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>         - [ ] update documents (README, actions.yml)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>         - [ ] update sample workflow</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a><span class="at">        </span><span class="fu">labels</span><span class="kw">:</span><span class="at"> New yq Version</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a><span class="at">        </span><span class="fu">branch</span><span class="kw">:</span><span class="at"> yq-version-${{ steps.latest.outputs.version }}</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a><span class="at">        </span><span class="fu">base</span><span class="kw">:</span><span class="at"> main</span><span class="co">  # 最近作ったリポジトリなので main がデフォルトブランチ</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true"></a><span class="at">        </span><span class="fu">draft</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span><span class="co"> # ドラフトPRにしてくれる</span></span></code></pre></div>
<p><code>body</code> のところに自分の GitHub アカウントをメンションしておくと，GitHub のスマホアプリとかで通知されて気付きやすい． こんな感じの PR が出来上がる：</p>
<p><img src="/assets/check-release-using-github-actions/pr.jpg"></img></p>
<p>ちなみに，すでにブランチがある場合は PR が作成されない． また，PR を放置しているうちに新しいバージョンがリリースされた場合は，新しい PR がもう一個でき上がる．</p>
<h2 id="おしまい">おしまい</h2>
<p>結構便利です．</p>
  </div>]]></summary>
</entry>
<entry>
    <title>Elm で Featherweight Go を書いてみた（その１）</title>
    <link href="https://matsubara0507.github.io/posts/2020-12-07-fg-with-elm-part1.html" />
    <id>https://matsubara0507.github.io/posts/2020-12-07-fg-with-elm-part1.html</id>
    <published>2020-12-07T00:00:00Z</published>
    <updated>2020-12-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>タイトルの通り，Elm で Featherweight Go を作って遊んでました． 本記事はそのメモ書きです．</p>
<h1 id="section"></h1>
<p>あとこれは <a href="https://qiita.com/advent-calendar/2020/elm">Elm Advent Calendar 2020</a> の7日目の記事です．</p>
<h2 id="featherweight-go">Featherweight Go</h2>
<p>Go にジェネリクスを導入するために考案された，極めてミニマムな Go 処理系（の形式的な定義）． そのまんま「<a href="https://arxiv.org/abs/2005.11710">Featherweight Go</a>」という論文が出てる． 前に，ざっくり日本語でまとめました：</p>
<ul>
<li><a href="https://matsubara0507.github.io/posts/2020-07-02-read-featherweight-go.html">Featherweight Go を読んでみた - ひげメモ</a></li>
</ul>
<p>論文では Featherweight Go（以下 FG）と，それにジェネリクスを追加した Featherweight Generics Go の構文規則・評価規則・型付け規則などが定義されており，型安全性が証明されている． 今回は，Featherweight Go のパーサーと型検査器を論文の定義に則って Elm で実装した話．</p>
<p>ちなみに評価の方は実装しないです．</p>
<h2 id="elm">Elm</h2>
<p>Elm は JavaScript へとトランスパイルされる Web フロントエンドに特化した純粋関数型プログラミング言語． 構文は Haskell に似ているが，言語機能自体は Haskell のように多彩ではなく，極めてコンパクトである．</p>
<p>今回 Elm を使う理由は2つあって：</p>
<ol type="1">
<li>Elm でプログラミング言語作る人がほとんど居ないから</li>
<li>簡単に Web ビュー側を作れるから</li>
</ol>
<p>です．</p>
<h3 id="elm-でパーサーを作るには">Elm でパーサーを作るには</h3>
<p>Elm でパーサーを記述するには <a href="https://package.elm-lang.org/packages/elm/parser">elm/parser</a> という公式が提供しているパーサーコンビネーターライブラリを使う．</p>
<h2 id="fgのパーサーを作る">FGのパーサーを作る</h2>
<p>構文規則は次の通り：</p>
<p><img src="/assets/read-featherweight-go/fg.jpg"></img></p>
<p>これを Elm でひたすら実装していく．</p>
<h3 id="構文の型を定義">構文の型を定義</h3>
<p>まずは，構文を表現する型を定義しよう． ひたすら予約語にあたる部分を排除するだけだ：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode elm"><code class="sourceCode elm"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Go</span><span class="op">.</span><span class="dt">Featherweight</span><span class="op">.</span><span class="dt">Syntax</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">Program</span> <span class="op">=</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    { <span class="fu">decls</span> : <span class="dt">List</span> <span class="dt">Declaration</span><span class="op">,</span> <span class="fu">exp</span> : <span class="dt">Expression</span> }</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Declaration</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="op">=</span> <span class="dt">TDecl</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        { <span class="fu">name</span> : <span class="dt">TypeName</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">literal</span> : <span class="dt">TypeLiteral</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>        }</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">MDecl</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>        { <span class="fu">recv</span> : ( <span class="dt">VarName</span><span class="op">,</span> <span class="dt">TypeName</span> )</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">name</span> : <span class="dt">MethodName</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">sign</span> : <span class="dt">MethodSignature</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">retv</span> : <span class="dt">Expression</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>        }</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">TypeName</span> <span class="op">=</span> <span class="dt">String</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">VarName</span> <span class="op">=</span> <span class="dt">String</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">MethodName</span> <span class="op">=</span> <span class="dt">String</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">FieldName</span> <span class="op">=</span> <span class="dt">String</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">TypeLiteral</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>    <span class="op">=</span> <span class="dt">Structure</span> (<span class="dt">List</span> ( <span class="dt">FieldName</span><span class="op">,</span> <span class="dt">TypeName</span> ))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">Interface</span> (<span class="dt">List</span> <span class="dt">MethodSpecific</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">MethodSpecific</span> <span class="op">=</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>    { <span class="fu">name</span> : <span class="dt">MethodName</span><span class="op">,</span> <span class="fu">sign</span> : <span class="dt">MethodSignature</span> }</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">MethodSignature</span> <span class="op">=</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    { <span class="fu">args</span> : <span class="dt">List</span> ( <span class="dt">VarName</span><span class="op">,</span> <span class="dt">TypeName</span> )<span class="op">,</span> <span class="fu">rett</span> : <span class="dt">TypeName</span> }</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Expression</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>    <span class="op">=</span> <span class="dt">Var</span> <span class="dt">VarName</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">MethodCall</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>        { <span class="fu">exp</span> : <span class="dt">Expression</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">method</span> : <span class="dt">MethodName</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">args</span> : <span class="dt">List</span> <span class="dt">Expression</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>        }</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">StructLiteral</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a>        { <span class="fu">struct</span> : <span class="dt">TypeName</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">args</span> : <span class="dt">List</span> <span class="dt">Expression</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>        }</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">SelectField</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>        { <span class="fu">exp</span> : <span class="dt">Expression</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">field</span> : <span class="dt">FieldName</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a>        }</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">TypeAssertion</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>        { <span class="fu">exp</span> : <span class="dt">Expression</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">ty</span> : <span class="dt">TypeName</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a>        }</span></code></pre></div>
<h3 id="パーサーを書く">パーサーを書く</h3>
<p>先に，FG のパーサーを記述する上で便利なヘルパー関数をいくつか定義しておく：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode elm"><code class="sourceCode elm"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Go</span><span class="op">.</span><span class="dt">Parser</span><span class="op">.</span><span class="dt">Helper</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="fu">newlineSequence</span> : <span class="dt">Parser</span> () <span class="op">-&gt;</span> <span class="dt">Parser</span> <span class="fu">a</span> <span class="op">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">List</span> <span class="fu">a</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="fu">newlineSequence</span> <span class="fu">end</span> <span class="fu">p</span> <span class="op">=</span> <span class="op">...</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="fu">blockWith</span> : ( <span class="dt">String</span><span class="op">,</span> <span class="dt">String</span> ) <span class="op">-&gt;</span> <span class="dt">Parser</span> <span class="fu">a</span> <span class="op">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">List</span> <span class="fu">a</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="fu">blockWith</span> ( <span class="fu">start</span><span class="op">,</span> <span class="fu">end</span> ) <span class="fu">p</span> <span class="op">=</span> <span class="op">...</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="fu">whitespaces</span> : <span class="dt">Parser</span> ()</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="fu">whitespaces</span> <span class="op">=</span> <span class="op">...</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="fu">newlines</span> : <span class="dt">Parser</span> ()</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="fu">newlines</span> <span class="op">=</span> <span class="op">...</span></span></code></pre></div>
<p><a href="https://github.com/matsubara0507/featherweight-go/blob/4ce84918c80b0852b4c32989bdbfe29331ab1fe9/src/Go/Parser/Helper.elm">実装はこの辺りを見てください</a>． <code>newlineSequence</code> は改行区切りで引数のパーサーを実行してくれる． 例えば，構造体のフィールドを改行区切りで列挙するのをパースするのに役立つ． <code>blockWith</code> は，1引数目で与えた開始文字列と終端文字列で囲まれてかつ，2引数目のパーサーをカンマ区切りで実行してくれる． 関数定義の引数のパースなどに役立つ． <code>whitespaces</code> は1つ以上の空白を，<code>newlines</code> は1つ以上の改行をパースする．</p>
<p>で，まずは「プログラム」の部分のパーサーだ． プログラムは次のようなのをパースしたい：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">package</span> main</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co">// 構造体や関数の定義</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    _ = .. <span class="co">// なんらかの式</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>とりあえず，式や構造体の定義のパーサーはあるものと仮定して実装する：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode elm"><code class="sourceCode elm"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Parser</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Go</span><span class="op">.</span><span class="dt">Parser</span><span class="op">.</span><span class="dt">Helper</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="fu">parser</span> : <span class="dt">Parser</span> <span class="dt">Program</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="fu">parser</span> <span class="op">=</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="kw">let</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        <span class="fu">parseMainPackage</span> <span class="op">=</span> <span class="co">-- package main の部分</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>            <span class="fu">succeed</span> ()</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">keyword</span> <span class="st">&quot;package&quot;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">whitespaces</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">keyword</span> <span class="st">&quot;main&quot;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>        <span class="fu">parseMainFunc</span> <span class="op">=</span> <span class="co">-- func main() の部分</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>            <span class="fu">succeed</span> ()</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">backtrackable</span> (<span class="fu">keyword</span> <span class="st">&quot;func&quot;</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">backtrackable</span> <span class="fu">whitespaces</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">keyword</span> <span class="st">&quot;main()&quot;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>        <span class="fu">parseMainExp</span> <span class="op">=</span> <span class="co">-- _ = e の部分</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>            <span class="fu">succeed</span> <span class="fu">identity</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">symbol</span> <span class="st">&quot;_&quot;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">whitespaces</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">symbol</span> <span class="st">&quot;=&quot;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>                <span class="op">|.</span> <span class="fu">whitespaces</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>                <span class="op">|=</span> <span class="fu">expParser</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>    <span class="kw">in</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>    <span class="fu">succeed</span> <span class="dt">Program</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>        <span class="op">|.</span> <span class="fu">parseMainPackage</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a>        <span class="op">|.</span> <span class="fu">newlines</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a>        <span class="op">|=</span> <span class="fu">newlineSequence</span> <span class="fu">parseMainFunc</span> <span class="fu">declParser</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true"></a>        <span class="op">|.</span> <span class="fu">spaces</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true"></a>        <span class="op">|.</span> <span class="fu">symbol</span> <span class="st">&quot;{&quot;</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true"></a>        <span class="op">|.</span> <span class="fu">spaces</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true"></a>        <span class="op">|=</span> <span class="fu">parseMainExp</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true"></a>        <span class="op">|.</span> <span class="fu">spaces</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true"></a>        <span class="op">|.</span> <span class="fu">symbol</span> <span class="st">&quot;}&quot;</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true"></a>        <span class="op">|.</span> <span class="fu">spaces</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true"></a>        <span class="op">|.</span> <span class="dt">Parser</span><span class="op">.</span><span class="fu">end</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true"></a><span class="fu">declParser</span> : <span class="dt">Parser</span> <span class="dt">Declaration</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true"></a><span class="fu">declParser</span> <span class="op">=</span> <span class="dt">Debug</span><span class="op">.</span><span class="fu">todo</span> <span class="st">&quot;Decl Parser&quot;</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true"></a><span class="fu">expParser</span> : <span class="dt">Parser</span> <span class="dt">Expression</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true"></a><span class="fu">expParser</span> <span class="op">=</span> <span class="dt">Debug</span><span class="op">.</span><span class="fu">todo</span> <span class="st">&quot;Exp Parser&quot;</span></span></code></pre></div>
<p>基本的に <code>declParser</code> や <code>expParser</code> も同じように構文定義を見ながら実装していくだけなので割愛する（<a href="https://github.com/matsubara0507/featherweight-go/blob/4ce84918c80b0852b4c32989bdbfe29331ab1fe9/tests/Test/Go/Featherweight/Syntax.elm">コード</a>）． 1つだけ，なんらかの変数をパースするパーサーだけは書いておく． elm/parser には <code>variable</code> というまさにこれをやるパーサーコンビネーターがあるのでこれを利用する：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode elm"><code class="sourceCode elm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">nameParser</span> : <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="fu">nameParser</span> <span class="op">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="fu">variable</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        { <span class="fu">start</span> <span class="op">=</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">isAlphaNum</span> <span class="co">-- 先頭文字，小文字や数字を含まないとかできる</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">inner</span> <span class="op">=</span> \<span class="fu">c</span> <span class="op">-&gt;</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">isAlphaNum</span> <span class="fu">c</span> <span class="op">||</span> <span class="fu">c</span> <span class="op">==</span> <span class="ch">&#39;_&#39;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">reserved</span> <span class="op">=</span> <span class="fu">keywords</span>     <span class="co">-- 変数にはならない予約を列挙する</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        }</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="fu">keywords</span> : <span class="dt">Set</span> <span class="dt">String</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="fu">keywords</span> <span class="op">=</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>    <span class="dt">Set</span><span class="op">.</span><span class="fu">fromList</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>        [ <span class="st">&quot;package&quot;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        <span class="op">,</span> <span class="st">&quot;main&quot;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>        <span class="op">,</span> <span class="st">&quot;func&quot;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>        <span class="op">,</span> <span class="st">&quot;struct&quot;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>        <span class="op">,</span> <span class="st">&quot;interface&quot;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>        <span class="op">,</span> <span class="st">&quot;type&quot;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>        <span class="op">,</span> <span class="st">&quot;return&quot;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>        ]</span></code></pre></div>
<h3 id="テスト">テスト</h3>
<p>とりあえず簡単に，FGの論文にあるサンプルコードが動作するかのテストだけを書いた：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode elm"><code class="sourceCode elm"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Test</span><span class="op">.</span><span class="dt">Go</span><span class="op">.</span><span class="dt">Featherweight</span><span class="op">.</span><span class="dt">Syntax</span> <span class="kw">exposing</span> (<span class="fu">suite</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Go</span><span class="op">.</span><span class="dt">Featherweight</span><span class="op">.</span><span class="dt">Syntax</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Parser</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="fu">suite</span> : <span class="dt">Test</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="fu">suite</span> <span class="op">=</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="fu">describe</span> <span class="st">&quot;module Go.Featherweight.Syntax&quot;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>        [ <span class="fu">describe</span> <span class="st">&quot;parser&quot;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>            [ <span class="fu">test</span> <span class="st">&quot;parse sample FG code&quot;</span> <span class="op">&lt;|</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>                \<span class="fu">_</span> <span class="op">-&gt;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>                    <span class="dt">Parser</span><span class="op">.</span><span class="fu">run</span> <span class="fu">parser</span> <span class="fu">sample</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>                        <span class="op">|&gt;</span> <span class="dt">Expect</span><span class="op">.</span><span class="fu">equal</span> (<span class="dt">Ok</span> <span class="op">&lt;|</span> { <span class="fu">decls</span> <span class="op">=</span> <span class="op">...,</span> <span class="fu">exp</span> <span class="op">=</span> <span class="op">...</span> }</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a><span class="fu">sample</span> : <span class="dt">String</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a><span class="fu">sample</span> <span class="op">=</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>    <span class="dt">String</span><span class="op">.</span><span class="fu">dropLeft</span> <span class="dv">1</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>        <span class="st">&quot;&quot;&quot;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a><span class="st">package main</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a><span class="st">type Any interface {}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a><span class="st">type Function interface {</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a><span class="st">    Apply(x Any) Any</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a><span class="st">}</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a><span class="st">type incr struct { n int }</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a><span class="st">func (this incr) Apply(x Any) Any {</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a><span class="st">    return this.n.add(x.(int))</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a><span class="st">}</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a><span class="st">type pos struct {}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a><span class="st">func (this pos) Apply(x Any) Any {</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a><span class="st">    return x.(int).lt(zero)</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a><span class="st">}</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a><span class="st">type compose struct {</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a><span class="st">    f Function</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a><span class="st">    g Function</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a><span class="st">}</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a><span class="st">func (this compose) Apply(x Any) Any {</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a><span class="st">    return this.g.Apply(this.f.Apply(x))</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a><span class="st">}</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a><span class="st">func main(){</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a><span class="st">    _ = compose{incr{x}, pos{}}.Apply(y).(bool)</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a><span class="st">}</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a><span class="st">&quot;&quot;&quot;</span></span></code></pre></div>
<h2 id="fgの型検査器を作る">FGの型検査器を作る</h2>
<p>型検査器を作るにはとりあえず，論文の型付け規則（3.3節の図11）をそのまんま実装していけばいい． まぁまぁ量があるので型付け規則自体は載せません（論文を見て）．</p>
<h3 id="例プログラムの型付け規則">例：プログラムの型付け規則</h3>
<p>全部載せると膨大なので，「プログラム」の型付け規則とその実装だけ． 型付け規則は次のようになっている：</p>
<pre><code>distinct(tdecls(seq(D)))
distinct(mdecls(seq(D)))
seq(D ok)
[] |- e : t
---------------------------------------------
package main; seq(D) func main { _ = e } ok</code></pre>
<p>数式で書くの大変なので，だいぶ本来の記法と離れちゃってますが雰囲気として，<code>---</code> より上が全て成り立てば下が成り立つという感じ． 下の <code>... ok</code> というのは「プログラム」が正しく型付けされていることを意味しており，上のそれぞれは：</p>
<ul>
<li><code>D</code> というのは型（構造体・インターフェース）の宣言かメソッドの宣言</li>
<li><code>seq(D)</code> は <code>D</code> のリスト（シーケンス）</li>
<li><code>tdecls(seq(D))</code> は <code>seq(D)</code> のうち型の宣言だけを集めたもの</li>
<li><code>mdecls(seq(D))</code> は <code>seq(D)</code> のうちメソッドの宣言だけを集めたもの</li>
<li><code>distinct(xs)</code> は <code>xs</code> 内に重複がないことを意味する（つまり，型やメソッドが重複してたらダメ）</li>
<li><code>D ok</code> は宣言 <code>D</code> が正しく型付けされていることを意味する</li>
<li><code>seq(D ok)</code> は <code>seq(D)</code> の全ての宣言が正しく型付けされていることを意味する</li>
<li><code>[] |- e : t</code> は式 <code>e</code> がなんらかの型 <code>t</code> で型付けされていることを意味する</li>
</ul>
<p>最後ので <code>[]</code> は空の型環境を意味している． 型環境はある式がどの型になるかの辞書だ． つまり，Elm で実装するとこんな感じ：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode elm"><code class="sourceCode elm"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Go</span><span class="op">.</span><span class="dt">Featherweight</span><span class="op">.</span><span class="dt">Type</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Dict</span> <span class="kw">exposing</span> (<span class="dt">Dict</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Go</span><span class="op">.</span><span class="dt">Featherweight</span><span class="op">.</span><span class="dt">Syntax</span> <span class="kw">as</span> <span class="dt">FG</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">Gamma</span> <span class="op">=</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    <span class="dt">Dict</span> <span class="dt">VarName</span> <span class="dt">TypeName</span></span></code></pre></div>
<p>また，型検査をするには <code>seq(D)</code> で宣言されている型やメソッドの情報が必要だ． 論文の数理論理学的な定義では，情報が必要になるたびに <code>seq(D)</code> から引っ張ってきている． しかし，実際のプログラムでそれをやると効率が悪いので，事前にそのような辞書を環境（<code>Env</code>）として定義しておく：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode elm"><code class="sourceCode elm"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">Env</span> <span class="op">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    ( <span class="dt">Gamma</span><span class="op">,</span> <span class="dt">DeclMap</span> )</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="co">-- 型名をキー</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="co">-- 型の情報（`TypeLiteral`）とメソッドの情報（`MethodSpecific`）が値</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">alias</span> <span class="dt">DeclMap</span> <span class="op">=</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="dt">Dict</span> <span class="dt">TypeName</span> ( <span class="dt">TypeLiteral</span><span class="op">,</span> <span class="dt">List</span> <span class="dt">MethodSpecific</span> )</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="fu">newEnv</span> : <span class="dt">List</span> <span class="dt">Declaration</span> <span class="op">-&gt;</span> <span class="dt">Env</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a><span class="fu">newEnv</span> <span class="fu">decls</span> <span class="op">=</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>    ( <span class="dt">Dict</span><span class="op">.</span><span class="fu">empty</span><span class="op">,</span> <span class="fu">mkDeclMap</span> <span class="fu">decls</span> )</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a><span class="fu">mkDeclMap</span> : <span class="dt">List</span> <span class="dt">Declaration</span> <span class="op">-&gt;</span> <span class="dt">DeclMap</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a><span class="fu">mkDeclMap</span> <span class="fu">decls</span> <span class="op">=</span> <span class="op">...</span> <span class="co">-- ちょっと複雑なので割愛</span></span></code></pre></div>
<p>で，「プログラム」の型付け規則をそのまんま実装すると次のようになる：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode elm"><code class="sourceCode elm"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Go</span><span class="op">.</span><span class="dt">Featherweight</span><span class="op">.</span><span class="dt">Type</span> <span class="kw">exposing</span> (<span class="op">..</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="fu">check</span> : <span class="dt">FG</span><span class="op">.</span><span class="dt">Program</span> <span class="op">-&gt;</span> <span class="dt">Result</span> <span class="dt">TypeError</span> ()</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="fu">check</span> <span class="fu">p</span> <span class="op">=</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    <span class="kw">let</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>        <span class="fu">env</span> <span class="op">=</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>            <span class="fu">newEnv</span> <span class="fu">p</span><span class="op">.</span><span class="fu">decls</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>        <span class="fu">dmap</span> <span class="op">=</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>            <span class="dt">Tuple</span><span class="op">.</span><span class="fu">second</span> <span class="fu">env</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    <span class="kw">in</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="fu">combine_</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>        [ <span class="fu">distinct</span> (<span class="fu">tdecls</span> <span class="fu">p</span><span class="op">.</span><span class="fu">decls</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>            <span class="op">|&gt;</span> <span class="dt">Result</span><span class="op">.</span><span class="fu">mapError</span> (<span class="dt">DuplicatedDefinition</span> <span class="st">&quot;type&quot;</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">distinct</span> (<span class="fu">mdecls</span> <span class="fu">p</span><span class="op">.</span><span class="fu">decls</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>            <span class="op">|&gt;</span> <span class="dt">Result</span><span class="op">.</span><span class="fu">mapError</span> (\( <span class="fu">x</span><span class="op">,</span> <span class="fu">y</span> ) <span class="op">-&gt;</span> <span class="dt">DuplicatedDefinition</span> <span class="st">&quot;method&quot;</span> (<span class="fu">x</span> <span class="op">++</span> <span class="st">&quot;.&quot;</span> <span class="op">++</span> <span class="fu">y</span>))</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">combine_</span> (<span class="dt">List</span><span class="op">.</span><span class="fu">map</span> (<span class="fu">checkDeclWith</span> <span class="fu">dmap</span>) <span class="fu">p</span><span class="op">.</span><span class="fu">decls</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>        <span class="op">,</span> <span class="fu">typeInferWith</span> <span class="fu">env</span> <span class="fu">p</span><span class="op">.</span><span class="fu">exp</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>            <span class="op">|&gt;</span> <span class="dt">Result</span><span class="op">.</span><span class="fu">map</span> (<span class="fu">always</span> ())</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>        ]</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a><span class="co">-- `Result.combine` は `Result e a` を返すが</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a><span class="co">-- `Result e ()` を返す関数が欲しかった</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a><span class="fu">combine_</span> : <span class="dt">List</span> (<span class="dt">Result</span> <span class="fu">e</span> <span class="fu">a</span>) <span class="op">-&gt;</span> <span class="dt">Result</span> <span class="fu">e</span> ()</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a><span class="fu">combine_</span> <span class="op">=</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a>    <span class="dt">Result</span><span class="op">.</span><span class="fu">map</span> (<span class="fu">always</span> ()) <span class="op">&lt;&lt;</span> <span class="dt">Result</span><span class="op">.</span><span class="fu">combine</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a><span class="co">-- 重複のチェックは</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a><span class="co">-- 型の場合は型名が重複してないかどうか</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a><span class="co">-- メソッドの場合は型名+メソッド名が重複してないかどうか</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a><span class="fu">distinct</span> : <span class="dt">List</span> <span class="fu">comparable</span> <span class="op">-&gt;</span> <span class="dt">Result</span> <span class="fu">comparable</span> ()</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a><span class="fu">tdecls</span> : <span class="dt">List</span> <span class="dt">Declaration</span> <span class="op">-&gt;</span> <span class="dt">List</span> <span class="dt">TypeName</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a><span class="fu">mdecls</span> : <span class="dt">List</span> <span class="dt">Declaration</span> <span class="op">-&gt;</span> <span class="dt">List</span> ( <span class="dt">TypeName</span><span class="op">,</span> <span class="dt">MethodName</span> )</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a><span class="fu">checkDeclWith</span> : <span class="dt">DeclMap</span> <span class="op">-&gt;</span> <span class="dt">Declaration</span> <span class="op">-&gt;</span> <span class="dt">Result</span> <span class="dt">TypeError</span> ()</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a><span class="fu">checkDeclWith</span> <span class="fu">dmap</span> <span class="fu">d</span> <span class="op">=</span> <span class="op">...</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a><span class="fu">typeInferWith</span> : <span class="dt">Env</span> <span class="op">-&gt;</span> <span class="dt">Expression</span> <span class="op">-&gt;</span> <span class="dt">Result</span> <span class="dt">TypeError</span> <span class="dt">TypeName</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true"></a><span class="fu">typeInferWith</span> <span class="fu">env</span> <span class="fu">exp</span> <span class="op">=</span> <span class="op">...</span></span></code></pre></div>
<p><code>checkDeclWith</code> は与えた宣言（<code>Declaration</code>）が正しく型付けされているかどうかをチェックする． つまり <code>D ok</code> にあたる． <code>typeInferWith</code> は2引数目の式（<code>Expression</code>）の型を推論して返す関数だ． 推論できない場合は <code>TypeError</code> を返し，推論できた場合はその型名を返す． 「プログラム」の <code>e</code> の場合，どんな型に推論されても問題ないので <code>Result.map (always ())</code> で結果を破棄している．</p>
<p>これを型付け規則分作らないといけない． まぁまぁしんどかった．</p>
<h2 id="webページを作る">Webページを作る</h2>
<p>Elm なので，FGのコードを書くと型検査してくれるページを作った：</p>
<p><img src="/assets/fg-with-elm/fg-parser-page.jpg"></img></p>
<p>やっていることは簡単で，テキストエリアの文字列を <code>Go.Featherweight.Syntax.parser</code> でパースして <code>Program</code> 型の値を作り，それをそのまま <code>Go.Featherweight.Type.check</code> しているだけ． そして，結果がエラーだったらそのエラーメッセージを出力して，エラーでなければ「OK」って出しているだけ．</p>
<h2 id="おしまい">おしまい</h2>
<p>作ってから時間が経ってしまったので，記事が結構雑だ．．． その２では Featherweight Generics Go のパーサーと型検査器です．</p>
  </div>]]></summary>
</entry>
<entry>
    <title>Haskell Stack プロジェクトを Bazel でビルドしてみる</title>
    <link href="https://matsubara0507.github.io/posts/2020-12-02-build-haskell-stack-project-using-bazel.html" />
    <id>https://matsubara0507.github.io/posts/2020-12-02-build-haskell-stack-project-using-bazel.html</id>
    <published>2020-12-02T00:00:00Z</published>
    <updated>2020-12-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>仕事では Bazel を使ってビルドすることが多くなり，自分でも Bazel ルールを自作するようになったので，実験も兼ねて趣味の Haskell Stack プロジェクトを Bazel を使ってビルドしてみることにしました． 本記事はそのメモ書きです．</p>
<h1 id="section"></h1>
<p>あとこれは <a href="https://qiita.com/advent-calendar/2020/haskell">Haskell Advent Calendar 2020</a> の2日目の記事です．</p>
<h2 id="bazel">Bazel</h2>
<p><a href="https://bazel.build/">Bazel</a> は Google のエンジニアが中心になって開発している OSS のビルドツールだ．</p>
<p>以下のような特徴がある：</p>
<ul>
<li>必要なコマンドのインストール・バイナリのビルド・コマンドの実行などを記述できる</li>
<li>それらは全て専用のサンドボックス内で実行されるため再現性が高い</li>
<li>Starlark という Python 風な独自言語で記述する</li>
<li>キャッシュなどが工夫されており二度目以降のビルドが高速になりやすい</li>
<li>依存関係を明確に記述する必要がある</li>
</ul>
<p>また，記述した Bazel ルールを公開したり，それをライブラリのように再利用したりできる． 多くのメジャーな言語や Docker や Kubernetes などのメジャーなツールの Bazel ルールは<a href="https://github.com/search?q=topic%3Abazel-rules+org%3Abazelbuild&amp;type=Repositories">公式が結構提供してくれている</a>．</p>
<h3 id="rules_haskell">rules_haskell</h3>
<p>だがしかし，Haskell の Bazel ルールは不思議なことに公式にはない． 代わりに，<a href="https://www.tweag.io/">Tweag</a> が rules_haskell を精力的に作成してくれているので，今回はこれを利用することにする．</p>
<ul>
<li><a href="https://github.com/tweag/rules_haskell">tweag/rules_haskell - GitHub</a></li>
</ul>
<p>また，GitHub の <a href="https://github.com/github/semantic">semantic</a> が Bazel を利用しており，とても参考になる．</p>
<h2 id="ビルドする">ビルドする</h2>
<p>今回は <a href="https://github.com/matsubara0507/mdium">mdium</a> という自作ツールに Bazel を導入する． これは表題の通り，すでに Stack で管理されたプロジェクトだ． 今回の作業 PR はこれ：</p>
<ul>
<li><a href="https://github.com/matsubara0507/mdium/pull/8">Use Bazel to build by matsubara0507 · Pull Request #8 · matsubara0507/mdium</a></li>
</ul>
<h3 id="bazelisk">bazelisk</h3>
<p>作業を始める前に <a href="https://github.com/bazelbuild/bazelisk">bazelisk</a> について紹介する． bazel コマンドの代わりに bazelisk コマンドを利用することで，<code>.bazelversion</code> ファイルに記述したバージョンの bazel コマンドを勝手に利用してくれる．</p>
<p>rules_haskell は現在の最新バージョンである v0.13 だと（なぜか）サポートしている Bazel のバージョンが 2.1.0〜3.3.1 なので， <code>.bazelversion</code> ファイルで 3.3.1 を指定しておくと良い． ちなみに，現在の最新は 3.7.1．</p>
<h3 id="初期化する">初期化する</h3>
<p>rules_haskell の README にある通り，下記のコマンドを実行することでカレントディレクトリのプロジェクトを rules_haskell で初期化できる：</p>
<pre><code>$ curl https://haskell.build/start | sh</code></pre>
<p>実行することで以下のファイルが作成される</p>
<ul>
<li><code>WORKSPACE</code></li>
<li><code>BUILD.bazel</code></li>
<li><code>zlib.BUILD.bazel</code></li>
<li><code>Example.hs</code></li>
<li><code>.bazelrc</code></li>
</ul>
<p>WORKSPACE ファイルは外部への依存を記述する（コマンドのインストールなど）ファイルで，Bazel コマンドを実行するときのルートパスにもなる． BUILD ファイルは実行可能な Bazel コマンドを記述する． WORKSPACE が1つの Bazel プロジェクトに1つなのに対して，BUILD ファイルはアプリケーション毎に分ける（ことが多い）． 例えば，zlib.BUILD.bazel は zlib を用意するためのものだ． .bazelrc は Bazel コマンドを実行するときに渡すデフォルトのオプションなどを記述することができる．</p>
<p>Example.hs は例用の <code>Main</code> ファイルなので，これと今回は使わない zlib.BUILD.bazel は削除してしまう． また WORKSPACE に zlib 用の記述があるので，これも消してしまう．</p>
<p>また，gitignore に <code>bazel-*</code> を追記する． これは Bazel を実行したときに生成されるファイル群なのでコミットしない．</p>
<h3 id="依存パッケージの準備">依存パッケージの準備</h3>
<p>Haskell を Bazel でビルドするのにはパッケージの依存関係を Bazel で明示する必要がある（Cabal ファイルなどとは別に）． 厳密にどのバージョンのパッケージを使うかを記述す必要があるのだが，一つ一つやるのはめんどくさい． そこで，Stackage を使うことでだいぶ楽ができる（Stackage のスナップショットには，様々なパッケージのバージョンが固定されている）． 次のような<a href="https://docs.haskellstack.org/en/v1.3.0/custom_snapshot/">カスタムスナップショット</a>を定義してあげると良い：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="fu">resolver</span><span class="kw">:</span><span class="at"> lts-16.23</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="fu">packages</span><span class="kw">:</span><span class="co"> # 指定した resolver にはないパッケージをここで追記する</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">-</span><span class="at"> extensible-0.8.1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">-</span><span class="at"> membership-0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">-</span><span class="at"> fallible-0.1.0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="kw">-</span><span class="at"> incremental-0.3.1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">github</span><span class="kw">:</span><span class="at"> matsubara0507/mix.hs</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="at">  </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> 75714be080db16f6a4f9d0a22e86947ffcdadc57</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="at">  </span><span class="fu">subdirs</span><span class="kw">:</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="at">  </span><span class="kw">-</span><span class="at"> mix</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="at">  </span><span class="kw">-</span><span class="at"> mix-json-logger</span></span></code></pre></div>
<p>このファイルを利用する形で，次のように WORKSPACE ファイルへ依存パッケージを記述する：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>load(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="st">&quot;@rules_haskell//haskell:cabal.bzl&quot;</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="st">&quot;stack_snapshot&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>stack_snapshot(</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;stackage&quot;</span>,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    <span class="co"># 利用するパッケージを列挙する</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    packages <span class="op">=</span> [</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>        <span class="st">&quot;base&quot;</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>        <span class="st">&quot;rio&quot;</span>,</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>        <span class="st">&quot;aeson&quot;</span>,</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>        <span class="st">&quot;dotenv&quot;</span>,</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>        <span class="st">&quot;extensible&quot;</span>,</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>        <span class="st">&quot;fallible&quot;</span>,</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>        <span class="st">&quot;mix&quot;</span>,</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>        <span class="st">&quot;mix-json-logger&quot;</span>,</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>        <span class="st">&quot;wreq&quot;</span>,</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>    ],</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>    <span class="co"># 自分で定義したカスタムスナップショットを指定する</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>    local_snapshot <span class="op">=</span> <span class="st">&quot;//:stack-snapshot.yaml&quot;</span>,</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>)</span></code></pre></div>
<p>ちなみに，これは github/semantic にあったやり方．</p>
<h3 id="パッケージのビルド">パッケージのビルド</h3>
<p>次に自身で記述したパッケージのビルド方法を記述する． BUILD.bazel に次のようにルールを追記するだけだ：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>load(<span class="st">&quot;@rules_haskell//haskell:defs.bzl&quot;</span>, <span class="st">&quot;haskell_library&quot;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>load(<span class="st">&quot;//:build/common.bzl&quot;</span>, <span class="st">&quot;GHC_FLAGS&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co"># You can add your own libraries with haskell_library.</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>haskell_library(</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;mdium-library&quot;</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    srcs <span class="op">=</span> glob([<span class="st">&#39;src/**/*.hs&#39;</span>]),</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    <span class="co"># WORKSPACE の stack_snapshot で明記した依存パッケージを記述している</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    deps <span class="op">=</span> [</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:base&quot;</span>,</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:rio&quot;</span>,</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:aeson&quot;</span>,</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:extensible&quot;</span>,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:fallible&quot;</span>,</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:mix&quot;</span>,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:mix-json-logger&quot;</span>,</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:wreq&quot;</span>,</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>    ],</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>    compiler_flags <span class="op">=</span> GHC_FLAGS,</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>)</span></code></pre></div>
<p>確か，<code>srcs</code> には <code>.hs</code> ファイル以外を指定しても利用できないはず． Template Haskell などで使いたい <code>.hs</code> 以外のファイルをビルド時に利用する場合は <code>extra_srcs</code> を利用する． まぁ詳しくは<a href="https://release.api.haskell.build/haskell/defs.html#haskell_library">公式ドキュメント</a>を参照してください．</p>
<p><code>GHC_FLAGS</code> という定数っぽいのは build/common.bzl というファイルに次のように記述されている：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>GHC_FLAGS <span class="op">=</span> [</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="st">&quot;-v1&quot;</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="st">&quot;-j8&quot;</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="st">&quot;-fdiagnostics-color=always&quot;</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="st">&quot;-ferror-spans&quot;</span>,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="st">&quot;-Wall&quot;</span>,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="st">&quot;-Wcompat&quot;</span>,</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="st">&quot;-Wincomplete-record-updates&quot;</span>,</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="st">&quot;-Wincomplete-uni-patterns&quot;</span>,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    <span class="st">&quot;-Wredundant-constraints&quot;</span>,</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>    <span class="st">&quot;-optP-Wno-nonportable-include-path&quot;</span>,</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="st">&quot;-DBAZEL_BUILD=1&quot;</span>,</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    <span class="st">&quot;-XNoImplicitPrelude&quot;</span>,</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    <span class="st">&quot;-XConstraintKinds&quot;</span>,</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>    <span class="st">&quot;-XDataKinds&quot;</span>,</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>    <span class="st">&quot;-XFlexibleContexts&quot;</span>,</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>    <span class="st">&quot;-XFlexibleInstances&quot;</span>,</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>    <span class="st">&quot;-XGeneralizedNewtypeDeriving&quot;</span>,</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>    <span class="st">&quot;-XLambdaCase&quot;</span>,</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>    <span class="st">&quot;-XMultiWayIf&quot;</span>,</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>    <span class="st">&quot;-XNumericUnderscores&quot;</span>,</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>    <span class="st">&quot;-XOverloadedLabels&quot;</span>,</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>    <span class="st">&quot;-XOverloadedStrings&quot;</span>,</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>    <span class="st">&quot;-XPolyKinds&quot;</span>,</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a>    <span class="st">&quot;-XRankNTypes&quot;</span>,</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true"></a>    <span class="st">&quot;-XStandaloneDeriving&quot;</span>,</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true"></a>    <span class="st">&quot;-XTypeFamilies&quot;</span>,</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true"></a>    <span class="st">&quot;-XTypeOperators&quot;</span>,</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true"></a>    <span class="st">&quot;-XTypeSynonymInstances&quot;</span>,</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true"></a>]</span></code></pre></div>
<p>これも github/semantic を参考にしたやり方だ．</p>
<p>あとは <code>bazelisk build //:mdium-library</code> というコマンドを実行することでパッケージのビルドができる． なお，初回は30分ぐらい時間がかかるので注意．</p>
<h3 id="バイナリのビルド">バイナリのビルド</h3>
<p>あとはバイナリをビルドするだけだ．バイナリの場合は BUILD.bazel に次のようにルールを追記する：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>load(<span class="st">&quot;@rules_haskell//haskell:defs.bzl&quot;</span>, <span class="st">&quot;haskell_binary&quot;</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>haskell_binary(</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;mdium&quot;</span>,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    srcs <span class="op">=</span> glob([<span class="st">&quot;app/**/*.hs&quot;</span>]),</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    deps <span class="op">=</span> [</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>        <span class="st">&quot;:mdium-library&quot;</span>, <span class="co"># 前小節で作ったパッケージ</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:base&quot;</span>,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:rio&quot;</span>,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:extensible&quot;</span>,</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        <span class="st">&quot;@stackage//:dotenv&quot;</span>,</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    ],</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    compiler_flags <span class="op">=</span> GHC_FLAGS,</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>)</span></code></pre></div>
<p>あとは <code>bazelisk build //:mdium</code> というコマンドでバイナリのビルドができる．</p>
<p>ただし，<code>--version</code> オプションがうまくコンパイルできないので，一旦この部分を削除することにした． というのも，(1) paths_module は自動生成されないのと (2) githash パッケージ（.git からバージョン情報を組み立てる）が動作しないためである． (1) は頑張ってとりあえず解決したので後述する．</p>
<h3 id="github-actions-を設定する">GitHub Actions を設定する</h3>
<p>最後に，CI/CD を回すために GitHub Actions を設定しておく． なんと，bazel と bazelisk コマンドはデフォルトで全てのプラットフォームにインストールされてるので，そのままコマンドを実行できる．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> Build Application</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">on</span><span class="kw">:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="at">  </span><span class="fu">pull_request</span><span class="kw">:</span><span class="at"> </span><span class="ch">null</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="at">  </span><span class="fu">push</span><span class="kw">:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="at">    </span><span class="fu">branches</span><span class="kw">:</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> master</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="at">  </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-18.04</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> actions/checkout@v2</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Cache Bazel</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> actions/cache@v2</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a><span class="fu">        path</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>          ~/.cache/bazel</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a><span class="at">        </span><span class="fu">key</span><span class="kw">:</span><span class="at"> ${{ runner.os }}-${{ hashFiles(&#39;WORKSPACE&#39;) }}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build binary</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a><span class="fu">      run</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>        bazelisk build //:mdium</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>        bazel-bin/mdium --help</span></code></pre></div>
<p>キャッシュは1G以上あったが，30分近くかかったビルドが2分ぐらいで終わるようになるのでできれば設定した方がいいんじゃないかな．</p>
<h2 id="バージョン情報を埋め込む">バージョン情報を埋め込む</h2>
<p>かなり苦戦した． 色々試した結果，まずは path_module を自分で生成することにした． build/rules/haskell/def.bzl というファイルを作成し，そこに自作ルールを次のように記述した：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>load(<span class="st">&quot;@rules_haskell//haskell:defs.bzl&quot;</span>, <span class="st">&quot;haskell_library&quot;</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="kw">def</span> paths_module(name, package, version, <span class="bu">dir</span> <span class="op">=</span> <span class="st">&quot;gen_paths&quot;</span>, deps <span class="op">=</span> [<span class="st">&quot;@stackage//:base&quot;</span>], <span class="op">**</span>kwargs):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    module_name <span class="op">=</span> <span class="st">&quot;Paths_&quot;</span> <span class="op">+</span> package.replace(<span class="st">&quot;-&quot;</span>, <span class="st">&quot;_&quot;</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    paths_file <span class="op">=</span> <span class="bu">dir</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> module_name <span class="op">+</span> <span class="st">&quot;.hs&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    _generate_paths_module(name <span class="op">=</span> paths_file, module <span class="op">=</span> module_name, version <span class="op">=</span> version)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    haskell_library(name <span class="op">=</span> name, srcs <span class="op">=</span> [paths_file], deps <span class="op">=</span> deps, <span class="op">**</span>kwargs)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>_generate_paths_module <span class="op">=</span> rule(</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    _generate_paths_module_impl,</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>    attrs <span class="op">=</span> {</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>        <span class="st">&quot;module&quot;</span>: attr.string(),</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>        <span class="st">&quot;version&quot;</span>: attr.string(),</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>        <span class="st">&quot;_template&quot;</span>: attr.label(</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>            default <span class="op">=</span> <span class="st">&quot;:Paths_module.hs&quot;</span>,</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>            allow_single_file <span class="op">=</span> <span class="va">True</span>,</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>        ),</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>    },</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a><span class="kw">def</span> _generate_paths_module_impl(ctx):</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>    paths_file <span class="op">=</span> ctx.actions.declare_file(ctx.label.name)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a>    ctx.actions.expand_template(</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>        template <span class="op">=</span> ctx.<span class="bu">file</span>._template,</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>        output <span class="op">=</span> paths_file,</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true"></a>        substitutions <span class="op">=</span> {</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true"></a>            <span class="st">&quot;%</span><span class="sc">{module_name}</span><span class="st">&quot;</span>: ctx.attr.module,</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true"></a>            <span class="st">&quot;%</span><span class="sc">{version}</span><span class="st">&quot;</span>: <span class="bu">str</span>(ctx.attr.version.replace(<span class="st">&quot;.&quot;</span>, <span class="st">&quot;,&quot;</span>)),</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true"></a>        },</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true"></a>    )</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true"></a>    <span class="cf">return</span> struct(files <span class="op">=</span> depset([paths_file]))</span></code></pre></div>
<p>やってることは単純で，<code>_generate_paths_module</code> という自作ルールで <code>Paths_xxx.hs</code> というファイルを生成し（普段は Cabal とかがやってるはず），それを <code>haskell_library</code> を利用して Bazel で参照できるパッケージにしている．</p>
<h3 id="ルールの自作">ルールの自作</h3>
<p>ルールの自作は，結構慣れてこないと難しいのだが簡単に説明する． ルールを自作するには，<code>rule_name = rule(...)</code> というふうにメソッドっぽいものを定義する． このルールで使える引数を <code>attrs</code> という名前付き引数で指定している．<code>_generate_paths_module</code> の場合は：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>_generate_paths_module <span class="op">=</span> rule(</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    _generate_paths_module_impl,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    attrs <span class="op">=</span> {</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>        <span class="st">&quot;module&quot;</span>: attr.string(),</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>        <span class="st">&quot;version&quot;</span>: attr.string(),</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>        <span class="st">&quot;_template&quot;</span>: attr.label(</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>            default <span class="op">=</span> <span class="st">&quot;:Paths_module.hs&quot;</span>,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>            allow_single_file <span class="op">=</span> <span class="va">True</span>,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>        ),</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    },</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>)</span></code></pre></div>
<p><code>module</code> と <code>version</code> がある（アンダースコアから始まる引数は普通デフォルト値でしか利用しないみたい）． 実際のルールの実装は1引数目（あるいは <code>implementation</code> という名前付き引数）で指定する． つまり <code>_generate_paths_module_impl</code> というのが，<code>_generate_paths_module</code> の実装部分である（名前の通りですね）．</p>
<p>ルールの実装に当たるメソッドの引数には ctx というのが割り当てられる． 詳しくは<a href="https://docs.bazel.build/versions/master/skylark/lib/ctx.html">公式ドキュメント</a>を参照して欲しいが，この引数からルールに与えられた引数を参照したり（<code>ctx.attr</code>），ファイルのダウンロードやテンプレートの展開をしたりができる（<code>ctx.actions</code>）． <code>_generate_paths_module_impl</code> の場合は：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">def</span> _generate_paths_module_impl(ctx):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    paths_file <span class="op">=</span> ctx.actions.declare_file(ctx.label.name)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    ctx.actions.expand_template(</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>        template <span class="op">=</span> ctx.<span class="bu">file</span>._template,</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>        output <span class="op">=</span> paths_file,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>        substitutions <span class="op">=</span> {</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>            <span class="st">&quot;%</span><span class="sc">{module_name}</span><span class="st">&quot;</span>: ctx.attr.module,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>            <span class="st">&quot;%</span><span class="sc">{version}</span><span class="st">&quot;</span>: <span class="bu">str</span>(ctx.attr.version.replace(<span class="st">&quot;.&quot;</span>, <span class="st">&quot;,&quot;</span>)),</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>        },</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    )</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="cf">return</span> struct(files <span class="op">=</span> depset([paths_file]))</span></code></pre></div>
<p><code>ctx.actions.expand_template</code> で，テンプレートの展開をしている． <code>substitutions</code> はテンプレートファイル内にある文字列の置換用辞書だ． テンプレートファイルは <code>_template</code> という引数のデフォルト値で指定しており，build/rules/haskell/Paths_module.hs という次のようなファイルを使っている：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">module</span> <span class="op">%</span>{module_name} <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Version</span> (<span class="dt">Version</span> (..))</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="ot">version ::</span> <span class="dt">Version</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>version <span class="ot">=</span> <span class="dt">Version</span> [<span class="op">%</span>{version}] []</span></code></pre></div>
<p>モジュール名はパッケージ名の区切りもじを <code>_</code> に置換して，<code>Paths_</code> というプレフィックスをつけたものだ（最初の <code>paths_module</code> メソッドの冒頭でやっている）． バージョンは <code>1.2.3</code> などのままでは使えないので，<code>.</code> を <code>,</code> に置換してからテンプレートに埋め込んでいる． ちなみに，テンプレートファイルのように <code>BUILD</code> ファイル外のファイルを利用するには次のような <code>BUILD</code> ファイルを記述して公開設定をしておく必要がある：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co"># build/rules/haskell/BUILD.bazel</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>filegroup(name <span class="op">=</span> <span class="st">&quot;all&quot;</span>, srcs <span class="op">=</span> glob([<span class="st">&quot;*&quot;</span>]), visibility <span class="op">=</span> [<span class="st">&quot;//visibility:public&quot;</span>])</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>exports_files([<span class="st">&quot;Paths_module.hs&quot;</span>], visibility <span class="op">=</span> [<span class="st">&quot;//visibility:public&quot;</span>])</span></code></pre></div>
<h3 id="自作ルールを利用する">自作ルールを利用する</h3>
<p>あとは BUILD.bazel に次のように追記することで paths_module が生成される：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>load(<span class="st">&quot;//build/rules/haskell:def.bzl&quot;</span>, <span class="st">&quot;paths_module&quot;</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>paths_module(</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;paths_module&quot;</span>,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    package <span class="op">=</span> <span class="st">&quot;mdium&quot;</span>,</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    version <span class="op">=</span> <span class="st">&quot;1.0.0&quot;</span>,</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>)</span></code></pre></div>
<p><code>haskell_binary</code> の方の <code>deps</code> に <code>:paths_module</code> を追記することで <code>Paths_mdium</code> モジュールを利用できるようになる． これを利用して <code>--version</code> オプションを復活させた．</p>
<h2 id="github-container-registry-にプッシュする">GitHub Container Registry にプッシュする</h2>
<p>最後に Bazel で Docker イメージのビルドを行い，それを GitHub Container Registry にプッシュできるようにしておく．</p>
<h3 id="rules_docker-の準備">rules_docker の準備</h3>
<p>Docker の操作を行うには rules_docker を利用する．rules_docker を利用するためにまずは WORKSPACE に rules_docker の設定を追記しよう：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>http_archive(</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;io_bazel_rules_docker&quot;</span>,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    sha256 <span class="op">=</span> <span class="st">&quot;1698624e878b0607052ae6131aa216d45ebb63871ec497f26c67455b34119c80&quot;</span>,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    strip_prefix <span class="op">=</span> <span class="st">&quot;rules_docker-0.15.0&quot;</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    urls <span class="op">=</span> [<span class="st">&quot;https://github.com/bazelbuild/rules_docker/releases/download/v0.15.0/rules_docker-v0.15.0.tar.gz&quot;</span>],</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>load(</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>    <span class="st">&quot;@io_bazel_rules_docker//repositories:repositories.bzl&quot;</span>,</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>    container_repositories <span class="op">=</span> <span class="st">&quot;repositories&quot;</span>,</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>container_repositories()</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>load(<span class="st">&quot;@io_bazel_rules_docker//repositories:deps.bzl&quot;</span>, container_deps <span class="op">=</span> <span class="st">&quot;deps&quot;</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>container_deps()</span></code></pre></div>
<p>これは rules_docker の README に書いてある追記の仕方なのだが，このままビルドしようとすると次のようなエラーが出た：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>$ <span class="ex">bazel</span> build //:image</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="ex">ERROR</span>: error loading package <span class="st">&#39;&#39;</span>: in /path/to/external/io_bazel_rules_docker/repositories/deps.bzl: in /path/to/external/io_bazel_rules_docker/repositories/py_repositories.bzl: Label <span class="st">&#39;@rules_python//python/legacy_pip_import:pip.bzl&#39;</span> is invalid because <span class="st">&#39;python/legacy_pip_import&#39;</span> is not a package<span class="kw">;</span> <span class="ex">perhaps</span> you meant to put the colon here: <span class="st">&#39;@rules_python//python:legacy_pip_import/pip.bzl&#39;</span>?</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="ex">INFO</span>: Elapsed time: 0.235s</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="ex">INFO</span>: 0 processes.</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="ex">FAILED</span>: Build did NOT complete successfully (0 packages loaded)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    <span class="ex">Fetching</span> @bazel_gazelle<span class="kw">;</span> <span class="ex">fetching</span></span></code></pre></div>
<p>色々調べたところ，これはどうやら <a href="https://github.com/bazelbuild/rules_docker/issues/1670#issuecomment-734249355">rules_docker が依存している rules_python v0.1.0 より古い rules_python を利用しようとしてエラーが起きている</a>ようだった． 実は rules_haskell が古い rules_python v0.0.1 に依存しており，rules_docker が最新をダウンロードするよりも先に古いほうの rules_python をダウンロードしてしまう（WORKSPACE ファイル内で先に書いてあるので）． なので，rules_haskell よりも先に，明示的に rules_python v0.1.0 を自分でダウンロードするようにした：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>http_archive(</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;rules_python&quot;</span>,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    sha256 <span class="op">=</span> <span class="st">&quot;b6d46438523a3ec0f3cead544190ee13223a52f6a6765a29eae7b7cc24cc83a0&quot;</span>,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    urls <span class="op">=</span> [<span class="st">&quot;https://github.com/bazelbuild/rules_python/releases/download/0.1.0/rules_python-0.1.0.tar.gz&quot;</span>],</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a><span class="co"># Download rules_haskell and make it accessible as &quot;@rules_haskell&quot;.</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>http_archive(</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;rules_haskell&quot;</span>,</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>    ...</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>)</span></code></pre></div>
<p>幸いにも，rules_haskell は v0.1.0 の rules_python を使っても動作している． 今のところは．</p>
<h3 id="ベースイメージのプル">ベースイメージのプル</h3>
<p>ベースイメージの準備は WORKSPACE に次のように記述する：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>load(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>    <span class="st">&quot;@io_bazel_rules_docker//container:container.bzl&quot;</span>,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    <span class="st">&quot;container_pull&quot;</span>,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>container_pull(</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;haskell_base&quot;</span>,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    registry <span class="op">=</span> <span class="st">&quot;registry.hub.docker.com&quot;</span>,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>    repository <span class="op">=</span> <span class="st">&quot;matsubara0507/ubuntu-for-haskell&quot;</span>,</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>    digest <span class="op">=</span> <span class="st">&quot;sha256:5967c5908a6c79dc4f4253badfe90326aaf4584a3eaa42d9c9ecc5ae8ba4d133&quot;</span>,</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>)</span></code></pre></div>
<p>ちなみにこれは<a href="https://hub.docker.com/r/matsubara0507/ubuntu-for-haskell">自作しているやつ</a>です．</p>
<h3 id="イメージのビルドとプッシュ">イメージのビルドとプッシュ</h3>
<p>ここからは BUILD.bazel の方に記述する． イメージの設定を追加する前に，バイナリをパッケージ化しておこう：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>load(<span class="st">&quot;@rules_pkg//:pkg.bzl&quot;</span>, <span class="st">&quot;pkg_tar&quot;</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>pkg_tar(</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;mdium-bin&quot;</span>,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    srcs <span class="op">=</span> [<span class="st">&quot;:mdium&quot;</span>],</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>    mode <span class="op">=</span> <span class="st">&quot;0755&quot;</span>,</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>    package_dir <span class="op">=</span> <span class="st">&quot;/usr/local/bin&quot;</span>,</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>)</span></code></pre></div>
<p>こうすることで，バイナリのイメージへの展開先などが指定できて便利だ． イメージのビルドとプッシュの設定はこんな感じだ：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>load(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>    <span class="st">&quot;@io_bazel_rules_docker//container:container.bzl&quot;</span>,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    <span class="st">&quot;container_image&quot;</span>,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    <span class="st">&quot;container_push&quot;</span>,</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>container_image(</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;mdium-image&quot;</span>,</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>    base <span class="op">=</span> <span class="st">&quot;@haskell_base//image&quot;</span>,</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>    tars <span class="op">=</span> [<span class="st">&quot;:mdium-bin&quot;</span>],</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>    entrypoint <span class="op">=</span> [<span class="st">&quot;/usr/local/bin/mdium&quot;</span>],</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>container_push(</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>    name <span class="op">=</span> <span class="st">&quot;push&quot;</span>,</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>    <span class="bu">format</span> <span class="op">=</span> <span class="st">&quot;Docker&quot;</span>,</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a>    image <span class="op">=</span> <span class="st">&quot;:mdium-image&quot;</span>,</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a>    registry <span class="op">=</span> <span class="st">&quot;ghcr.io&quot;</span>,</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a>    repository <span class="op">=</span> <span class="st">&quot;matsubara0507/mdium&quot;</span>,</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a>)</span></code></pre></div>
<p>これで <code>bazelisk run //:push</code> で GitHub Container Registry へプッシュできる（先に <code>docker login</code> などの設定は済んでいる前提です）． ただ問題が1つある． 実はベースイメージは ubuntu だが，バイナリはビルド環境のものになっている． 例えば，Mac でこのコマンドを実行してしまうと，プッシュされたイメージでの <code>docker run</code> は次のようなエラーとなる：</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>$ <span class="ex">docker</span> run --rm bazel:mdium-image</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="ex">standard_init_linux.go</span>:211: exec user process caused <span class="st">&quot;exec format error&quot;</span></span></code></pre></div>
<p><a href="https://github.com/tweag/rules_haskell/issues/32">rules_haskell はどうやらまだ，クロスコンパイルをサポートしていない</a>ようなのでこれは仕方ない（そもそも Haskell のクロスコンパイルは難しい）． Haskell Stack なら Docker インテグレーションを使って割と簡単にできるが，，，どうしたものか． ということで，GitHub Actions に頼ることにした．</p>
<h3 id="github-actions-からプッシュする">GitHub Actions からプッシュする</h3>
<p>GitHub Actions の ubuntu イメージでイメージのビルドとプッシュをしてしまえば，正しい Docker イメージを構築できそうだ． ということで，その設定を次のように追記する：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> Build Application</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="fu">on</span><span class="kw">:</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="at">  </span><span class="fu">pull_request</span><span class="kw">:</span><span class="at"> </span><span class="ch">null</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span class="at">  </span><span class="fu">push</span><span class="kw">:</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a><span class="at">    </span><span class="fu">branches</span><span class="kw">:</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> master</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a><span class="at">  </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a><span class="at">    ...</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a><span class="at">    ...</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build image</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> bazelisk build //:mdium-image</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Setup QEMU</span><span class="co"> # ここはいらないかも</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> docker/setup-qemu-action@master</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true"></a><span class="at">        </span><span class="fu">platforms</span><span class="kw">:</span><span class="at"> all</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true"></a></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Login to GitHub Container Registry</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> docker/login-action@v1</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true"></a><span class="at">        </span><span class="fu">registry</span><span class="kw">:</span><span class="at"> ghcr.io</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true"></a><span class="at">        </span><span class="fu">username</span><span class="kw">:</span><span class="at"> matsubara0507</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true"></a><span class="at">        </span><span class="fu">password</span><span class="kw">:</span><span class="at"> ${{ secrets.CR_PAT }}</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Push image</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true"></a><span class="at">      </span><span class="fu">if</span><span class="kw">:</span><span class="at"> ${{ github.event_name != &#39;pull_request&#39; }}</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> bazelisk run //:push</span></span></code></pre></div>
<p><a href="https://github.com/docker/login-action"><code>docker/login-action</code></a> を使うことで，様々なレジストリの <code>docker login</code> を済ましてくれる． それ以外はただシンプルに bazel コマンドを実行しているだけだ．</p>
<h2 id="おしまい">おしまい</h2>
<p>Bazel を利用することで，Haskell コードのビルドの他に Docker イメージのビルドなどの設定も同じビルドツールで管理できるようになります． 正直，Docker だけだとあまりメリットを感じませんが，例えば Web アプリケーションを作るためにフロント用言語（例えば TypeScript や Elm など）も Bazel でビルドしたり，k8s でのデプロイも Bazel で行えるようになったりすればメリットがどんどん大きくなってきますね．</p>
<p>しかし，Bazel の「やってみた・使ってみた」記事は少なく，Haskell 関連や日本語記事となると本当にちょっとしかありません． ので，できるだけ増やして行こうかなーっていう野心です．</p>
  </div>]]></summary>
</entry>
<entry>
    <title>Hacktoberfest 2020 なので PR を4つ出してみた</title>
    <link href="https://matsubara0507.github.io/posts/2020-10-27-join-hacktoberfest%5B-2020.html" />
    <id>https://matsubara0507.github.io/posts/2020-10-27-join-hacktoberfest%5B-2020.html</id>
    <published>2020-10-27T00:00:00Z</published>
    <updated>2020-10-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>Hacktoberfest 2020 がきたので今年もPRを出してきました．</p>
<p><img src="/assets/join-hacktoberfest-2020/status.jpg"></img></p>
<h2 id="hacktoberfest-2020">Hacktoberfest 2020</h2>
<p>例年と異なり，PR のカウントの仕方が（途中から）変わった． もともとは Public なリポジトリに対する PR ならなんでもよかったが，途中から次のいずれかのみカウントされるようになった：</p>
<ul>
<li><code>hacktoberfest</code> topic のついた Public リポジトリに対する PR で，Approve か Merge されたもの</li>
<li>Public リポジトリの PR で <code>hacktoberfest-accepted</code> ラベルがついたもの</li>
</ul>
<p>普段使っているパッケージのリポジトリなどには軒並み <code>hacktoberfest</code> topic がついていなかったので，ついてるリポジトリを1つ選んで献上しようかなと考えた． <code>hacktoberfest</code> topic と Haskell で検索したところ，昔から興味のあった Egison 言語にも <code>hacktoberfest</code> topic がついていたので，これにコミットすることにした．</p>
<h3 id="egison">Egison</h3>
<p><a href="https://github.com/egison/egison">Egison</a> はパターンマッチ指向プログラミング言語というもので，他のプログラミング言語とは比べ物にならないほど強力なパターンマッチ機能を持っている：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- 素数の無限リストから全ての双子素数をパターンマッチにより抽出</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>def twinPrimes <span class="op">:=</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  matchAll primes as list integer with</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="op">|</span> _ <span class="op">++</span> <span class="op">$</span><span class="ot">p ::</span> <span class="op">#</span>(p <span class="op">+</span> <span class="dv">2</span>)<span class="ot"> ::</span> _ <span class="ot">-&gt;</span> (p, p <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">-- 最初の5個の双子素数を列挙</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="fu">take</span> <span class="dv">5</span> twinPrimes</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="co">-- =&gt; [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31)]</span></span></code></pre></div>
<p>これは <a href="https://www.egison.org">Egison の公式サイト</a>に載っている例だ． 素数の無限リスト <code>primes</code> 自体は標準パッケージに（なぜか）入っているものだ． 双子素数は差が 2 しかない素数の組である．</p>
<p>最近だと数式処理などにも力を入れているようだ．</p>
<h3 id="出した-pr">出した PR</h3>
<ol type="1">
<li><a href="https://github.com/egison/egison/pull/255">コマンドオプションのテスト</a></li>
<li><a href="https://github.com/egison/egison/pull/258">ドキュメントの修正（<code>def</code> キーワードの追加）</a></li>
<li><a href="https://github.com/egison/egison/pull/260">中置関数の導入</a></li>
<li><a href="https://github.com/egison/egison/pull/261">テストの個別実行を可能にする</a></li>
</ol>
<h2 id="コマンドオプションのテスト">1. コマンドオプションのテスト</h2>
<p>これは <code>good first issue</code> としてすでにあったやつだ．</p>
<p><a href="https://github.com/egison/egison/issues/244"><img src="/assets/join-hacktoberfest-2020/test-cli-opts-issue.jpg"></img></a></p>
<p>どうしようかなと考えた結果 <a href="http://hackage.haskell.org/package/process-1.6.10.0/docs/System-Process.html#v:readProcess"><code>readProcess</code></a> を使うことにした． <code>stack exec -- egison</code> をこの関数で実行して，その出力が意図通りかをテストする：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework</span>                 (defaultMain)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework.Providers.HUnit</span> (hUnitTestToTests)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.HUnit</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">System.Process</span>                 (readProcess)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>main <span class="ot">=</span> defaultMain <span class="op">.</span> hUnitTestToTests <span class="op">.</span> test <span class="op">$</span> <span class="dt">TestList</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    [ <span class="dt">TestLabel</span> <span class="st">&quot;eval option&quot;</span> <span class="op">.</span> <span class="dt">TestCase</span> <span class="op">$</span> assertEgisonCmd</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>        <span class="st">&quot;[[], [1], [1, 2], [1, 2, 3]]\n&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        [<span class="st">&quot;--eval&quot;</span>, <span class="st">&quot;matchAll [1,2,3] as list something with $x ++ _ -&gt; x&quot;</span>]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>        <span class="st">&quot;&quot;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    ]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>assertEgisonCmd</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="ot">  ::</span> <span class="dt">String</span>   <span class="co">-- The expected value</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>  <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="co">-- any arguments for egison command</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>   <span class="co">-- standard input for egison command</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">Assertion</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>assertEgisonCmd expected args input <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>  actual <span class="ot">&lt;-</span> readProcess <span class="st">&quot;stack&quot;</span> (<span class="st">&quot;exec&quot;</span> <span class="op">:</span> <span class="st">&quot;--&quot;</span> <span class="op">:</span> <span class="st">&quot;egison&quot;</span> <span class="op">:</span> args) input</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>  assertEqual <span class="st">&quot;&quot;</span> expected actual</span></code></pre></div>
<p>こういうことをやってくれるライブラリもあるかもしれないが，あまり依存パッケージを増やすのも嫌だったので既に使われてるパッケージで実現できる方法にした． ちなみに，<code>egison</code> コマンドは <code>--eval</code> オプションなどを使わない場合はREPLが起動する：</p>
<pre><code>$ stack exec -- egison
Egison Version 4.1.1
https://www.egison.org
Welcome to Egison Interpreter!
&gt; 1 + 1
2
&gt;
Leaving Egison Interpreter.</code></pre>
<p><code>readProcess</code> は標準入力も与えることができるので，これを使ってREPLを介したテストも可能だ：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Version</span>    (showVersion)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Language.Egison</span> (version)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="op">...</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    [ <span class="dt">TestLabel</span> <span class="st">&quot;load-file option&quot;</span> <span class="op">.</span> <span class="dt">TestCase</span> <span class="op">$</span> assertEgisonCmd</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        (interpreter <span class="st">&quot;1\n&quot;</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        [<span class="st">&quot;--load-file&quot;</span>, <span class="st">&quot;test/fixture/a.egi&quot;</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="st">&quot;x&quot;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    ]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="ot">interpreter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>interpreter output <span class="ot">=</span> <span class="fu">concat</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  [ <span class="st">&quot;Egison Version &quot;</span>, showVersion version, <span class="st">&quot;\n&quot;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  , <span class="st">&quot;https://www.egison.org\n&quot;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>  , <span class="st">&quot;Welcome to Egison Interpreter!\n&quot;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>  , <span class="st">&quot;&gt; &quot;</span>, output</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>  , <span class="st">&quot;&gt; Leaving Egison Interpreter.\n&quot;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  ]</span></code></pre></div>
<h2 id="ドキュメントの修正def-キーワードの追加">2. ドキュメントの修正（<code>def</code> キーワードの追加）</h2>
<p>コマンドオプションのテストケースは <a href="https://egison.readthedocs.io/en/latest/reference/command-line-options.html">Issue にあったドキュメント</a>を参考に実装した． そのドキュメントの通りに実装したらコンパイルエラーになった：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec -- egison -l test/fixture/name-of-file-to-load.egi</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ex">Parse</span> error at: egison:1:3:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="kw">|</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">x</span> := 1</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  <span class="kw">|</span>   ^</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="ex">unexpected</span> <span class="st">&#39;:&#39;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ex">expecting</span> <span class="st">&quot;...&quot;</span>, <span class="st">&quot;where&quot;</span>, atomic expression, end of input, index, or infix</span></code></pre></div>
<p>これは，Egison のバージョン4.1.0から変わった記法で，変数や関数定義のときに <code>def</code> キーワードが必要になったのだ． コマンドオプションのテスト追加PRで「ついでにこのPRでドキュメントも修正しますか？それとも別で出した方が良いですか？」と聞いたところ「余力があるならぜひ別で良いので出してください」と返って来たので別PRで出した次第．</p>
<h2 id="中置関数の導入">3. 中置関数の導入</h2>
<p>Haskell に関数の中置記法がある． 任意の関数に対して，バッククォートで囲ってあげることで二項演算子のように使うことができる：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> <span class="dv">1</span> <span class="ot">`add`</span> <span class="dv">2</span> <span class="co">-- =&gt; display `3`</span></span></code></pre></div>
<p>これを Egison にも導入して欲しいという Issue が既にあった：</p>
<p><a href="https://github.com/egison/egison/issues/135"><img src="/assets/join-hacktoberfest-2020/infix-func-issue.jpg"></img></a></p>
<p>他の出したPRと異なりガッツリ処理系をいじる必要がある． 言わずもがな，一番難しかった．</p>
<p>Issue には注意点として，右に閉じバッククォートがない場合は <code>QuoteSymbolExpr</code> となると書いてあった（おそらくLispのマクロ由来の逆クォート）． 試しに，現状の Egison で中置関数を記述してみると：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec -- egison</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ex">Egison</span> Version 4.1.1</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="ex">https</span>://www.egison.org</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="ex">Welcome</span> to Egison Interpreter!</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">1</span> + 2</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">def</span> add x y := x + y</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">add</span> 1 2</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">1</span> <span class="kw">`</span><span class="ex">add</span><span class="kw">`</span> 2</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a><span class="ex">Parse</span> error at: egison:1:8:</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>  <span class="kw">|</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">1</span> <span class="kw">`</span><span class="ex">add</span><span class="kw">`</span> 2</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>  <span class="kw">|</span>        ^^</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="ex">unexpected</span> <span class="st">&quot; 2&quot;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a><span class="ex">expecting</span> atomic expression</span></code></pre></div>
<p>もちろんダメだった．</p>
<h3 id="演算子のパーサーはどこか">演算子のパーサーはどこか</h3>
<p>Egison はパーサーに megaparsec を利用しており，演算子のパーサーは次のようになっている：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">CustomError</span> <span class="dt">String</span> <span class="dt">RuntimeM</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="ot">opExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>opExpr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  ops <span class="ot">&lt;-</span> gets exprOps</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  makeExprParser exprInOp (makeExprTable ops)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="ot">exprInOp ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>exprInOp <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="ot">makeExprTable ::</span> [<span class="dt">Op</span>] <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>makeExprTable ops <span class="ot">=</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  <span class="fu">map</span> (<span class="fu">map</span> toOperator) (groupBy (\x y <span class="ot">-&gt;</span> priority x <span class="op">==</span> priority y) ops)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    <span class="co">-- 実装は割愛</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="ot">    unary ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a><span class="ot">    binary ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="ot">    toOperator ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span></code></pre></div>
<p><code>makeExprParser</code> は <a href="https://hackage.haskell.org/package/parser-combinators-1.2.1/docs/Control-Monad-Combinators-Expr.html#v:makeExprParser">megaparsec（が依存している parser-combinators パッケージ）の関数</a>である．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>makeExprParser</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="ot">  ::</span> <span class="dt">MonadPlus</span> m	 </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="ot">=&gt;</span> m a              <span class="co">-- 二項演算子の引数に当たる部分のパーサー</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> m a]] <span class="co">-- 演算子のパーサーのテーブル</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>2引数目の <code>[[Operator m a]]</code> が今回のキモだ． <code>Operator m a</code> は演算子のパーサーで，<code>[[Operator m a]]</code> は演算子の優先順位（<code>priority</code>）の高い順に <code>Operator m a</code> のリストが並んでいる． <code>gets exprOps</code> は <code>Parser</code> が保持している演算子（<code>Op</code> 型）の集合を返している（<code>ReaderT</code> で保持している）：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Op</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Op</span> {<span class="ot"> repr     ::</span> <span class="dt">String</span>  <span class="co">-- representation</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>       ,<span class="ot"> priority ::</span> <span class="dt">Int</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>       ,<span class="ot"> assoc    ::</span> <span class="dt">Assoc</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>       ,<span class="ot"> isWedge  ::</span> <span class="dt">Bool</span>    <span class="co">-- これはよくわからない</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>       }</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Assoc</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">InfixL</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">InfixR</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">InfixN</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Prefix</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>そして，<code>makeExprTable</code> はこの演算子のリストをもらって，<code>makeExprParser</code> 関数に渡すための演算子パーサー群を生成するための関数だ．</p>
<h3 id="中置関数のパーサーを作る">中置関数のパーサーを作る</h3>
<p>最初は愚直に，関数定義のたびに演算子（<code>Op</code> 型）を生成して，<code>Parser</code> にセットしてあげれば良いかなと雑に考えていたが、これを網羅的にやるのはめんどくさいコトに気づいた． <code>makeExprTable</code> では演算子（<code>Op</code> 型）と演算子パーサーが一対一対応するように作っているが，よく考えたら <code>Operator m a</code> 型はただのパーサーなのでもっと自由に書けるはずだということに気づいた． ということで，中置関数を追加するために <code>makeExprTable</code> へ新しい中治関数用の演算子パーサーを追加することにした：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">makeExprTable ::</span> [<span class="dt">Op</span>] <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>makeExprTable ops <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="fu">reverse</span> <span class="op">$</span> <span class="fu">map</span> (<span class="fu">map</span> <span class="fu">snd</span>) <span class="op">$</span> groupBy ((<span class="op">==</span>) <span class="ot">`on`</span> <span class="fu">fst</span>) <span class="op">$</span> sortOn <span class="fu">fst</span> <span class="op">$</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    (infixFuncOpPriority, infixFuncOperator) <span class="op">:</span> <span class="fu">map</span> (\op <span class="ot">-&gt;</span> (priority op, toOperator op)) ops</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    <span class="co">-- 実装は割愛</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="ot">    unary ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="ot">    binary ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="ot">    toOperator ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="ot">    infixFuncOperator ::</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    infixFuncOperator <span class="ot">=</span> <span class="dt">InfixL</span> <span class="op">$</span> <span class="dt">InfixExpr</span> <span class="op">&lt;$&gt;</span> infixFuncOp</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a><span class="ot">infixFuncOp ::</span> <span class="dt">Parser</span> <span class="dt">Op</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>infixFuncOp <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>  func <span class="ot">&lt;-</span> try (indented <span class="op">&gt;&gt;</span> between (symbol <span class="st">&quot;`&quot;</span>) (symbol <span class="st">&quot;`&quot;</span>) ident)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Op</span> { repr <span class="ot">=</span> func, priority <span class="ot">=</span> infixFuncOpPriority, assoc <span class="ot">=</span> <span class="dt">E.InfixL</span>, isWedge <span class="ot">=</span> <span class="dt">False</span> }</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a><span class="ot">infixFuncOpPriority ::</span> <span class="dt">Int</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>infixFuncOpPriority <span class="ot">=</span> <span class="dv">7</span></span></code></pre></div>
<p>優先順位をいい感じに組み立てるために，少しわかりにくい実装をしているが，順に読んでいけばわかるはずだ：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="fu">map</span> (\op <span class="ot">-&gt;</span> (priority op, toOperator op)) ops    <span class="co">-- [(優先順位 (Int), Op から生成した演算子パーサー)]</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="op">&amp;</span> ((infixFuncOpPriority, infixFuncOperator) <span class="op">:</span>) <span class="co">-- 中置関数の演算子パーサーを追加</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="op">&amp;</span> sortOn <span class="fu">fst</span>                                   <span class="co">-- 優先順位でソート (groupBy するため)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="op">&amp;</span> groupBy ((<span class="op">==</span>) <span class="ot">`on`</span> <span class="fu">fst</span>)                      <span class="co">-- 優先順位でグループ化 ([[(優先順位, 演算子パーサー)]])</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  <span class="op">&amp;</span> <span class="fu">map</span> (<span class="fu">map</span> <span class="fu">snd</span>)                                <span class="co">-- 演算子パーサーだけ取り出す ([[演算子パーサー]])</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>  <span class="op">&amp;</span> <span class="fu">reverse</span>                                      <span class="co">-- 優先順位の低い順になっているので反転  </span></span></code></pre></div>
<p>中置関数のパーサーはシンプルでバッククォートで囲まれた識別子（<code>ident</code>）をとってきているだけだ（<code>ident</code> は変数のパーサーなどで使われている）． <code>symbol</code> を使っているのでバッククォート前後にスペースがあっても動作する． これは Haskell がそうなっていたのでそうしたが，<code>QuoteSymbolExpr</code> のある Egison ではやめた方がいいかもしれない：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ex">ghci</span><span class="op">&gt;</span> 13 <span class="kw">`</span><span class="ex">mod</span><span class="kw">`</span> 10 :: Int</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="ex">ghci</span><span class="op">&gt;</span> 13<span class="kw">`</span><span class="ex">mod</span><span class="kw">`</span>10 :: Int</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="ex">ghci</span><span class="op">&gt;</span> 13<span class="kw">`</span> <span class="ex">mod</span> <span class="kw">`</span>10 :: Int</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="ex">ghci</span><span class="op">&gt;</span> 13<span class="kw">`</span> <span class="ex">mod</span>    <span class="kw">`</span>10 :: Int</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="ex">3</span></span></code></pre></div>
<h3 id="quotesymbolexpr-の対応">QuoteSymbolExpr の対応</h3>
<p>あとは，注意点にあった <code>QuoteSymbolExpr</code> の部分をなんとかするだけだ：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">-- Atomic expressions without index</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="ot">atomExpr&#39; ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>atomExpr&#39; <span class="ot">=</span> anonParamFuncExpr</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">ConstantExpr</span> <span class="op">&lt;$&gt;</span> constantExpr</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">FreshVarExpr</span> <span class="op">&lt;$</span> symbol <span class="st">&quot;#&quot;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">VarExpr</span> <span class="op">&lt;$&gt;</span> ident</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> vectorExpr</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> collectionExpr</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> tupleOrParenExpr</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> hashExpr</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">QuoteExpr</span> <span class="op">&lt;$&gt;</span> (char <span class="ch">&#39;\&#39;&#39;</span> <span class="op">&gt;&gt;</span> atomExpr&#39;)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a> <span class="co">-- 元々 &lt;|&gt; QuoteSymbolExpr &lt;$&gt; (char &#39;`&#39; &gt;&gt; atomExpr&#39;)</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">QuoteSymbolExpr</span> <span class="op">&lt;$&gt;</span> try (char <span class="ch">&#39;`&#39;</span> <span class="op">&gt;&gt;</span> atomExpr&#39; <span class="op">&lt;*</span> notFollowedBy (char <span class="ch">&#39;`&#39;</span>))</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">AnonParamExpr</span>  <span class="op">&lt;$&gt;</span> try (char <span class="ch">&#39;%&#39;</span> <span class="op">&gt;&gt;</span> positiveIntegerLiteral)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>        <span class="op">&lt;?&gt;</span> <span class="st">&quot;atomic expression&quot;</span></span></code></pre></div>
<p><a href="https://hackage.haskell.org/package/megaparsec-9.0.0/docs/Text-Megaparsec.html#v:notFollowedBy"><code>notFollowedBy</code></a> 関数を使って後ろにバッククォートがないかをチェックしている（<code>try</code> を付けないとパーサーが入力を消費してしまう）．</p>
<h3 id="セクション記法">セクション記法</h3>
<p>実はもう1つやることがある． セクション記法に対応する必要がある（<code>(+ 1)</code> とか <code>(1 +)</code>って感じのやつ）． セクション記法のパーサーはそれぞれ <code>leftSection</code> と <code>rightSection</code> があるので，これに <code>infixFuncOp</code> を追記してあげるだけだ：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">leftSection ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>leftSection <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  ops  <span class="ot">&lt;-</span> gets exprOps</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  op   <span class="ot">&lt;-</span> choice <span class="op">$</span> <span class="fu">map</span> (infixLiteral <span class="op">.</span> repr) ops</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  op   <span class="ot">&lt;-</span> choice <span class="op">$</span> infixFuncOp <span class="op">:</span> <span class="fu">map</span> (infixLiteral <span class="op">.</span> repr) ops <span class="co">-- この (infixFuncOp :)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>  rarg <span class="ot">&lt;-</span> optional expr</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span class="kw">case</span> rarg <span class="kw">of</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>    _ <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">SectionExpr</span> op <span class="dt">Nothing</span> rarg)</span></code></pre></div>
<p>あとはよしなにテストを追加して完成．</p>
<h2 id="テストの個別実行を可能にする">4. テストの個別実行を可能にする</h2>
<p>中置関数の導入で実際は，先にテストを追加して TDD っぽく実装をしていた． その際に，<code>stack test</code> で全部のテストが実行されると非常に遅いのでテストケースを適当に指定して実行したい． ということで，そういうことができるようにした PR が最後のやつだ．</p>
<p><code>stack test</code> は <code>--test-arguments</code> オプションで実行されるテストプログラムにコマンドライン引数を渡すことができる． さらに，テストで使われている test-framework では <a href="https://hackage.haskell.org/package/test-framework-0.8.2.0/docs/Test-Framework-Runners-Console.html#v:defaultMainWithArgs"><code>defaultMainWithArgs</code></a> を使うことで簡単にリッチなオプションを追加できる：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework</span>                 (defaultMain)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework</span>                 (defaultMainWithArgs)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework.Providers.HUnit</span> (hUnitTestToTests)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.HUnit</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>  args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>  <span class="fu">flip</span> defaultMainWithArgs args <span class="op">$</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>    hUnitTestToTests <span class="op">$</span> test <span class="op">$</span> <span class="fu">map</span> runTestCase testCases</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a><span class="ot">testCases ::</span> [<span class="dt">FilePath</span>]</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>testCases <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a><span class="ot">runTestCase ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Test</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>runTestCase <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>こんなふうに実行できる（ちなみに，<code>--ta=--help</code> とすれば色々見れる）：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>$ <span class="ex">stack</span> test egison:test --ta=--select-tests=<span class="st">&quot;test/syntax.egi&quot;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="ex">egison</span><span class="op">&gt;</span> test (suite: test, args: --select-tests=test/syntax.egi)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="ex">io</span> and do expression</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="ex">io</span> and do expression without newline</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>:<span class="ex">test</span>/syntax.egi: [<span class="ex">OK</span>]</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>         <span class="ex">Test</span> Cases  Total      </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a> <span class="ex">Passed</span>  1           1          </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a> <span class="ex">Failed</span>  0           0          </span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a> <span class="ex">Total</span>   1           1          </span></code></pre></div>
<p><code>egison:test</code> の部分は Cabal ファイルに複数の <code>Test-Suite</code> が書いてある場合に指定することができる（Egison にはCLIオプションの <code>Test-Suite</code> が増えているので）．</p>
<h2 id="おしまい">おしまい</h2>
<p>今年の Hacktoberfest はちょっと炎上（このイベントをクリアするためにスパムなPRが乱立した）してて，最初はモチベーション下がっていました。 しかし，こういう時こそ正しい形で参加するのは Hacktoberfest 側にとって喜ばしいことかなと思い参加することにしました． 無事OSSに献上できてよかったです（レビューしてくれた方ありがとうございます）．</p>
  </div>]]></summary>
</entry>
<entry>
    <title>Hamler の Docker イメージを作る（その２）</title>
    <link href="https://matsubara0507.github.io/posts/2020-07-31-build-docker-image-for-hamler-part2.html" />
    <id>https://matsubara0507.github.io/posts/2020-07-31-build-docker-image-for-hamler-part2.html</id>
    <published>2020-07-31T00:00:00Z</published>
    <updated>2020-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>なんと「<a href="https://matsubara0507.github.io/posts/2020-06-13-build-docker-image-for-hamler.html">Hamler の Docker イメージを作る</a>」の第2段です． 現在，<a href="https://github.com/hamler-lang/hamler">Hamler</a> は活発に開発が進んでるのですが，そのたびに前回の方法でビルドしていると時間がかかりすぎるので新しい方法を考えたという話です．</p>
<p>ちなみに，<a href="https://hub.docker.com/r/hamlerlang/hamler">Hamler 側で公式の Docker イメージが提供されるようになりました</a>． しかし，あまりタグがうたれません． 今回の方法は任意のリビジョンで簡単に自前ビルドできるので，最新のリビジョンやフォークを試すのに非常に便利です．</p>
<h2 id="docker-イメージを作る">Docker イメージを作る</h2>
<p>今回やりたいのは最新のリビジョン（masterブランチ）で素早くイメージを作り直すこと． しかし，Docker 内で master を Haskell Stack でフルビルドし直すのはヒジョーに時間がかかる．</p>
<p>そこで Haskell Stack の Docker 機能を使って，ローカルのキャッシュをうまく利用できる方法をとることにする． 最終的にできた <a href="https://github.com/matsubara0507/docker-hamler/blob/781abfbdcf78f12d306f66593e94a3f08cbbd569/Dockerfile">Dockerfile</a> は次の通り：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">ARG</span> GHC_VERSION=8.6.5</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">ARG</span> OTP_VERSION=22.3.4.1</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">FROM</span> haskell:${GHC_VERSION} AS ghc</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION} AS build</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="kw">WORKDIR</span> /work</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">RUN</span> apt-get update &amp;&amp; apt-get install -y libtinfo5</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_REVISION</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="kw">RUN</span> mkdir hamler \</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a> &amp;&amp; cd hamler \</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a> &amp;&amp; git init \</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a> &amp;&amp; git remote add origin https://github.com/hamler-lang/hamler.git \</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a> &amp;&amp; git fetch origin $HAMLER_REVISION \</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a> &amp;&amp; git reset --hard FETCH_HEAD</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="kw">ENV</span> LC_ALL C.UTF-8</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a><span class="kw">COPY</span> --from=ghc /usr/local/bin/stack /usr/local/bin/stack</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="kw">COPY</span> --from=ghc /opt/ghc /opt/ghc</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="kw">ARG</span> local_bin_path</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="kw">COPY</span> ${local_bin_path}/hamler /usr/local/bin/hamler</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a><span class="kw">ARG</span> GHC_VERSION</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a><span class="kw">ENV</span> PATH /usr/local/bin:/opt/ghc/${GHC_VERSION}/bin:$PATH</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a><span class="kw">RUN</span> cd hamler \</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a> &amp;&amp; stack exec --system-ghc hamler build -- -l \</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a> &amp;&amp; make foreign</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_HOME=/usr/lib/hamler</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a><span class="kw">RUN</span> mkdir -p ${HAMLER_HOME}/bin \</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a> &amp;&amp; cp /usr/local/bin/hamler ${HAMLER_HOME}/bin/hamler \</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a> &amp;&amp; cp hamler/repl/replsrv ${HAMLER_HOME}/bin/replsrv \</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a> &amp;&amp; cp -r hamler/ebin  ${HAMLER_HOME} \</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a> &amp;&amp; cp -r hamler/lib  ${HAMLER_HOME}</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION}</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_HOME=/usr/lib/hamler</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a><span class="kw">WORKDIR</span> /work</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a><span class="kw">RUN</span> apt-get update &amp;&amp; apt-get install -y libtinfo5 \</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a> &amp;&amp; apt-get clean \</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a> &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a><span class="kw">COPY</span> --from=build ${HAMLER_HOME} ${HAMLER_HOME}</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a><span class="kw">ENV</span> LC_ALL C.UTF-8</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a><span class="kw">ENV</span> PATH ${HAMLER_HOME}/bin:$PATH</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a><span class="kw">ENTRYPOINT</span> [<span class="st">&quot;/usr/lib/hamler/bin/hamler&quot;</span>]</span></code></pre></div>
<h3 id="stack-with-docker">Stack with Docker</h3>
<p>ローカル環境ではなく，Docker コンテナ内でビルドをすることで Mac 上でも Linux のイメージを作ったりすることができる Haskell Stack の機能． また，ローカル環境でビルドするのと同様にキャッシュが効くので効率よくビルドすることが可能だ．</p>
<p>この辺りの涙ぐましい工夫は下記の記事でもやってる：</p>
<ul>
<li><a href="https://matsubara0507.github.io/posts/2019-06-10-build-haskell-app-docker-image-without-stack-image-cmd.html">stack image コマンドなしに Haskell アプリの Docker イメージを作る - ひげメモ</a></li>
</ul>
<p>やることはこれと同じで，Stack でビルドしたバイナリを指定した手元のパスに保存して，それを <code>docker build</code> 時にコピってくる感じ． 手元で任意のリビジョンの <code>hamler</code> をビルドするには次のような <code>stack.yaml</code> を書く：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="fu">resolver</span><span class="kw">:</span><span class="at"> lts-14.27</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="fu">allow-different-user</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="fu">extra-deps</span><span class="kw">:</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">-</span><span class="at"> happy-1.19.9</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="kw">-</span><span class="at"> language-javascript-0.7.0.0</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="kw">-</span><span class="at"> network-3.0.1.1</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="kw">-</span><span class="at"> these-1.0.1</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="kw">-</span><span class="at"> semialign-1</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">github</span><span class="kw">:</span><span class="at"> hamler-lang/CoreErlang</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="at">  </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> 2ea1038140118f5bc29f4cb14b50aa0918d62581</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">github</span><span class="kw">:</span><span class="at"> hamler-lang/purescript</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="at">  </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> bc43f3b094feee61e7b9091a69cc7154d5f7d6a7</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="kw">-</span><span class="at"> megaparsec-8.0.0@sha256:362f85e243ecbcb550e1de6e5c74ba5a50c09edaa1208c99bc5b9fd242227fc6,3808</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span class="co"># ここからの extra-deps は追記（lts-14にした関係）</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">github</span><span class="kw">:</span><span class="at"> hamler-lang/hamler</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a><span class="at">  </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> baa5f72e9139c60e4c72a7134132522e40138633</span><span class="co"> # ここでリビジョン指定する</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span class="kw">-</span><span class="at"> Glob-0.9.3</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a><span class="kw">-</span><span class="at"> ansi-terminal-0.8.2</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span class="kw">-</span><span class="at"> ansi-wl-pprint-0.6.8.2</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a><span class="kw">-</span><span class="at"> tasty-1.2</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a><span class="fu">flags</span><span class="kw">:</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a><span class="at">  </span><span class="fu">these</span><span class="kw">:</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a><span class="at">    </span><span class="fu">assoc</span><span class="kw">:</span><span class="at"> </span><span class="ch">false</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a><span class="at">    </span><span class="fu">quickcheck</span><span class="kw">:</span><span class="at"> </span><span class="ch">false</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a><span class="fu">docker</span><span class="kw">:</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a><span class="co">  # このイメージに lts-13 がないから lts-14 にした</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a><span class="at">  </span><span class="fu">repo</span><span class="kw">:</span><span class="at"> matsubara0507/stack-build</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a><span class="at">  </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a><span class="at">  </span><span class="kw">-</span><span class="at"> HAMLER_HOME=/usr/lib/hamler</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a><span class="at">  </span><span class="fu">enable</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span></code></pre></div>
<p>package.yaml はこんだけで良い：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> docker-hamler</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="fl">0.1.0</span></span></code></pre></div>
<p>これで <code>stack --local-bin-path=./bin install hamler</code> とすることで <code>./bin/hamler</code> が生成される．</p>
<h3 id="任意のリビジョンをクローンする">任意のリビジョンをクローンする</h3>
<p><code>hamler</code> バイナリは手に入るようになったが，他にもいくつか必要な作業がある． README を読むと手元でフルビルドをする場合は次のような手続きが書いてある：</p>
<pre><code>$ git clone https://github.com/hamler-lang/hamler.git
$ cd hamler
$ export LC_ALL=en_US.UTF-8
$ make
$ make install</code></pre>
<p><code>hamler</code> バイナリをビルドする必要はないが，これらの作業をするために <code>docker build</code> 内でリポジトリをクローンする必要はある． そのときに，<code>stack.yaml</code> で指定したリビジョンと同じものをクローンしたい． 調べた結果，次のようにすれば良い：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">ARG</span> OTP_VERSION=22.3.4.1</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION} AS build</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="kw">WORKDIR</span> /work</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_REVISION</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="kw">RUN</span> mkdir hamler \</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a> &amp;&amp; cd hamler \</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a> &amp;&amp; git init \</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a> &amp;&amp; git remote add origin https://github.com/hamler-lang/hamler.git \</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a> &amp;&amp; git fetch origin $HAMLER_REVISION \</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a> &amp;&amp; git reset --hard FETCH_HEAD</span></code></pre></div>
<p><code>HAMLER_REVISION</code> は外部から与える：</p>
<pre><code>$ cat hamler_revision
#!/bin/bash
grep -A1 &#39;github: hamler-lang/hamler&#39; stack.yaml | grep -woE &quot;[0-9a-f]+&quot;
$ docker build . --build-arg HAMLER_REVISION=`./hamler_revision`</code></pre>
<p>これでクローンまではできた． 次は <code>make</code> と <code>make install</code> の部分を再現する．</p>
<h3 id="hamlerのセットアップ">Hamlerのセットアップ</h3>
<p><code>make</code> は <code>make build</code> と <code>make foreign</code> を実行している． <code>make biuld</code> は <code>hamler</code> バイナリをビルドして <code>hamler build</code> を実行している． <code>make foreign</code> は Foreign 用の Erlang の実行ファイルを生成しているようだ．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">ARG</span> OTP_VERSION=22.3.4.1</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION} AS build</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="kw">WORKDIR</span> /work</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="co"># libtinfo5 は stack や hamler の実行に使う</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="kw">RUN</span> apt-get update &amp;&amp; apt-get install -y libtinfo5</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="co"># stack のインストール</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="kw">RUN</span> curl -sSL https://get.haskellstack.org/ | sh</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_REVISION</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="kw">RUN</span> mkdir hamler \</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a> &amp;&amp; cd hamler \</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a> &amp;&amp; git init \</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a> &amp;&amp; git remote add origin https://github.com/hamler-lang/hamler.git \</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a> &amp;&amp; git fetch origin $HAMLER_REVISION \</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a> &amp;&amp; git reset --hard FETCH_HEAD</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a><span class="kw">ENV</span> LC_ALL C.UTF-8</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a><span class="co"># local_bin_path でローカルからバイナリを渡す</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a><span class="kw">ARG</span> local_bin_path</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a><span class="kw">COPY</span> ${local_bin_path}/hamler /usr/local/bin/hamler</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a><span class="kw">ENV</span> PATH /usr/local/bin:$PATH</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a><span class="co"># ここから make の処理</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a><span class="kw">RUN</span> cd hamler \</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a> &amp;&amp; stack exec hamler build -- -l \</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a> &amp;&amp; make foreign</span></code></pre></div>
<p><code>make install</code> は <code>HAMLER_HOME</code> へ以下の4つをコピーしている：</p>
<ul>
<li><code>hamler</code> バイナリ</li>
<li>リポジトリにある <code>replsrv</code> という Erlang スクリプト</li>
<li><code>make foreign</code> で生成した Erlang バイナリ</li>
<li>標準ライブラリ（リポジトリの <code>lib</code> のやつ）</li>
</ul>
<p>これを <code>docker build</code> でもやる：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co"># 続きから</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a> &amp;&amp; make foreign</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_HOME=/usr/lib/hamler</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="kw">RUN</span> mkdir -p ${HAMLER_HOME}/bin \</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a> &amp;&amp; cp /usr/local/bin/hamler ${HAMLER_HOME}/bin/hamler \</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a> &amp;&amp; cp hamler/repl/replsrv ${HAMLER_HOME}/bin/replsrv \</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a> &amp;&amp; cp -r hamler/ebin  ${HAMLER_HOME} \</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a> &amp;&amp; cp -r hamler/lib  ${HAMLER_HOME}</span></code></pre></div>
<p>これで準備はほぼ整った． あとは実行用のイメージに必要なものだけをコピってくるだけ：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co"># 続きから</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION}</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_HOME=/usr/lib/hamler</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">WORKDIR</span> /work</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="kw">RUN</span> apt-get update &amp;&amp; apt-get install -y libtinfo5 \</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a> &amp;&amp; apt-get clean \</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a> &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="kw">COPY</span> --from=build ${HAMLER_HOME} ${HAMLER_HOME}</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="kw">ENV</span> LC_ALL C.UTF-8</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a><span class="kw">ENV</span> PATH ${HAMLER_HOME}/bin:$PATH</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a><span class="kw">ENTRYPOINT</span> [<span class="st">&quot;/usr/lib/hamler/bin/hamler&quot;</span>]</span></code></pre></div>
<h3 id="ghcをdlしない">GHCをDLしない</h3>
<p>現状だと <code>docker build</code> 毎に GHC をインストールしてきて結構時間がかかる． せっかくマルチステージビルドができるので，GHC も別のイメージからコピってくることにした．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">ARG</span> GHC_VERSION=8.6.5</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="kw">ARG</span> OTP_VERSION=22.3.4.1</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="kw">FROM</span> haskell:${GHC_VERSION} AS ghc</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION} AS build</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="kw">WORKDIR</span> /work</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="kw">RUN</span> apt-get update &amp;&amp; apt-get install -y libtinfo5</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="kw">ARG</span> GHC_VERSION</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_REVISION</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_HOME=/usr/lib/hamler</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a><span class="kw">RUN</span> mkdir hamler \</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a> <span class="co"># 割愛</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a> &amp;&amp; git reset --hard FETCH_HEAD</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a><span class="kw">ENV</span> LC_ALL C.UTF-8</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a><span class="co"># ついでに stack もとってくる</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a><span class="kw">COPY</span> --from=ghc /usr/local/bin/stack /usr/local/bin/stack</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a><span class="kw">COPY</span> --from=ghc /opt/ghc /opt/ghc</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a><span class="kw">ENV</span> LC_ALL C.UTF-8</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a><span class="kw">ARG</span> local_bin_path</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a><span class="kw">COPY</span> ${local_bin_path}/hamler /usr/local/bin/hamler</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a><span class="co"># GHC のパスも追加する</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a><span class="kw">ENV</span> PATH /usr/local/bin:/opt/ghc/${GHC_VERSION}/bin:$PATH</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a><span class="kw">RUN</span> cd hamler \</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a> <span class="co"># system-ghc フラグをつける</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a> &amp;&amp; stack exec --system-ghc hamler build -- -l \</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a> &amp;&amp; make foreign</span></code></pre></div>
<h3 id="動作確認">動作確認</h3>
<p>適当に Makefile を書いておく：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="dv">bin/hamler:</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>	stack --local-bin-path=./bin install hamler</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="dv">clean:</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>	rm bin/hamler</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="dv">image:</span><span class="dt"> bin/hamler</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>	docker build -t <span class="ch">${</span><span class="dt">tag</span><span class="ch">}</span> . --build-arg local_bin_path=./bin --build-arg HAMLER_REVISION=`./hamler_revision`</span></code></pre></div>
<p>あとは <code>make image tag=matsubara0507/hamler:dev</code> とかやるとイメージができる． こんな感じに使う．</p>
<pre><code>$ mkdir sample
$ cd sample
$ docker run -it --rm -w /work -v `pwd`:/work matsubara0507/hamler:dev init
$ docker run -it --rm -w /work -v `pwd`:/work matsubara0507/hamler:dev repl
Compiling JSON
Hamler REPL, version 0.2
Type :? for help

&gt; 1 + 1
2</code></pre>
<h3 id="バイナリがビルドできないケース">バイナリがビルドできないケース</h3>
<p><code>Makefile</code> の設定から <code>./bin/hamler</code> が残っている場合はバイナリのビルドをスキップする． なのでリビジョンを更新してビルドしなおしたいときは先に <code>make clean</code> して <code>./bin/hamler</code> を削除する． しかし，間違えてリビジョンを変えずに <code>make clean</code> をした場合，次のようなエラーが出る：</p>
<pre><code>$ make clean
rm bin/hamler
$ make bin/hamler
stack --docker --local-bin-path=./bin install hamler
Cabal file warning in/path/to/docker-hamler.cabal@0:0: A package using &#39;cabal-version: 1.12&#39; must use section syntax. See the Cabal user guide for details.
No latest package revision found for: hamler, dependency callstack: []</code></pre>
<p>どうやらこれは <a href="https://github.com/commercialhaskell/stack/issues/5258">Stack 側のバグっぽい</a>． リビジョンを更新する以外に，Pantry 側を削除するしかなさそうなのが痛い． 早く治りますように…</p>
<h2 id="おしまい">おしまい</h2>
<p>その３があるかどうかはわかりません．</p>
  </div>]]></summary>
</entry>
<entry>
    <title>Featherweight Go を読んでみた</title>
    <link href="https://matsubara0507.github.io/posts/2020-07-02-read-featherweight-go.html" />
    <id>https://matsubara0507.github.io/posts/2020-07-02-read-featherweight-go.html</id>
    <published>2020-07-02T00:00:00Z</published>
    <updated>2020-07-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>Go言語にジェネリクスを導入するために，その形式的な議論を研究した論文「<a href="https://arxiv.org/abs/2005.11710">Featherweight Go</a>」が6月頭に発表されました． せっかくなので（久々に）全訳をしながら丁寧に読んでみたので，それを簡単にまとめることにします．</p>
<p>可能な限りGo言語に馴染みのない人や，プログラミング言語の形式的な議論に馴染みのない人でも理解できるようにしてみます．</p>
<h4 id="注意">注意</h4>
<ul>
<li>僕は英語がとても苦手です（DeepLを駆使しても3週間かかりました）</li>
<li>僕はGoでアプリケーションを少し書いていますがコアについては全く詳しくありません</li>
<li>僕は言語の形式的な議論を院生時代にやってましたが卒業して数年経ちます</li>
</ul>
<p>なので間違ってる可能性も十分に考慮してください．</p>
<h2 id="tldr">TL;DR</h2>
<ul>
<li>Goにジェネリクスを導入する新しいデザインを提案：
<ul>
<li>インターフェースと型アサーションを駆使する方法</li>
</ul></li>
<li>新デザインを形式的に議論するために FG と FGG を定義
<ul>
<li>FG：Goの極めて小さいモデル</li>
<li>FGG：FG をジェネリクスで拡張</li>
</ul></li>
<li>単相化（Monomorphisation）というFGGからFGの変換を定義
<ul>
<li>単相化は型パラメーターを具体化した実装を必要な型だけ完全に列挙する方法</li>
</ul></li>
<li><a href="https://github.com/rhu1/fgg">これらは全てGoでプロトタイプ実装した</a></li>
</ul>
<p>加えて，この Go のジェネリクスは Expression Problem の解法にもなり得るという議論もある．</p>
<h2 id="前提知識">前提知識</h2>
<h3 id="featherweight-java">Featherweight Java</h3>
<p>1999年に出された論文に「<a href="https://dl.acm.org/doi/abs/10.1145/320385.320395">Featherweight Java</a>」というものがある． 僕はこの論文を読んではいないがどうやら，この論文も FJ という Java の小さな言語モデルを定義し，それをジェネリクスで拡張した FGJ を定義し，FGJ から FJ への変換の仕方を定義して形式的な議論を与えている．</p>
<p>Featherweight Go でも言及されているとおり，Featherweight Go は議論の展開の仕方に Featherweight Java を参考としている．</p>
<h3 id="goの型">Goの型</h3>
<p>Goで型と呼べるものは大きく分けて2つ，構造体（structure）とインターフェース（interface）がある：</p>
<ul>
<li>構造体：
<ul>
<li><code>type [name] structure { ... }</code> という形で宣言</li>
<li><code>...</code> にフィールド名と型を列挙（いわゆるレコード型）</li>
<li>フィールドアクセスはドット記法（e.g. <code>x.m()</code>）</li>
</ul></li>
<li>インターフェース：
<ul>
<li><code>type [name] interface { ... }</code> という形で宣言</li>
<li><code>...</code> にメソッド仕様（method specification，メソッド名 + 型）を列挙</li>
<li>列挙したメソッドを定義した型はインターフェースのサブタイプになる（いわゆる構造的部分型）</li>
</ul></li>
</ul>
<h3 id="型アサーション">型アサーション</h3>
<p>Goでの型キャストっぽい機能． インターフェースで指定されてる型からサブタイプへと変換する．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">type</span> Hoge <span class="kw">interface</span> { ... }</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">type</span> Fuga <span class="kw">struct</span> { ... }</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">// Fuga は Hoge を実装しているとする</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">func</span> piyo(x Hoge) *Fuga {  <span class="co">// *X はX型のポインタ型</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    y, ok := x.(Fuga)      <span class="co">// これが型アサーション</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="kw">if</span> !ok {               <span class="co">// 型アサーションに失敗したときに false を返す</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        <span class="kw">return</span> <span class="ot">nil</span>         <span class="co">// nil はポインタのゼロ値</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="kw">return</span> &amp;y</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>piyo</code> 関数は <code>Hoge</code> インターフェースを実装した型の値であれば，なんでも引数として与えることができる． 型アサーションの <code>ok</code> は省略することができ，その場合は型アサーションに失敗したときに実行時エラーとなる．</p>
<h3 id="用語と翻訳">用語と翻訳</h3>
<p>基本的に，この分野の入門書として名高い[要出典]「型システム入門（原題：Type and Programming Language，略して TaPL）」の訳し方を参考にする． TaPL には無い用語は次のように翻訳したが，Go ジェネリクスが市民権を得たときには別の翻訳が宛てがわれるかもしれない：</p>
<ul>
<li>Monomorphisation：単相化
<ul>
<li>Polymorphism（多相性）の対義語が Monomorphism（単相性）というらしい</li>
<li>Rust でも Monomorphization という用語を単相化と訳していた</li>
<li>（この表記の揺れはおそらくイギリス綴りかアメリカ綴りかの差？）</li>
</ul></li>
<li>Bound：境界
<ul>
<li>機能は Java の Bounded Types（境界型などと訳されている）に近い</li>
<li><a href="https://github.com/rust-lang-ja/the-rust-programming-language-ja/issues/153">Rust でも色々議論した結果 Bound を「境界」と訳した</a></li>
</ul></li>
</ul>
<p>また，プログラミング言語の形式的な議論で頻出する用語について簡単に解説する：</p>
<ul>
<li>構文（Syntax）:
<ul>
<li>ある言語においてプログラムの「正しい記述方法」を定義したもの</li>
<li>一般的に BNF（バッカス・ナウア記法）で定義する</li>
</ul></li>
<li>意味論（Semantics）:
<ul>
<li>ある言語においてプログラムが「どのように実行されるか」を定義したもの</li>
<li>いくつか定義の仕方があるがこの論文では簡約規則（操作的意味論）を利用している</li>
</ul></li>
<li>型付け規則（Typing Rule）:
<ul>
<li>式 <span class="math inline"><em>e</em></span> に対して「正しい」型の付け方の規則</li>
<li>正しく型付けされているとはつまり静的型検査が通るような状態</li>
<li>一般的に <span class="math inline"><em>Γ</em> ⊢ <em>e</em> : <em>t</em></span> とかく（<span class="math inline"><em>Γ</em></span> は環境で変数がなんの型なのかを保存している）</li>
</ul></li>
<li>簡約（Reduction）:
<ul>
<li>ある式 <span class="math inline"><em>e</em></span> から別の式（値）への変換</li>
<li>一般的に <span class="math inline"><em>e</em> → <em>e</em>′</span> のように矢印を使う</li>
<li>例: <span class="math inline">1 + 2 * 3 → 1 + 6 → 7</span></li>
</ul></li>
<li>型安全性（Safety）:
<ul>
<li>健全性（Soundness）とも呼ぶ</li>
<li>正しく型付けされた項は「おかしくなる」ことがないということ</li>
<li>「おかしくなる」の定義は言語モデルによって異なる（例：行き詰まり状態）</li>
<li>進行定理 + 保存定理 なのでこの2つを証明するのが一般的</li>
</ul></li>
<li>進行定理（Progress）:
<ul>
<li>正しく型付けされた項は行き詰まり状態では無い</li>
<li>行き詰まり状態：値でもないし簡約もできない状態</li>
</ul></li>
<li>保存定理（Preservation）:
<ul>
<li>正しく型付けされた項が評価できるならば，評価後の項も正しく型付けされる</li>
</ul></li>
<li>双模倣性（Bisimulation）:
<ul>
<li>並行モデルでよく出てくる性質（今回の中では最もマイナーな性質）</li>
<li>ざっくりいうと，2つのモデルが同じように振舞うという性質</li>
</ul></li>
</ul>
<h3 id="プログラミング言語の形式的な議論">プログラミング言語の形式的な議論</h3>
<p>なぜ，わざわざ形式的な議論（証明を与える）をするのか． TaPL の第19章「事例: Featherweight Java」にはこう書いてある：</p>
<blockquote>
<p>プログラミング言語のような現実世界の複雑な人工物を設計するには，形式的にモデル化することが大きな手助けとなる．形式モデルを使うと，設計のある側面を正確に説明したり，その性質を記述・証明したり，そこまでしないと見落としかねない問題に注意を向けたりできる．</p>
</blockquote>
<p>現に，Featherweight Go ではFGGがある「前提条件」のもとで必ず単相化できることを証明しており，その結果，実際のジェネリクス付きGoの「正しい」静的検査（コンパイル）を定義できた（この条件がないと，単相化が停止しない可能性がある）．</p>
<h3 id="expression-problem">Expression Problem</h3>
<p>今回は割愛する（ググって）が，本論文で提案するジェネリクス付きGoは Expression Problem に対する解法になっていると主張している（個人的には，あまり Go っぽい書き方じゃない気がするけど笑）．</p>
<h2 id="goで多相的な実装をする">Goで多相的な実装をする</h2>
<p>現状のGoでも多相的な実装をする方法がいくつかある． 今回目を付けたのが，インターフェースと型アサーションを使った方法だ．</p>
<p>例えば，高階関数を次のように表現できる：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">type</span> Any <span class="kw">interface</span> {}</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">type</span> Function <span class="kw">interface</span> {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    Apply(x Any) Any</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>}</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="co">// g(f(x)) を表現</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="kw">type</span> compose <span class="kw">struct</span> {</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    f Function</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    g Function</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>}</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="kw">func</span> (this compose) Apply(x Any) Any {</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>    <span class="kw">return</span> this.g.Apply(this.f.Apply(x))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>}</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span class="kw">type</span> incr <span class="kw">struct</span> { n <span class="dt">int</span> } <span class="co">// nだけインクリメントする</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a><span class="kw">func</span> (this incr) Apply(x Any) Any {</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>    <span class="kw">return</span> x.(<span class="dt">int</span>) + this.n</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>}</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a><span class="kw">type</span> pos <span class="kw">struct</span> {} <span class="co">// 正数なら真が返る</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a><span class="kw">func</span> (this pos) Apply(x Any) Any {</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>    <span class="kw">return</span> x.(<span class="dt">int</span>) &gt; <span class="dv">0</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>}</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a>    <span class="kw">var</span> f Function = compose{incr{-<span class="dv">5</span>}, pos{}}</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a>    <span class="kw">var</span> b <span class="dt">bool</span> = f.Apply(<span class="dv">3</span>).(<span class="dt">bool</span>) <span class="co">// false</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a>}</span></code></pre></div>
<p>このコードは，既存の Go としても完全に正しい． <code>Any</code> インターフェースは実装すべきメソッド仕様を一つも持たないので，全ての型が実装していることになる． 無論，本当は <code>int</code> や <code>bool</code> であるべきところが <code>Any</code> になっていたり，<code>Any</code> な型同士の区別が付かなくなっていたりする問題がある． だがしかし，それがコンパイル時に検査できるようになったらどうだろうか．新しいデザインがまさにそういう形式になっている．</p>
<h2 id="fg-と-fgg">FG と FGG</h2>
<p>論文では，それぞれの構文と型付け規則，簡約規則を定義し，構文的正しさの検証規則の定義と，保存定理と進行定理を証明している（すなわち型安全であることを示している）． ここでは2つの構文だけ紹介する．</p>
<h3 id="fgの構文">FGの構文</h3>
<p><span class="math inline"><em>x̄</em></span> のような上線付きの記法は，ある形式の項の「列」であることを示している． 例えば <span class="math inline"><em>x̄</em></span> の場合は <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ...<em>x</em><sub><em>n</em></sub></span> を意味している．</p>
<p><img src="/assets/read-featherweight-go/fg.jpg"></img></p>
<p>プログラム <span class="math inline"><em>P</em></span> は，Go の形式にならって定義されているが，論文中では諸々省略して <span class="math inline"><em>D̄</em> ⊳ <em>e</em></span> と記述することもある．</p>
<p>FG は極めてコンパクトな Go のサブセットである． そのため，有効な式は変数・メソッド呼び出し・構造体リテラル・フィールド選択・型アサーションの5つしかない． 対して型（構造体・インターフェース）に関する構文はかなり充実している．</p>
<h2 id="section"></h2>
<p>FG には他に型付け規則と簡約規則がある．特に型付け規則の一部である，構造的部分型を表現した規則 <span class="math inline"><em>t</em> &lt;  : <em>u</em></span> は重要だ：</p>
<ul>
<li><span class="math inline"><em>u</em></span> が構造体 <span class="math inline"><em>t</em><sub><em>S</em></sub></span> の場合は <span class="math inline"><em>t</em><sub><em>S</em></sub></span> 自信のみがサブタイプになる（i.e. <span class="math inline"><em>t</em><sub><em>S</em></sub> &lt;  : <em>t</em><sub><em>S</em></sub></span>）</li>
<li><span class="math inline"><em>u</em></span> がインターフェース <span class="math inline"><em>t</em><sub><em>I</em></sub></span> の場合は <span class="math inline"><em>m</em><em>e</em><em>t</em><em>h</em><em>o</em><em>d</em><em>s</em>(<em>t</em>) ⊇ <em>m</em><em>e</em><em>t</em><em>h</em><em>o</em><em>d</em><em>s</em>(<em>t</em><sub><em>I</em></sub>)</span> を満たすような <span class="math inline"><em>t</em></span> のみがサブタイプになる（i.e. <span class="math inline"><em>t</em><sub><em>S</em></sub> &lt;  : <em>t</em><sub><em>I</em></sub></span>）</li>
</ul>
<p>ここで <span class="math inline"><em>m</em><em>e</em><em>t</em><em>h</em><em>o</em><em>d</em><em>s</em>(<em>t</em>)</span> という補助関数は型 <span class="math inline"><em>t</em></span> に定義されているメソッドのメソッド仕様の集合である（重複しないという前提）． また，メソッド仕様の等価性には変数名は関係しない（つまり，メソッド名・引数の型・返り値の型が一致するかどうかをみる）． この部分型関係 <span class="math inline"> &lt; :</span> は，メソッド呼び出しや構造体リテラルの引数を適用する部分や，型アサーションの型付け規則で利用される．</p>
<h3 id="fggの構文">FGGの構文</h3>
<p>前述したとおり，FGG は FG をジェネリクスで拡張した言語である． なので下記の構文規則のうち，FG からの拡張に当たる部分を赤でハイライトしてある．</p>
<p><img src="/assets/read-featherweight-go/fgg.jpg"></img></p>
<p>最も大きな変更として型宣言とメソッド宣言（メソッドシグネチャ）が型引数 <span class="math inline"><em>Φ</em></span> も取りうるようになったことだ． この型引数がまさにジェネリクスである． 手っ取り早く具体的なコードを見てみよう． 下記のコードは「Goで多相的な実装をする」を FGG 風の記法で置き換えたものだ（風というのは <code>+</code> や <code>&gt;</code> や <code>int</code> や <code>bool</code> は FGG にはまだ無いため）：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">type</span> Any <span class="kw">interface</span> {}</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="kw">type</span> Function(<span class="kw">type</span> a Any, b Any) <span class="kw">interface</span> {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    Apply(x a) b</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>}</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="co">// g(f(x)) を表現</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="kw">type</span> compose(<span class="kw">type</span> a Any, b Any, c Any) <span class="kw">struct</span> {</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    f Function(a, b)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    g Function(b, c)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>}</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a><span class="kw">func</span> (this compose(<span class="kw">type</span> a Any, b Any, c Any)) Apply(x a) c {</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>    <span class="kw">return</span> this.g.Apply(this.f.Apply(x))</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>}</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a><span class="kw">type</span> incr <span class="kw">struct</span> { n <span class="dt">int</span> } <span class="co">// nだけインクリメントする</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a><span class="kw">func</span> (this incr) Apply(x <span class="dt">int</span>) <span class="dt">int</span> {</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>    <span class="kw">return</span> x + this.n</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>}</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a><span class="kw">type</span> pos <span class="kw">struct</span> {} <span class="co">// 正数なら真が返る</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a><span class="kw">func</span> (this pos) Apply(x <span class="dt">int</span>) <span class="dt">bool</span> {</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>    <span class="kw">return</span> x &gt; <span class="dv">0</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>}</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a>    <span class="kw">var</span> f Function(<span class="dt">int</span>, <span class="dt">bool</span>) = compose(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">bool</span>){incr{-<span class="dv">5</span>}, pos{}}</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a>    <span class="kw">var</span> b <span class="dt">bool</span> = f.Apply(<span class="dv">3</span>) <span class="co">// false</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a>}</span></code></pre></div>
<p>なんと，このコードには型アサーションが一切出てこない． また，高階関数を表現するインターフェースで，ちゃんと引数と戻り値の型を区別することができている．</p>
<p>構文の本質的な変更を見てみよう． インターフェースや構造体，メソッドの宣言に <code>(type a Any, b Any)</code> というのが出てくるようになった． これがまさに型引数 <span class="math inline"><em>Φ</em></span> や <span class="math inline"><em>Ψ</em></span> に当たる． <code>a</code> や <code>b</code> の型パラメーターの後に記述している <code>Any</code> は <strong>境界（bound）</strong> と呼び，自由にインターフェースを置くことができる． 構造体リテラルやメソッド呼び出しで型引数に型を適用する場合や，部分型関係が成り立つ場合（<code>Apply(x int) bool</code> の <code>int</code> や <code>bool</code> のこと）は，与えた型が境界のインターフェースのサブタイプになっている必要がある（今回の場合は <code>Any</code> なのでどんな型でも良いが）． ここで重要になるのが，型引数の型パラメーターのスコープである：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">// 型名やメソッド名の型パラメーターは内部のメソッドシグネチャで利用できる</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">type</span> List(<span class="kw">type</span> a Any) <span class="kw">interface</span> {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    Map(<span class="kw">type</span> b Any)(f Function(a, b)) List(b)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>}</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="co">// 型パラメーターを自身の境界で利用することもできる</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="kw">type</span> Eq(<span class="kw">type</span> a Eq(a)) <span class="kw">interface</span> {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    Equal(that a) <span class="dt">bool</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>インターフェースの型引数はメソッド仕様の型引数でも使うことはできるが，その逆はできない．</p>
<h2 id="単相化">単相化</h2>
<p>いよいよ FGG から FG への変換方法をみていく． 論文では，単相化の規則を形式的に定義し，単相化したコードは構文的正しさが保存されることと，双模倣性を証明した．ここでは形式的な議論を割愛する．</p>
<h3 id="単相化の例">単相化の例</h3>
<p>まずは例を見てみよう． 前述した FGG の <code>Function</code> などの例を「単相化」で FG に変換すると次のようになる．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">type</span> Top <span class="kw">struct</span> {}</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="kw">var</span> f Function&lt;<span class="dt">int</span>, <span class="dt">bool</span>&gt; = compose&lt;<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">bool</span>&gt;{incr{-<span class="dv">5</span>}, pos{}}</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="kw">var</span> b <span class="dt">bool</span> = f.Apply(<span class="dv">3</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>}</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span class="kw">type</span> compose&lt;<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">bool</span>&gt; <span class="kw">struct</span> {</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    f Function&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    g Function&lt;<span class="dt">int</span>, <span class="dt">bool</span>&gt;</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>}</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a><span class="kw">type</span> Function&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; <span class="kw">interface</span> {</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    Apply&lt;<span class="dv">0</span>&gt; Top</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>    Apply(x <span class="dt">int</span>) <span class="dt">int</span>    </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>}</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a><span class="kw">type</span> Function&lt;<span class="dt">int</span>, <span class="dt">bool</span>&gt; <span class="kw">interface</span> {</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>    Apply&lt;<span class="dv">1</span>&gt; Top</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>    Apply(x <span class="dt">int</span>) <span class="dt">bool</span>    </span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>}</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a><span class="kw">type</span> (this compose&lt;<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">bool</span>&gt;) Apply(x <span class="dt">int</span>) <span class="dt">bool</span> {</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>    <span class="kw">return</span> this.g.Apply(this.f.Apply(x))</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a>}</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true"></a><span class="kw">type</span> (this compose&lt;<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">bool</span>&gt;) Apply&lt;<span class="dv">1</span>&gt;() Top {</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true"></a>    <span class="kw">return</span> Top{}</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true"></a>}</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true"></a></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true"></a><span class="kw">type</span> incr <span class="kw">struct</span> { n <span class="dt">int</span> }</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true"></a><span class="kw">type</span> (this incr) Apply(x <span class="dt">int</span>) <span class="dt">int</span> {</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true"></a>    <span class="kw">return</span> x + this.n</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true"></a>}</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true"></a><span class="kw">func</span> (this incr) Apply&lt;<span class="dv">0</span>&gt;() Top {</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true"></a>    <span class="kw">return</span> Top{}</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true"></a>}</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true"></a><span class="kw">type</span> pos strcut {}</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true"></a></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true"></a><span class="kw">func</span> (this pos) Apply(x <span class="dt">int</span>) <span class="dt">bool</span> {</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true"></a>    <span class="kw">return</span> x &gt; <span class="dv">0</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true"></a>}</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true"></a><span class="kw">func</span> (this incr) Apply&lt;<span class="dv">1</span>&gt;() Top {</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true"></a>    <span class="kw">return</span> Top{}</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true"></a>}</span></code></pre></div>
<p>大きな変更箇所として，<code>Function&lt;int, int&gt;</code> のように <code>(,)</code> が <code>&lt;,&gt;</code> へ至る所でなっている． FGG のときの <code>(,)</code> は内部の型は個別の型として認識されていたが，<code>&lt;,&gt;</code> は <code>Function&lt;int, int&gt;</code> で一つの型となり内部の型は区別されない．</p>
<p>また，<code>Apply&lt;0&gt; Top</code> のようなメソッドやメソッド仕様が追加されている． これは，部分型関係を正しく解決するためのダミーメソッドだ． 全てのメソッド宣言に対してダミーメソッドは追加で宣言され，インターフェースの全てのメソッド仕様に対してダミーメソッドのメソッド仕様が追加される． メソッド仕様の数字（<code>&lt;0&gt;</code> とか <code>&lt;1&gt;</code> とか）はメソッドの引数の型と返り値の型に対して一意に定まる（そのため <code>compose</code> と <code>pos</code> の <code>Apply</code> メソッドの数字は同じになる）．</p>
<p>ちなみに <code>Top</code> 構造体はダミーメソッドのために追加された構造体だ．</p>
<h3 id="ダミーメソッドが有効な例">ダミーメソッドが有効な例</h3>
<p>さて，上記の例ではダミーメソッドの有効性がわからないので，もう一つ例を示す． 前にちょっとだけ出てきた <code>List</code> インターフェースの完全な例を示す． 下記は FGG でのコードだ．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">type</span> List(<span class="kw">type</span> a Any) <span class="kw">interface</span> {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    Map(<span class="kw">type</span> b Any)(f Function(a, b)) List(b)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>}</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">type</span> Nil(<span class="kw">type</span> a Any) <span class="kw">struct</span> {}</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="kw">type</span> Cons(<span class="kw">type</span> a Any) <span class="kw">struct</span> {</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    head a</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    tail List(a)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>}</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a><span class="kw">func</span> (xs Nil(<span class="kw">type</span> a Any)) Map(<span class="kw">type</span> b Any)(f Function(a,b)) List(b) {</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    <span class="kw">return</span> Nil(b){}</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>}</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a><span class="kw">func</span> (xs Cons(<span class="kw">type</span> a Any)) Map(<span class="kw">type</span> b Any)(f Function(a,b)) List(b) {</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    <span class="kw">return</span> Cons(b){f.Apply(xs.head), xs.tail.Map(b)(f)}</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>}</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>    <span class="kw">var</span> xs List(<span class="dt">int</span>) = Cons(<span class="dt">int</span>){<span class="dv">3</span>, Cons(<span class="dt">int</span>){<span class="dv">6</span>, Nil(<span class="dt">int</span>){}}}</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>    <span class="kw">var</span> ys List(<span class="dt">int</span>) = xs.Map(<span class="dt">int</span>)(incr{-<span class="dv">5</span>})</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>    <span class="kw">var</span> _ List(<span class="dt">bool</span>) = ys.Map(<span class="dt">bool</span>)(pos{})</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>List</code> インターフェースは，配列のようなコンテナ型の各要素に同じメソッドを適用する高階関数を提供する． <code>Nil</code> と <code>Cons</code> 構造体は線形リストを表したものだ． ちなみに，Go の構造体は構造体による再帰的な構造を宣言することはできないが，インターフェースを介する場合は可能だ．</p>
<p>さて，これを単相化すると次のようになる．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="kw">var</span> xs List&lt;<span class="dt">int</span>&gt; = Cons&lt;<span class="dt">int</span>&gt;{<span class="dv">3</span>, Cons&lt;<span class="dt">int</span>&gt;{<span class="dv">6</span>, Nil&lt;<span class="dt">int</span>&gt;}}</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">var</span> ys List&lt;<span class="dt">int</span>&gt; = xs.Map&lt;<span class="dt">int</span>&gt;(incr{-<span class="dv">5</span>})</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="kw">var</span> _ List&lt;<span class="dt">bool</span>&gt; = ys.Map&lt;<span class="dt">bool</span>&gt;(pos{})</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>}</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="kw">type</span> List&lt;<span class="dt">int</span>&gt; <span class="kw">interface</span> {</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    Map&lt;<span class="dv">2</span>&gt;() Top <span class="co">// これは `(f Function(int, b)) List(b)` からの数字</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>    Map&lt;<span class="dt">int</span>&gt;(f Function&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;) List&lt;<span class="dt">int</span>&gt;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    Map&lt;<span class="dt">bool</span>&gt;(f Function&lt;<span class="dt">int</span>,<span class="dt">bool</span>&gt;) List&lt;<span class="dt">bool</span>&gt;</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>}</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="kw">type</span> Nil&lt;<span class="dt">int</span>&gt; <span class="kw">struct</span> {}</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a><span class="kw">func</span> (xs Nil&lt;<span class="dt">int</span>&gt;) Map&lt;<span class="dt">int</span>&gt;(f Function&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;) List&lt;<span class="dt">int</span>&gt; {</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>    <span class="kw">return</span> Nil&lt;<span class="dt">int</span>&gt;{}</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>}</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a><span class="kw">func</span> (xs Nil&lt;<span class="dt">int</span>&gt;) Map&lt;<span class="dt">bool</span>&gt;(f Function&lt;<span class="dt">int</span>,<span class="dt">bool</span>&gt;) List&lt;<span class="dt">bool</span>&gt; {</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>    <span class="kw">return</span> Nil&lt;<span class="dt">bool</span>&gt;{}</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>}</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a><span class="kw">func</span> (xs Nil&lt;<span class="dt">int</span>&gt;) Map&lt;<span class="dv">2</span>&gt;() Top {</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>    <span class="kw">return</span> Top{}</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>}</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a><span class="kw">type</span> Cons&lt;<span class="dt">int</span>&gt; <span class="kw">struct</span> {</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>    head <span class="dt">int</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>    tail List&lt;<span class="dt">int</span>&gt;</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>}</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a><span class="kw">func</span> (xs Cons&lt;<span class="dt">int</span>&gt;) Map&lt;<span class="dt">int</span>&gt;(f Function&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;) List&lt;<span class="dt">int</span>&gt; {</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>    <span class="kw">return</span> Cons&lt;<span class="dt">int</span>&gt;{f.Apply(xs.head), xs.tail.Map&lt;<span class="dt">int</span>&gt;(f)}</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a>}</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a><span class="kw">func</span> (xs Cons&lt;<span class="dt">int</span>&gt;) Map&lt;<span class="dt">bool</span>&gt;(f Function&lt;<span class="dt">int</span>,<span class="dt">bool</span>&gt;) List&lt;<span class="dt">bool</span>&gt; {</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a>    <span class="kw">return</span> Cons&lt;<span class="dt">bool</span>&gt;{f.Apply(xs.head), xs.tail.Map&lt;<span class="dt">bool</span>&gt;(f)}</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a>}</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a><span class="kw">func</span> (xs Cons&lt;<span class="dt">int</span>&gt;) Map&lt;<span class="dv">2</span>&gt;() Top {</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true"></a>    <span class="kw">return</span> Top{}</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true"></a>}</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true"></a><span class="kw">type</span> List&lt;<span class="dt">bool</span>&gt; <span class="kw">interface</span> {</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true"></a>    Map&lt;<span class="dv">3</span>&gt;() Top</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true"></a>}</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true"></a><span class="kw">type</span> Nil&lt;<span class="dt">bool</span>&gt; <span class="kw">struct</span> {}</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true"></a><span class="kw">func</span> (xs Nil&lt;<span class="dt">bool</span>&gt;) Map&lt;<span class="dv">3</span>&gt;() Top {</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true"></a>    <span class="kw">return</span> Top{}</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true"></a>}</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true"></a></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true"></a><span class="kw">type</span> Cons&lt;<span class="dt">bool</span>&gt; <span class="kw">struct</span> {</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true"></a>    head <span class="dt">bool</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true"></a>    tail List&lt;<span class="dt">bool</span>&gt;</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true"></a>}</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true"></a><span class="kw">func</span> (xs Cons&lt;<span class="dt">bool</span>&gt;) Map&lt;<span class="dv">3</span>&gt;() Top {</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true"></a>    <span class="kw">return</span> Top{}</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>List&lt;int&gt;</code> の <code>Map</code> メソッドは <code>main</code> のところで <code>int -&gt; int</code> と <code>int -&gt; bool</code> の2パターンで使われていたため，2つもインターフェースのメソッドとして宣言されている． 対して <code>List&lt;bool&gt;</code> は <code>ys.Map&lt;bool&gt;(pos{})</code> で生成されるものの，<code>Map</code> メソッドを呼んでいないため，インターフェースのメソッドは1つもない． このようにインターフェースのメソッドは，実際に利用された型のものしか生成されない． これにより，メソッドの無いインターフェースが生成されることがある（正確にはダミーメソッド以外には無い，だが）． ダミーメソッドはこのような振る舞いに対して有効だ．例えば，変数 <code>f</code> に <code>incr{1}</code> が束縛されているときを考える． 型アサーション <code>f.(List&lt;bool&gt;)</code> はダミーメソッドがあることで失敗するが，ダミーメソッドがないと成功してしまう．</p>
<h3 id="単相化ができない場合">単相化ができない場合</h3>
<p>全ての型付け可能な FGG のコードが単相化可能かというとそうではない． 例えば，次のような FGG のコードは単相化できない．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">type</span> Box(<span class="kw">type</span> a Any) <span class="kw">struct</span> {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    value a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>}</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="kw">func</span> (this Box(<span class="kw">type</span> a Any)) Nest(n <span class="dt">int</span>) Any {</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="kw">if</span> (n == <span class="dv">0</span>) {</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>        <span class="kw">return</span> this</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    } <span class="kw">else</span> {</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>        <span class="kw">return</span> Box(Box(a)){this}.Nest(n<span class="dv">-1</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    }</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>}</span></code></pre></div>
<p>これは多相再帰（polymorphic recursion），ある型で呼び出されたメソッドが別の型で再帰呼び出しをするもの，をしているプログラムの例である．<code>Box(a)</code> 型をレシーバーとするメソッド <code>Nest</code> を呼び出すと <code>Box(Box(a))</code> 型のレシーバーで再帰的に呼び出される． この例は型がどれだけ深くネストするかを事前に決定することができないので単相化することができない．</p>
<p>逆に，このような多相再帰なコードが含まれていない場合は，全ての FGG のコードを単相化することができる（ことを論文で証明していた）． なので，実際のコンパイラでは多相再帰が含まれてるかどうかの検査をするようだ．</p>
<h3 id="単相化の仕組み">単相化の仕組み</h3>
<p>単相化のプロセスは2つのフェーズから構成されている． 第一フェーズは，FGG プログラムから型とメソッドのインスタンス（型パラメーターを具体化したものだと思う）を取集する． 第二フェーズでは，第一フェーズで収集したインスタンスをもとにして，FGG プログラムを等価な FG プログラムへと変換する．</p>
<p>FGG のプログラム <span class="math inline"><em>P</em></span> から，各インスタンスの集合 <span class="math inline"><em>Ω</em></span> を収集した場合は <span class="math inline"><em>P</em> ▸ <em>Ω</em></span> と記述する（これが第一フェーズ）．FGG のプログラム <span class="math inline"><em>P</em></span> から FG のプログラム <span class="math inline"><em>P</em>′</span> への変換は <span class="math inline"> ⊢ <em>P</em> ↦ <em>P</em>′</span> と記述する．</p>
<p>論文ではこれらの規則を形式的に定義している（がここでは割愛）．</p>
<h3 id="他言語と単相化">他言語と単相化</h3>
<p>7章の「RELATED WORK」では，他のプログラミング言語での単相化の事例について紹介されていた．興味深いので論文から引用する．</p>
<ul>
<li>Bracha 氏らは「Making the Future Safe for the Past: Adding Genericity to the Java Programming Language」という論文でジェネリクス付きの Java からジェネリクスなしの Java へ，全ての型パラメーターの情報を消去することで変換する方法を提案した（これは単相化では無い）．消去の欠点として消去されたコードは単相化されたコードに比べて（実行？）効率が悪くなることがよくある．一方，消去はコードサイズの増加が線形であるのに対して，単相化はコードサイズが爆発的に増加する可能性がある．</li>
<li>Kennedy 氏と Syme 氏は「Design and Implementation of Generics for the .NET Common Language Runtime」で .NET Common Language Runtime (CLR) と C# の拡張を開発してジェネリクスをサポートした．これらは特化したコードと共有したコードを混ぜたものを生成する．前者は，各プリミティブ型ごとに個別にコンパイルする（これは単相化に似ている）．後者は，全てのオブジェクト型に対してひとつにコンパイルされる（これは消去に似ている）．</li>
<li>Stroustrup 氏は「The C++ Programming Language」という書籍の16章で，C++ におけるテンプレートのインスタンス化について述べている（実質，単相化）．これは広く使われているがコードが肥大化するとして悪名高い．</li>
<li>Benton 氏らは「Compiling Standard ML to Java Bytecodes」という論文で SML’97 プログラムから Java バイトコードへ変換するコンパイラについて述べており，ここで多相性は完全に単相化される．Standard ML では多相的な再帰を禁止しているため，常に単相化することが可能．</li>
<li>Fluet 氏は <a href="http://mlton.org/Monomorphise">MLton のウェブページ</a>で，SML の最適化コンパイラ MLton で利用している同様のアプローチを紹介している．</li>
<li>Tolmach 氏と Oliva 氏は「From ML to Ada: Strongly-Typed Language Interoperability via Source Translation」という論文で，MLライクな言語から Agda への型付きの変換を単相化ベースで開発し，その詳細を発表した．FGGのとは異なりサブタイピングに対応しておらず多相再帰もない．</li>
<li>Jones 氏は「Dictionary-free overloading by partial evaluation」という論文で，Haskell用の型クラスを効率的にコンパイルする方法について述べており，これは単相化に多少似ている．</li>
<li>Yu 氏らは「Formalization of generics for the .NET common language runtime」で，.NET JIT コンパイラの特化と共有を混ぜるメカニズムの形式化している．この論文では，型と意味論を保持した多相的な .NET の中間言語（IL）への変換を記述している．</li>
<li>Siek 氏と Taha 氏は「A Semantic Analysis of C++ Templates」という論文で，C++テンプレートのインスタンス化メカニズムを形式化している．</li>
<li>田中氏らは「Safe Low-level Code Generation in Coq Using Monomorphization and Monadification」という論文で，低レベルのCコードを生成する Coq (Gallina) のための単相化アルゴリズムをレポートしている．</li>
</ul>
<h2 id="実装について">実装について</h2>
<ul>
<li>FGとFGGの型検査器とインタプリタ</li>
<li>FGG から FG への変換器（monomorphiser）のプロトタイプ実装（単相化可能かの検査も含む）</li>
</ul>
<p>を Go で実装して公開したそうだ． Go で実装したのは Go の設計者やコミュニティとの議論を容易にするためらしい． さらに，これらの実装を使い多くのテストを行ったようだ．</p>
<ul>
<li>FG の評価結果を公式の Go コンパイラを使用したものと比較</li>
<li>FG と FGG インタプリタは保存定理と進行定理の動的な検査をサポート</li>
<li>単相化をテストするために双模倣性のテストを追加</li>
</ul>
<p>また，<a href="https://doi.org/10.1017/s0956796815000143">NEAT</a> を利用して FGG のサブセットから全ての正しく型付けされたプログラム（ただし，メソッドと型の出現巣の合計を指定して，ある程度のサイズまでに限定した上で）を列挙もしたらしい（SmallCheck に似ているらしい）． このサブセットに含まれる全ての FGG プログラムをサイズ20まで生成して，上述した双模倣性のテストが通ったことを確認したそうだ．</p>
<h2 id="おしまい">おしまい</h2>
<p>今後は C# のような，型のランタイム表現を渡すことに基づいた実装を検討して，単相化と組み合わせる方法を模索するらしい． あと，代入・配列・スライス・パッケージなどの他の重要な機能のモデル化も計画してるらしく，これを Bantamweight Go と呼ぶつもりらしい． さらに，「goroutines」とメッセージパッシングに基づくGoの並行メカニズムのモデル化も計画していて，これを Cruiserweight Go と呼ぶらしい． いったい素の Go は何級なんだろう笑</p>
  </div>]]></summary>
</entry>
<entry>
    <title>Hamler の Docker イメージを作る</title>
    <link href="https://matsubara0507.github.io/posts/2020-06-13-build-docker-image-for-hamler.html" />
    <id>https://matsubara0507.github.io/posts/2020-06-13-build-docker-image-for-hamler.html</id>
    <published>2020-06-13T00:00:00Z</published>
    <updated>2020-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p><a href="https://www.hamler-lang.org/">Hamler</a> という ErlangVM 上で動作する Haskell に似た構文のプログラミング言語が公開された． 手元で遊ぶためにまず，Docker イメージを作ってみることにした（brew したくなかった）． <a href="https://hub.docker.com/repository/docker/matsubara0507/hamler">作成したイメージはココ</a>で<a href="https://github.com/matsubara0507/docker-hamler">リポジトリはココ</a>．</p>
<p>ちなみに，今回利用するバージョンは <code>0.1</code> です．</p>
<h2 id="docker-イメージを作る">Docker イメージを作る</h2>
<p><a href="https://github.com/erlang/docker-erlang-otp/blob/ed3bd9400e1b72b2bdd08596990f8ed3350a75c0/22/Dockerfile#L1">公式の Erlang の Docker イメージは Debian</a> なので，Debian の Docker イメージを作る． 現状は Mac 用のバイナリしか提供されていないので自前でビルドする必要がある． 自前でビルドする方法は<a href="https://github.com/hamler-lang/hamler/tree/2ed8e6088721471a4dd7993eb6a984fb7ce66a73#installation">公式ドキュメント</a>によると次の通り：</p>
<ol type="1">
<li>Erlang インストール</li>
<li>Haskell Stack をインストール</li>
<li>hamler-lang/hamler リポジトリをクローン</li>
<li>リポジトリで <code>make &amp;&amp; make install</code></li>
</ol>
<p>幸いにも，Hamler は Haskell Stack でビルドできるので簡単だ．</p>
<h3 id="コンパイラをビルドする">コンパイラをビルドする</h3>
<p>まずは Stack をインストールしよう：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co"># マルチステージビルドをするので AS でタグづけしておく</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">ARG</span> OTP_VERSION=22.3.4.1</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION} AS build</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">WORKDIR</span> /work</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="kw">RUN</span> curl -sSL https://get.haskellstack.org/ | sh</span></code></pre></div>
<p>次にリポジトリを <code>git clone</code> してビルドする：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_VERSION=0.1</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">RUN</span> git clone --branch=v$HAMLER_VERSION --depth=1 https://github.com/hamler-lang/hamler.git</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">RUN</span> cd hamler &amp;&amp; make &amp;&amp; make install</span></code></pre></div>
<p>で，<code>make</code> というか中身は <code>stack build</code> のところで次のようなエラーが出た：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ex">Package</span> index cache populated</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="ex">Cloning</span> afb0b731ff457d278403ab4bc134d3c88e09ea1f from git@github.com:hamler-lang/CoreErlang.git</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="ex">Received</span> ExitFailure 128 when running</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ex">Raw</span> command: /usr/bin/git clone git@github.com:hamler-lang/CoreErlang.git /tmp/with-repo10/cloned</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="ex">Standard</span> error:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="ex">Cloning</span> into <span class="st">&#39;/tmp/with-repo10/cloned&#39;</span>...</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="ex">Host</span> key verification failed.</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="ex">fatal</span>: Could not read from remote repository.</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="ex">Please</span> make sure you have the correct access rights</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a><span class="ex">and</span> the repository exists.</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a><span class="ex">make</span>: *** [Makefile:9: build] Error 1</span></code></pre></div>
<p>これは stack.yaml の <code>extra-deps</code> で次のように指定していたからだ：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">git</span><span class="kw">:</span><span class="at"> git@github.com:hamler-lang/CoreErlang.git</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="at">  </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> afb0b731ff457d278403ab4bc134d3c88e09ea1f</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">git</span><span class="kw">:</span><span class="at"> git@github.com:hamler-lang/purescript.git</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="at">  </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> 2c43709229b12e72dfc550ccf3efce6bfa60da72</span></span></code></pre></div>
<p><code>git@github.com:owner/repo.git</code> という形で指定すると SSH を利用した方法で <code>git clone</code> をするのだが，この Docker 環境では SSH の設定をしていないのでエラーになる． なので，次のように書き換えてあげれば良い：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">github</span><span class="kw">:</span><span class="at"> hamler-lang/CoreErlang</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="at">  </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> afb0b731ff457d278403ab4bc134d3c88e09ea1f</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">github</span><span class="kw">:</span><span class="at"> hamler-lang/purescript</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="at">  </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> 2c43709229b12e72dfc550ccf3efce6bfa60da72</span></span></code></pre></div>
<p>このように修正した <code>stack.yaml</code> を用意して上書きすることにした：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_VERSION=0.1</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">RUN</span> git clone --branch=v$HAMLER_VERSION --depth=1 https://github.com/hamler-lang/hamler.git</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">COPY</span> stack.yaml hamler/stack.yaml</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="kw">RUN</span> cd hamler &amp;&amp; make &amp;&amp; make install</span></code></pre></div>
<p>余談だが，これについては<a href="https://github.com/hamler-lang/hamler/pull/157">修正PRを出してマージされた</a>ので次のバージョンからは必要ない． で，今度は次のようなエラーが出た：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ex">language-javascript</span>              <span class="op">&gt;</span> configure</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ex">language-javascript</span>              <span class="op">&gt;</span> Configuring language-javascript-0.7.0.0...</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="ex">language-javascript</span>              <span class="op">&gt;</span> build</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="ex">language-javascript</span>              <span class="op">&gt;</span> Preprocessing library for language-javascript-0.7.0.0..</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="ex">language-javascript</span>              <span class="op">&gt;</span> happy: src/Language/JavaScript/Parser/Grammar7.y: hGetContents: invalid argument (invalid byte sequence)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="ex">--</span>  While building package language-javascript-0.7.0.0 using:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>      <span class="ex">/root/.stack/setup-exe-cache/x86_64-linux-tinfo6/Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5</span> --builddir=.stack-work/dist/x86_64-linux-tinfo6/Cabal-2.4.0.1 build --ghc-options <span class="st">&quot;&quot;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    <span class="ex">Process</span> exited with code: ExitFailure 1</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="ex">make</span>: *** [Makefile:9: build] Error 1</span></code></pre></div>
<p>はい，親の顔よりも見る <code>hGetContents: invalid argument (invalid byte sequence)</code> ですね． language-javascript パッケージは UTF-8 前提なので <code>LC_ALL</code> 環境変数を UTF-8 にしてあげる必要がある：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">ARG</span> HAMLER_VERSION=0.1</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="kw">RUN</span> git clone --branch=v$HAMLER_VERSION --depth=1 https://github.com/hamler-lang/hamler.git</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="kw">COPY</span> stack.yaml hamler/stack.yaml</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="kw">ENV</span> LC_ALL C.UTF-8</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="kw">RUN</span> cd hamler &amp;&amp; make &amp;&amp; make install</span></code></pre></div>
<p>これでコンパイラのビルドは成功した！</p>
<h3 id="replを試すまで">REPLを試すまで</h3>
<p>マルチステージビルドなのでビルドしたコンパイラを次のステージにコピーしよう：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION}</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="kw">COPY</span> --from=build /root/.local/bin/hamler /usr/local/bin/hamler</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="kw">ENTRYPOINT</span> [<span class="st">&quot;/usr/local/bin/hamler&quot;</span>]</span></code></pre></div>
<p>試しに <code>--help</code> をしてみる：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>$ <span class="ex">docker</span> run --rm matsubara0507/hamler --help</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="ex">Usage</span>: hamler COMMAND</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  <span class="ex">The</span> hamler compiler based on purescript v0.13.6</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="ex">Available</span> options:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>  <span class="ex">--version</span>                Show the version number</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  <span class="ex">-h</span>,--help                Show this help text</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="ex">Available</span> commands:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>  <span class="ex">build</span>                    Compile hamler source files</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>  <span class="ex">init</span>                     init a hamler project</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>  <span class="ex">run</span>                      run hamler project</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>  <span class="ex">repldev</span>                  dev hamler lib</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>  <span class="ex">repl</span>                     run hamler repl</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a><span class="ex">For</span> help using each individual command, run <span class="kw">`</span><span class="ex">hamler</span> COMMAND --help<span class="kw">`</span>. For</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a><span class="ex">example</span>, <span class="kw">`</span><span class="ex">hamler</span> build --help<span class="kw">`</span> displays options specific to the <span class="kw">`</span><span class="ex">build</span><span class="kw">`</span> command.</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a><span class="ex">hamler</span> 0.1</span></code></pre></div>
<p>動作確認するために REPL を試してみる：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>$ <span class="ex">docker</span> run -it --rm matsubara0507/hamler repl</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="ex">hamler</span>: //src: getDirectoryContents:openDirStream: does not exist (No such file or directory)</span></code></pre></div>
<p>グローバルな環境で REPL は使えないっぽいのでプロジェクトを作成してみる：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>$ <span class="ex">docker</span> run --rm -w /work -v <span class="kw">`</span><span class="bu">pwd</span><span class="kw">`</span>/example:/work matsubara0507/hamler init</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>$ <span class="ex">docker</span> run -it --rm -w /work -v <span class="kw">`</span><span class="bu">pwd</span><span class="kw">`</span>/example:/work matsubara0507/hamler repl</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="ex">hamler</span>: /usr/local/lib/hamler/lib: getDirectoryContents:openDirStream: does not exist (No such file or directory)</span></code></pre></div>
<p><code>/usr/local/lib/hamler/lib</code> ？？？ いったいこれはどこで参照してるやつだ？？？と思ってリポジトリで色々調べてみたところ，どうやら標準ライブラリかなんかを参照してるっぽい． バグかな？って思ったけど <a href="https://github.com/hamler-lang/homebrew-hamler/blob/0.1/Formula/hamler.rb#L38-L40"><code>brew</code> の設定</a>をみてみたらリポジトリっぽいのを <code>/usr/local/lib/hamler</code> にシンボリックリンクしてるようだった． なので，試しにそうしてみる：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION}</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="kw">COPY</span> --from=build /root/.local/bin/hamler /usr/local/bin/hamler</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="kw">COPY</span> --from=build /work/hamler /usr/local/lib/hamler</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="kw">ENTRYPOINT</span> [<span class="st">&quot;/usr/local/bin/hamler&quot;</span>]</span></code></pre></div>
<p>今度はこういうエラーが出た：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>$ docker run -it --rm -w /work -v `pwd`/example:/work matsubara0507/hamler repl</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="st">&quot;/work&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>hamler: /usr/local/lib/hamler/bin/replsrv: start replsrv error!! : runInteractiveProcess: exec: does not exist (No such file or directory)</span></code></pre></div>
<p><code>bin/replsrv</code> ？？？ <code>brew</code> でインストールしてる tgz の中身をみてみたら <code>bin</code> ディレクトリがあり，そこには <code>replsrv</code> と <code>hamler</code> というファイルがあった． <code>hamler</code> はコンパイラのバイナリで，<code>replsrv</code> は Erlang のスクリプトだった． 探してみたら <code>repl/replsrv</code> という Erlang スクリプトがリポジトリにあり，<code>diff</code> してみたら tgz のものと一緒だった． なのでこれをコピーするようにした：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">FROM</span> erlang:${OTP_VERSION}</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="kw">COPY</span> --from=build /root/.local/bin/hamler /usr/local/bin/hamler</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="kw">COPY</span> --from=build /work/hamler /usr/local/lib/hamler</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="kw">RUN</span> mkdir /usr/local/lib/hamler/bin \</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a> &amp;&amp; cp /usr/local/lib/hamler/repl/replsrv /usr/local/lib/hamler/bin</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a><span class="kw">ENTRYPOINT</span> [<span class="st">&quot;/usr/local/bin/hamler&quot;</span>]</span></code></pre></div>
<p>なんとこれで REPL が動作した：</p>
<pre><code>$ docker run -it --rm -w /work -v `pwd`/example:/work matsubara0507/hamler repl
&quot;/work&quot;
Compiling Data.Void
...
Compiling Main
Compiling Demo.GenServer
PSCi, version 0.13.6
Type :? for help

&gt; :?
The following commands are available:

    :?                        Show this help menu
    :quit                     Quit PSCi
    :reload                   Reload all imported modules while discarding bindings
    :clear                    Discard all imported modules and declared bindings
    :browse      &lt;module&gt;     See all functions in &lt;module&gt;
    :type        &lt;expr&gt;       Show the type of &lt;expr&gt;
    :kind        &lt;type&gt;       Show the kind of &lt;type&gt;
    :show        import       Show all imported modules
    :show        loaded       Show all loaded modules
    :show        print        Show the repl&#39;s current printing function
    :paste       paste        Enter multiple lines, terminated by ^D
    :complete    &lt;prefix&gt;     Show completions for &lt;prefix&gt; as if pressing tab
    :print       &lt;fn&gt;         Set the repl&#39;s printing function to &lt;fn&gt; (which must be fully qualified)
    :set         pro val      Set the pro&#39;s val

Further information is available on the PureScript documentation repository:
 --&gt; https://github.com/purescript/documentation/blob/master/guides/PSCi.md
&gt; 1 + 1
2
&gt; :type 1
Integer</code></pre>
<p>やったね．</p>
<h2 id="おまけサンプルプログラム">おまけ：サンプルプログラム</h2>
<p><a href="https://github.com/hamler-lang/documentation/blob/60607565253a2b6fa3984067cf068c20ec971d69/guides/01_WhyHamler.md#erlang-and-concurrency">ここにあるサンプルプログラム</a>をビルドして実行してみた：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="co">-- `hamler run` は Main.main 関数を実行するみたい</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  <span class="co">-- メインプロセスのプロセスIDを取得</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  pid0 <span class="ot">&lt;-</span> selfPid</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  <span class="co">-- `spawn` は子プロセスの生成、`seqio` は IO 専用の `sequence`</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  pid100 <span class="ot">&lt;-</span> seqio [spawn loop (<span class="dt">State</span> pid0) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">1000</span>]]</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  <span class="co">-- `last` はリストの最後の要素を、`init` はリストの最後以外の部分リストを返す</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  <span class="co">-- `[x|xs]` は Haskell の `x:xs`、つまりリストの中身を1つずらしてる</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  <span class="co">-- `send` は指定したプロセスにメッセージを送信する</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>  seqio [send j (<span class="dt">Next</span> i) <span class="op">|</span> (i,j) <span class="ot">&lt;-</span> (<span class="fu">zip</span> pid100 [<span class="fu">last</span> pid100<span class="op">|</span><span class="fu">init</span> pid100]) ]</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>  send (<span class="fu">head</span> pid100) (<span class="dt">Trans</span> <span class="st">&quot;great hamler! &quot;</span> <span class="dv">0</span>)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>  <span class="fu">return</span> ()</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Message</span> <span class="ot">=</span> <span class="dt">Next</span> <span class="dt">Pid</span> <span class="op">|</span> <span class="dt">Trans</span> <span class="dt">String</span> <span class="dt">Integer</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">State</span> <span class="dt">Pid</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a><span class="ot">dealMessage ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span>  <span class="dt">Message</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">State</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a>dealMessage (<span class="dt">State</span> pid) (<span class="dt">Next</span> p) <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">State</span> p)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a>dealMessage (<span class="dt">State</span> pid) (<span class="dt">Trans</span> str <span class="dv">11111</span>) <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">State</span> pid)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true"></a>dealMessage (<span class="dt">State</span> pid) (<span class="dt">Trans</span> str i) <span class="ot">=</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true"></a>  <span class="kw">do</span> send pid (<span class="dt">Trans</span> str (i<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true"></a>     pid0 <span class="ot">&lt;-</span> selfPid</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true"></a>     println (<span class="fu">show</span> pid0 <span class="op">&lt;&gt;</span> <span class="st">&quot; -&gt; &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> pid <span class="op">&lt;&gt;</span> <span class="st">&quot;: &quot;</span> <span class="op">&lt;&gt;</span> str <span class="op">&lt;&gt;</span> <span class="fu">show</span> i)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true"></a>     <span class="fu">return</span> (<span class="dt">State</span> pid)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true"></a></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true"></a><span class="ot">loop ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true"></a>loop s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true"></a>  <span class="co">-- `receive` は送信されたメッセージを受信する</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true"></a>  x <span class="ot">&lt;-</span> receive</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true"></a>  s1 <span class="ot">&lt;-</span> dealMessage s x</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true"></a>  loop s1</span></code></pre></div>
<p>Erlang についてはあんまり詳しくないんだが，確かいわゆるアクターモデル的な並行システムだった気がする． 各 Erlang プロセスはメッセージボックス的なのを持っていて，別プロセスから送信することができる． この型検査ってどれぐらいできるのだろうか． さすがに送信・受信の型があってるかまではチェックできなそう（調べてない）．</p>
<p>で，これをビルドした結果がこちら：</p>
<pre><code>$ docker run -it --rm -w /work -v `pwd`/example:/work matsubara0507/hamler build
Compiling Data.Void
...
Compiling Demo.GenServer
Compiling Main

$ docker run -it --rm -w /work -v `pwd`/example:/work matsubara0507/hamler run
&lt;0.749.0&gt; -&gt; &lt;0.750.0&gt;: great hamler! 672
&lt;0.80.0&gt; -&gt; &lt;0.81.0&gt;: great hamler! 3
&lt;0.81.0&gt; -&gt; &lt;0.82.0&gt;: great hamler! 4
&lt;0.82.0&gt; -&gt; &lt;0.83.0&gt;: great hamler! 5
...
&lt;0.791.0&gt; -&gt; &lt;0.792.0&gt;: great hamler! 7714
&lt;0.792.0&gt; -&gt; &lt;0.793.0&gt;: great hamler! 7715</code></pre>
<h2 id="おしまい">おしまい</h2>
<p>会社単位で作ってるみたい． すごいなぁ，羨ましい．</p>
  </div>]]></summary>
</entry>
<entry>
    <title>自分の Haskell プロジェクトの依存パッケージの古さを可視化する（その１）</title>
    <link href="https://matsubara0507.github.io/posts/2020-05-31-create-deps-sensor-part1.html" />
    <id>https://matsubara0507.github.io/posts/2020-05-31-create-deps-sensor-part1.html</id>
    <published>2020-05-31T00:00:00Z</published>
    <updated>2020-05-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="post-content" itemprop="articleBody">
    <p>思いついたツールを自作続けるとこうなりますよね</p>
<p><img src="/assets/create-deps-sensor/myprojects.jpg"></img></p>
<p>時々思いつきで依存パッケージ，Stack プロジェクトであれば resolver をあげるんですけど，いい加減調べるのが大変． と言うことで，どれがどんだけ古くなってるかを可視化するツールを作りました． リポジトリはこちら：</p>
<h1 id="section"><iframe width="320" height="163" scrolling="no" frameborder="0" src="https://matsubara0507.github.io/my-github-cards/?target=matsubara0507/repomoving"></iframe></h1>
<h2 id="ゴール">ゴール</h2>
<p>今回は</p>
<ul>
<li>集めるのは Haskell Stack プロジェクトのみ</li>
<li>一覧化するのは stack.yaml に書いてる resolver のみ</li>
</ul>
<p>だけにする． 気が向いたときに少しずつパワーアップしていく．</p>
<h3 id="どうやるか">どうやるか</h3>
<p>可視化したいプロジェクトは設定ファイルで指定する形式にする． 自動で集めても良いが，まぁそれはおいおい．</p>
<p>で，設定をもとにルートにある <code>stack.yaml</code> ファイルを <a href="https://developer.github.com/v3/repos/contents/#get-contents">GitHub API の get-content</a> を使って取得する． そのファイルを読み込んで YAML をパースして，<code>resolver</code> あるいは <code>snapshot</code> を出力する． それだけ．</p>
<p>これを CLI ツールとして作る．</p>
<h2 id="作る">作る</h2>
<p>まずは CLI から．</p>
<h3 id="cli-ツールの雛形">CLI ツールの雛形</h3>
<p>なんと，すでに stack template を用意してあるので簡単：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>$ <span class="ex">stack</span> new deps-sensor github:matsubara0507/mix-cli.hsfiles</span></code></pre></div>
<p>このテンプレートは自作フレームワーク <a href="https://github.com/matsubara0507/mix.hs">mix.hs</a> を使った CLI ツールのもの． mix.hs は <a href="https://github.com/fumieval/extensible">extensible パッケージ</a>と <a href="https://github.com/commercialhaskell/rio">rio パッケージ</a>を混ぜたような簡単なフレームワークです． で，あとはよしなにモジュール名を整えたら<a href="https://github.com/matsubara0507/deps-sensor/commit/f6e463f4cdd7a8488fef57364e5aedcd9ba3049b">出来上がり</a>：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>$ <span class="ex">stack</span> build</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ex">...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>$ <span class="ex">stack</span> exec -- deps-sensor --help</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="ex">deps-sensor</span> [options] [input-file]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="ex">-h</span>  --help     Show this help text</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>      <span class="ex">--version</span>  Show version</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  <span class="ex">-v</span>  --verbose  Enable verbose mode: verbosity level <span class="st">&quot;debug&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>$ <span class="ex">stack</span> exec -- deps-sensor --version</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="ex">Version</span> 0.1.0, Git revision Sat May 23 14:58:54 2020 +0900 (2 commits)</span></code></pre></div>
<h3 id="設定ファイルを読み取る">設定ファイルを読み取る</h3>
<p>まずは型を定義する． 色々考えた結果とりあえず今回はシンプルに：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">DepsSensor.Config</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">RIO</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Extensible</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Yaml</span>       <span class="kw">as</span> <span class="dt">Y</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Record</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>  &#39;[ <span class="st">&quot;repositories&quot;</span> <span class="op">&gt;:</span> [<span class="dt">Text</span>] <span class="co">-- expect owner/name</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>   ]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="ot">readConfig ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> m <span class="dt">Config</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>readConfig <span class="ot">=</span> Y.decodeFileThrow</span></code></pre></div>
<p><code>readConfig</code> を定義してるのは，<code>Y.decodeFileThrow</code> を使うときに型注釈をしなくて良くするため． この設定型を RIO の <code>Env</code> 型に追加する：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">DepsSensor.Env</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">RIO</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Extensible</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">DepsSensor.Config</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Record</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  &#39;[ <span class="st">&quot;logger&quot;</span> <span class="op">&gt;:</span> <span class="dt">LogFunc</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>   , <span class="st">&quot;config&quot;</span> <span class="op">&gt;:</span> <span class="dt">Config</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>   ]</span></code></pre></div>
<p>あとは CLI 側に追加するだけ：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="op">...</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>main <span class="ot">=</span> <span class="op">...</span> <span class="co">-- runCmd を呼び出す</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="co">-- FilePath は CLI のコマンドライン引数で渡す</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span class="ot">runCmd ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>runCmd opts path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>  config <span class="ot">&lt;-</span> readConfig <span class="op">$</span> fromMaybe <span class="st">&quot;./config.yaml&quot;</span> path   <span class="co">-- ココと</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>  <span class="kw">let</span> plugin <span class="ot">=</span> hsequence</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>             <span class="op">$</span> <span class="op">#</span>logger <span class="op">&lt;@=&gt;</span> MixLogger.buildPlugin logOpts</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>            <span class="op">&lt;:</span> <span class="op">#</span>config <span class="op">&lt;@=&gt;</span> MixConfig.buildPlugin config  <span class="co">-- ココを追記</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>            <span class="op">&lt;:</span> nil</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>  Mix.run plugin cmd</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>    logOpts <span class="ot">=</span> <span class="op">#</span>handle <span class="op">@=</span> stdout</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>           <span class="op">&lt;:</span> <span class="op">#</span>verbose <span class="op">@=</span> (opts <span class="op">^.</span> <span class="op">#</span>verbose)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>           <span class="op">&lt;:</span> nil</span></code></pre></div>
<p>これで次のような YAML 設定ファイルを読み込めるようになった：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="fu">repositories</span><span class="kw">:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">-</span><span class="at"> matsubara0507/deps-sensor</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">-</span><span class="at"> matsubara0507/git-plantation</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="kw">-</span><span class="at"> haskell-jp/antenna</span></span></code></pre></div>
<h3 id="github-api-で取得">GitHub API で取得</h3>
<p>GitHub API も頻繁に使うので<a href="https://github.com/matsubara0507/mix.hs/tree/master/mix-plugin-github">プラグイン化</a>してる． 次のように <code>Env</code> 型を拡張して CLI 経由で渡すことで，<code>RIO Env a</code> 配下ですっごく簡単に GitHub API を呼び出すことができる：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">-- Env の拡張</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Mix.Plugin.GitHub</span> <span class="kw">as</span> <span class="dt">MixGitHub</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Record</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  &#39;[ <span class="st">&quot;logger&quot;</span> <span class="op">&gt;:</span> <span class="dt">LogFunc</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>   , <span class="st">&quot;github&quot;</span> <span class="op">&gt;:</span> <span class="dt">MixGitHub.Token</span> <span class="co">-- 追記</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>   , <span class="st">&quot;config&quot;</span> <span class="op">&gt;:</span> <span class="dt">Config</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>   ]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="co">-- Main の拡張</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a><span class="ot">runCmd ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>runCmd opts path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>  gToken <span class="ot">&lt;-</span> liftIO <span class="op">$</span> fromString <span class="op">&lt;$&gt;</span> getEnv <span class="st">&quot;GH_TOKEN&quot;</span>     <span class="co">-- ココと</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>  config <span class="ot">&lt;-</span> readConfig <span class="op">$</span> fromMaybe <span class="st">&quot;./config.yaml&quot;</span> path</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>  <span class="kw">let</span> plugin <span class="ot">=</span> hsequence</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>             <span class="op">$</span> <span class="op">#</span>logger <span class="op">&lt;@=&gt;</span> MixLogger.buildPlugin logOpts</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>            <span class="op">&lt;:</span> <span class="op">#</span>github <span class="op">&lt;@=&gt;</span> MixGitHub.buildPlugin gToken  <span class="co">-- ココを追記</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>            <span class="op">&lt;:</span> <span class="op">#</span>config <span class="op">&lt;@=&gt;</span> MixConfig.buildPlugin config</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>            <span class="op">&lt;:</span> nil</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>  Mix.run plugin cmd</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>    <span class="op">...</span></span></code></pre></div>
<p>呼び出し側はこんな感じ：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">DepsSensor.Cmd</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">GitHub</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Mix.Plugin.GitHub</span> <span class="kw">as</span> <span class="dt">MixGitHub</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="ot">fetchStackFileContent ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">RIO</span> <span class="dt">Env</span> (<span class="dt">Maybe</span> <span class="dt">Text</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>fetchStackFileContent owner name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  <span class="kw">let</span> (owner&#39;, name&#39;) <span class="ot">=</span> (GitHub.mkName <span class="dt">Proxy</span> owner, GitHub.mkName <span class="dt">Proxy</span> name)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>  <span class="co">-- MixGitHub.fetch するだけ，簡単でしょ？</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  resp <span class="ot">&lt;-</span> MixGitHub.fetch <span class="op">$</span> GitHub.contentsForR owner&#39; name&#39; <span class="st">&quot;stack.yaml&quot;</span> <span class="dt">Nothing</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>  <span class="kw">case</span> resp <span class="kw">of</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>    <span class="dt">Left</span> _        <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Nothing</span> <span class="co">-- エラー握り潰すのはあれだけど</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>    <span class="dt">Right</span> content <span class="ot">-&gt;</span> <span class="fu">pure</span> (toFileContent content)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a><span class="co">-- get-content API の返り値に含まれるファイルの中身だけを取り出す</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="ot">toFileContent ::</span> <span class="dt">GitHub.Content</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>toFileContent <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>  <span class="dt">GitHub.ContentFile</span> c <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> GitHub.contentFileContent c</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>  _                    <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<h3 id="yamlを取り込む">YAMLを取り込む</h3>
<p>yaml パッケージを使ってサクッと YAML のデコードをするために，必要な情報だけの簡単なデータ型を作っておく：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">DepsSensor.Cmd</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">StackFile</span> <span class="ot">=</span> <span class="dt">Record</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  &#39;[ <span class="st">&quot;resolver&quot;</span> <span class="op">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>   , <span class="st">&quot;snapshot&quot;</span> <span class="op">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>   ]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="ot">toResolver ::</span> <span class="dt">StackFile</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>toResolver stackFile <span class="ot">=</span> stackFile <span class="op">^.</span> <span class="op">#</span>resolver <span class="op">&lt;|&gt;</span> stackFile <span class="op">^.</span> <span class="op">#</span>snapshot</span></code></pre></div>
<p>実は1つ問題があって，get-content API で取得した中身は Base64 エンコードされているのだ． なので <code>fetchStackFileContent</code> 関数で取得した <code>Text</code> 型の値を Base64 デコードする関数を用意しておこう：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span>                <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray.Encoding</span> <span class="kw">as</span> <span class="dt">BA</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Yaml</span>               <span class="kw">as</span> <span class="dt">Y</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="ot">decodeStackFile ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">StackFile</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>decodeStackFile dat <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  <span class="co">-- 改行コードを含むので抜いて連結してから memory パッケージを使ってデコードしている</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  dat&#39; <span class="ot">&lt;-</span> BA.convertFromBase <span class="dt">BA.Base64</span> <span class="op">$</span> T.encodeUtf8 (<span class="fu">mconcat</span> <span class="op">$</span> T.lines dat)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>  mapLeft <span class="fu">show</span> <span class="op">$</span> Y.decodeEither&#39; dat&#39;</span></code></pre></div>
<p>ちなみに，<a href="https://hackage.haskell.org/package/memory">memory パッケージ</a>を使っているのは <a href="https://hackage.haskell.org/package/cryptonite">cryptonite パッケージ</a>でも利用されているから．</p>
<h3 id="組み合わせる">組み合わせる</h3>
<p>準備は整ったのでこれを連結した処理をループで回すだけだ． ただ，用意したほとんどの関数が <code>Maybe a</code> 型か <code>Either e a</code> 型を返すので，このままエラーハンドリングすると段々畑になってしまう． そこで重宝するのが <a href="https://github.com/matsubara0507/fallible">fallible パッケージ</a>だ：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span>          <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Fallible</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Mix.Plugin.Logger</span> <span class="kw">as</span> <span class="dt">MixLogger</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="ot">cmd ::</span> <span class="dt">RIO</span> <span class="dt">Env</span> ()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>cmd <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  repositories <span class="ot">&lt;-</span> asks (view <span class="op">#</span>repositories <span class="op">.</span> view <span class="op">#</span>config)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>  for_ repositories <span class="op">$</span> \repo <span class="ot">-&gt;</span> evalContT <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    <span class="kw">let</span> (owner, name) <span class="ot">=</span> T.drop <span class="dv">1</span> <span class="op">&lt;$&gt;</span> T.break (<span class="op">==</span> <span class="ch">&#39;/&#39;</span>) repo</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>    content   <span class="ot">&lt;-</span> lift (fetchStackFileContent owner name) <span class="op">!??</span> warn repo <span class="st">&quot;stack.yaml is not found&quot;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>    stackFile <span class="ot">&lt;-</span> decodeStackFile content <span class="op">??=</span> warn repo</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    resolver  <span class="ot">&lt;-</span> toResolver stackFile <span class="op">???</span> warn repo <span class="st">&quot;undefined resolver&quot;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>    MixLogger.logInfo (display <span class="op">$</span> repo <span class="op">&lt;&gt;</span> <span class="st">&quot;: &quot;</span> <span class="op">&lt;&gt;</span> resolver)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>    <span class="co">-- とりあえず警告するだけ</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>    warn r msg <span class="ot">=</span> exit <span class="op">$</span> MixLogger.logWarn (display <span class="op">$</span> T.pack msg <span class="op">&lt;&gt;</span> <span class="st">&quot;: &quot;</span> <span class="op">&lt;&gt;</span> r)</span></code></pre></div>
<p>演算子が3種類も出てきてわかりにくいが - 左が <code>!</code> の場合は左辺が <code>RIO Env (f a)</code> になっていて， <code>?</code> の場合は <code>f a</code> になっている（<code>f</code> は <code>Maybe</code> や <code>Either e</code>） - 右が <code>=</code> の場合は右辺で <code>Either e a</code> の <code>e</code> を受け取るハンドリングをし，<code>?</code> の場合は無視する（<code>Maybe</code> の場合は後者一択）</p>
<p>で，これを実行するとこんな感じになった：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec -- deps-sensor</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ex">matsubara0507</span>/deps-sensor: <span class="ex">lts-15.13</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="ex">matsubara0507</span>/git-plantation: <span class="ex">lts-15.5</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="ex">haskell-jp</span>/antenna: <span class="ex">lts-14.20</span></span></code></pre></div>
<h1 id="おしまい">おしまい</h1>
<p>追々，Webページの生成と http://packdeps.haskellers.com っぽい機能を足したりするつもりです。</p>
  </div>]]></summary>
</entry>

</feed>
