<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>ひげメモ</title>
    <link href="https://matsubara0507.github.io/feed.xml" rel="self" />
    <link href="https://matsubara0507.github.io" />
    <id>https://matsubara0507.github.io/feed.xml</id>
    <author>
        <name>MATSUBARA Nobutada</name>
        <email></email>
    </author>
    <updated>2018-12-18T00:00:00Z</updated>
    <entry>
    <title>GHC 8.x 勉強会に行ってきた</title>
    <link href="https://matsubara0507.github.io/posts/2018-12-18-ghc8x.html" />
    <id>https://matsubara0507.github.io/posts/2018-12-18-ghc8x.html</id>
    <published>2018-12-18T00:00:00Z</published>
    <updated>2018-12-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">GHC 8.x 勉強会に行ってきた</h1>
    <p class="post-meta">
      <time datetime="2018-12-18" itemprop="datePublished">
        Dec 18, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>本記事は <a href="https://qiita.com/advent-calendar/2018/haskell2">Haskell (その2) Advent Calendar 2018</a> の18日目の記事です． 空いていたのでついでに埋めました．</p>
<h2 id="section"></h2>
<p>12/7 の10-17時半ぐらいに IIJ-II で GHC8 系のバージョンアップを追う会的なイベントが企画されました． このイベントは IIJ-II の Haskell チームで発案・企画し，Haskell-jp の Slack で募集をかけていました． 定員12人かつ，平日昼間でしたが，面白そうなので有給とって行ってきた(僕は IIJ-II では無いので)． 多少クローズドな会ということもあり，せっかくなので色々と議論したことを記事に起こしておきます． 正確な情報は GHC のドキュメントを呼んでください．</p>
<h2 id="進め方">進め方</h2>
<p>GHCには<a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/8.0.1-notes.html">こんな感じ</a>のリリースノートがある． 当日は8系のリリースノートのハイライトを追っていくという感じだった．</p>
<p>事前に一人一つぐらいは調べてきて発表する感じだったが，担当者がいない内容でも，紹介記事を引っ張ってきたりなんだりしてた．</p>
<h2 id="section-1">8.0</h2>
<p><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/8.0.1-notes.html">リリースノートはこれ</a>． 8.0だけめっちゃ多い． 当初は 7.12 とかにする予定だったが，あまりにも差分があったので 8 にした的な話があるとかないとか(要出典)．</p>
<h3 id="typeintype-など">TypeInType など</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeInType"><code>TypeInType</code></a> 言語拡張について</li>
<li>以下3つの言語拡張も包含している
<ul>
<li>PolyKinds</li>
<li>DataKinds</li>
<li>KindSignatures</li>
</ul></li>
<li>PolyKind: 型変数のカインドが多相的になる（本来は <code>*</code>）</li>
<li>DataKinds: 定義した型をカインドとして利用できる</li>
<li>KindSignatures: カインドを明示的に指定できる</li>
<li>TypeInType:
<ul>
<li>上記全部を利用可</li>
<li>多相カインド</li>
<li>RankNTypes も追加で高階カインドも可能</li>
</ul></li>
<li>Q: 結局目指すところは？
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">Dependent Haskell</a> のマイルストーンの一部では？</li>
<li>Merging Types and Kinds</li>
</ul></li>
</ul>
<h3 id="patternsynonyms-系">PatternSynonyms 系</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#record-patsyn">Record Pattern Synonyms</a> をサポート</li>
<li>レコード型でも PatternSynonyms を利用</li>
<li><a href="https://kazu-yamamoto.hatenablog.jp/entry/20170919/1505787393">PatternSynonymsのススメ - あどけない話</a>
<ul>
<li>そもそも PatternSynonyms って？</li>
<li>PatternSynonyms それ自体は 7.8.1 から</li>
</ul></li>
<li>8.0 から export 時に <code>pattern</code> キーワードがいらなくなった
<ul>
<li>すごい助かるって意見もあれば</li>
<li>あえて明示的にすべきという意見も</li>
</ul></li>
<li>ネットワーク屋さん的にはこのパターンは本当に便利という話</li>
<li>BangPattern や ViewPattern の組み合わせ</li>
</ul>
<h3 id="deriveanyclass">DeriveAnyClass</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#derive-any-class">DeriveAnyClass</a> 言語拡張について</li>
<li>名前の通り任意の型クラスに対して <code>deriving</code> を利用する仕組みを提供</li>
<li><code>deriving</code> 可能な型クラスからデフォルト実装を定義したり</li>
</ul>
<h3 id="injective-type-families">Injective type families</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#injective-ty-fams"><code>TypeFamilyDependencies</code></a> 言語拡張について</li>
<li><a href="https://qiita.com/lotz/items/6c038698c8f04f57113a">型族が単射だと嬉しい理由 - Qiita</a></li>
<li>(書いた当人は書いてたこと忘れてた笑)</li>
</ul>
<h3 id="applicativedo">ApplicativeDo</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#applicative-do"><code>ApplicativeDo</code></a> 言語拡張について</li>
<li>do 記法が Applicative でも使える</li>
<li>だけじゃなく，do 記法が特定の条件を満たすと勝手に Applicative や Functor に脱糖してくれる
<ul>
<li>この条件がなかなか(笑)</li>
</ul></li>
</ul>
<p>なんか結構盛り上がった(笑)</p>
<h3 id="wildcards-in-data-and-type-family">Wildcards in data and type family</h3>
<p><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#wildcards-on-the-lhs-of-data-and-type-family-instances">この辺り</a>？ ちょっと何話したか忘れた．</p>
<h3 id="strict-系">Strict 系</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#strict-haskell"><code>Strict</code></a> 言語拡張について</li>
<li><a href="https://kazu-yamamoto.hatenablog.jp/entry/20151117/1447726679">Strict Haskell - あどけない話</a></li>
<li>昔から正格評価にする記法はあったが，この拡張によりデフォルトの評価戦略を切り替えれる．</li>
<li>実は逆に <code>~x</code> とすることで <code>x</code> を遅延評価できる</li>
<li>Q: パターンマッチの反駁不能パターンはどうなるんだろ？
<ul>
<li><code>~(~x)</code> のようにチルダをカッコで重ねる</li>
</ul></li>
</ul>
<h3 id="duplicate-record-fields">Duplicate record fields</h3>
<ul>
<li><a href="https://kazu-yamamoto.hatenablog.jp/entry/20160114/1452735514">重複したフィールドラベル - あどけない話</a></li>
<li>Q: <code>instance (a ~ Int) =&gt; IsLabel &quot;same&quot; (Foo -&gt; a)</code> の <code>a ~ Int</code> はなぜ必要か？
<ul>
<li><code>IsLabel &quot;same&quot; (Foo -&gt; Int)</code> ではなく</li>
<li>推論の順番を明示的にする</li>
</ul></li>
<li>Q: ボイラーテンプレートの件は進んだの？？
<ul>
<li>なんか放置されてる</li>
</ul></li>
<li>SystemF + レコード多相は死ぬ
<ul>
<li>OCaml は分けている</li>
</ul></li>
</ul>
<h3 id="ユーザ定義-typeerror">ユーザ定義 TypeError</h3>
<ul>
<li>型エラーをユーザーで定義できる？</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Proposal/CustomTypeErrors">プロポーザル</a></li>
<li>どんな話したか忘れました，すいません</li>
</ul>
<h3 id="ghci-関連">GHCi 関連</h3>
<ul>
<li>本来 GHCi はコードを同一のプロセスと共通のヒープで実行する</li>
<li>それを <a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/ghci.html#external-interpreter"><code>fexternal-interpreter</code></a> オプションでコントロールできる</li>
<li>だっけか（また細かい話は忘れました，すいません）</li>
</ul>
<h2 id="section-2">8.2</h2>
<p><a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/8.2.1-notes.html">リリースノートはこれ</a>．</p>
<ul>
<li>Typeable mechanism, Type.Reflection</li>
<li>そういえばCUIがカラフルになったね</li>
<li>Heap 系
<ul>
<li>あんまりよく覚えてないごめんなさい</li>
</ul></li>
</ul>
<h3 id="derivingstrategies">DerivingStrategies</h3>
<ul>
<li><code>DerivingStrategies</code> 言語拡張について</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DerivingStrategies">Commentary/Compiler/DerivingStrategies – GHC</a></li>
<li><a href="https://github.com/kakkun61/deriving-strategies-playground">kakkun 氏の資料</a></li>
<li><code>deriving</code> する時に <code>newtype</code> や <code>stock</code> などのキーワードを指定することで <code>deriving</code> の仕方をコントロールできる</li>
</ul>
<h3 id="unboxedsums">UnboxedSums</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XUnboxedSums"><code>UnboxedSums</code></a> 言語拡張について</li>
<li><a href="https://gist.github.com/maoe/e5888fad16a190a9c7cf58b8bedb1d04">maoe 氏の資料</a></li>
</ul>
<h3 id="compact-regions">Compact Regions</h3>
<ul>
<li><a href="https://github.com/ezyang/compact">ezyang/compact - GitHub</a></li>
<li>処理系によってGCされないデータ領域</li>
<li>インターフェースは充実してる</li>
<li>ただしデータの追加しかできない（書き換えは不可）</li>
<li>Q: 何に使える？
<ul>
<li>強大な辞書とか？</li>
<li>設定ファイルとか？（巨大なら）</li>
<li>NGワード集とか？</li>
</ul></li>
</ul>
<p>GHC8.x 勉強会のあとに記事にしてくれた:</p>
<ul>
<li><a href="https://qiita.com/ruicc/items/c955e794c5dc74c4cb58">Compact Regionsについて軽く - Qiita</a></li>
</ul>
<h3 id="backpack">Backpack</h3>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Backpack">Backpack – GHC</a></li>
<li>雑にいうと: ML系のファンクターのようなより強力なモジュールシステム</li>
<li>モジュールのインターフェースと実装を分離できる</li>
<li><a href="https://matsubara0507.github.io/posts/2017-12-12-backpack-memo.html">Haskell Backpack 覚え書き - ひげメモ</a>
<ul>
<li>自分の記事だけど1年近く前で覚えてない(笑)</li>
</ul></li>
<li>Q: どんな時に有用？
<ul>
<li>本質的には型クラスと同じ用途のはず</li>
<li>ただし型に依存しない（型クラスは型によって実装をディスパッチ）</li>
<li>不自然な <code>Proxy a</code> を渡さなくていい（苦肉の策でそういう実装をしている型クラスがある）</li>
</ul></li>
<li>そういえば最近 <a href="https://github.com/kowainik/containers-backpack">contains の Backpack 版</a>がでた</li>
</ul>
<p>作者さんが忙しくて Stack への適用を断念したため，なかなか浸透しない． 今「Stack への適用をやりたい」という人が現れたが時間がかかりそう．</p>
<h3 id="脱線-各位リンカどうしてるの">脱線: 各位リンカどうしてるの？</h3>
<p>kazu yamamoto 氏が GHC 8.6 になってから(だっけ？)リンカ周りで動作しなくて困ってるらしい(OS は Mac)． 僕は適当にやってて困ったことないのでよくわからない．</p>
<p>ちなみに GHC 8.6.3 で無事動いたらしい:</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
吉報：GHC 8.6.3 は macOS で問題なく使えるようになりました！
</p>
— 山本和彦 (<span class="citation" data-cites="kazu_yamamoto">@kazu_yamamoto</span>) <a href="https://twitter.com/kazu_yamamoto/status/1072030847799255040?ref_src=twsrc%5Etfw">2018年12月10日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h2 id="section-3">8.4</h2>
<p><a href="https://downloads.haskell.org/~ghc/8.4.4/docs/html/users_guide/8.4.1-notes.html">リリースノートはこれ</a>．</p>
<p>そういえば，8.4.4 は 8.6 系が出てから出て，ちゃんとバグフィックス出すんだと感心した的な話をした．</p>
<h3 id="semigroup-monoid-proposal">Semigroup-Monoid Proposal</h3>
<ul>
<li><code>Monoid</code> にサブクラスとして <code>Semigroup</code> を持たせる
<ul>
<li>その方が数学的に自然</li>
</ul></li>
<li><a href="https://kazu-yamamoto.hatenablog.jp/entry/20180306/1520314185">あなたの知らないSemigroupの世界 - あどけない話</a></li>
<li>前のバージョンアから <code>-Wnoncanonical-monoid-instances</code> などの警告を付け足して段階的にやっている
<ul>
<li>しかし <code>-Wall</code> に含まれてないので気づかず</li>
<li>なんか 8.4 で急にエラーに</li>
</ul></li>
<li>ちなみに以降は <code>Monoid</code> をインポートしなくても <code>(&lt;&gt;)</code> が使える</li>
</ul>
<h3 id="monadfail-と-no-return">MonadFail と no return</h3>
<p>ここは脱線．</p>
<ul>
<li><a href="https://wiki.haskell.org/MonadFail_Proposal">MonadFail Proposal - HaskellWiki</a></li>
<li><code>Monad</code> には <code>fail</code> が定義されている
<ul>
<li>が <code>error</code> などを利用している残念な実装もある</li>
</ul></li>
<li><code>MonadFail</code> という型クラスで切り出す</li>
<li><code>-Wnoncanonical-monadfail-instances</code> ができた？</li>
<li>8.6: <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-MonadFailDesugaring"><code>MonadFailDesugaring</code></a> 言語拡張がデフォルトに
<ul>
<li>do 記法の <code>fail</code> への脱糖が <code>MonadFail</code> のものになる</li>
</ul></li>
</ul>
<h2 id="section-4">8.6</h2>
<p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/8.6.1-notes.html">リリースノートはこれ</a>．</p>
<h3 id="quantifiedconstraints">QuantifiedConstraints</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-QuantifiedConstraints">QuantifiedConstraints</a> 言語拡張を追加</li>
<li>インスタンスの定義に量化が使える
<ul>
<li>例: <code>instance (Eq a, forall b. (Eq b) =&gt; Eq (f b)) =&gt; Eq (Rose f a)</code></li>
</ul></li>
<li><a href="http://the.igreque.info/slides/2018-12-07-ghc8x.html">igrap 氏の資料</a></li>
<li>Q: Constraint のシノニムでも使える？
<ul>
<li>無理だった orz</li>
</ul></li>
</ul>
<h3 id="derivingvia">DerivingVia</h3>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DerivingVia"><code>DerivingVia</code></a> 言語拡張について</li>
<li><code>via</code> キーワードを使ってインスタンスを明示的に選択できるようになる</li>
<li><a href="https://github.com/kayhide/try-ghc86">kayhide 氏の資料</a>
<ul>
<li>QuickCheck の例</li>
<li>テストの実装を Via で定義</li>
</ul></li>
<li>わかりやすい<a href="https://speakerdeck.com/konn/ben-dang-hasugoi-newtype">スライド</a>
<ul>
<li>後半の方</li>
<li>タプルの例</li>
</ul></li>
</ul>
<h3 id="plugin-mechanism">Plugin mechanism</h3>
<p>(誰も調べてはない) ちょうど記事があった</p>
<ul>
<li><a href="https://qiita.com/waddlaw/items/65b57517f105fcbbe724">GHC Source Plugin 作ってみた - Qiita</a></li>
</ul>
<p>終わった後の雑談で，Scala には似たような機能(Scala Compiler Plugins?)が既にあるので，真似するといいとかなんとか．</p>
<h3 id="valid-hole-fits">Valid hole fits</h3>
<ul>
<li><a href="https://wiki.haskell.org/GHC/Typed_holes">Type holes</a> という機能についての拡張
<ul>
<li><a href="https://haskell.jp/blog/posts/2017/07-TypedHoles.html">Type Hole については Haskell-jp に記事がある</a></li>
</ul></li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#typed-hole-valid-hole-fits">コンパイルフラグ</a>で type Holes での推論アルゴリズム(?)のコントロールができるようになった(って感じかな)</li>
</ul>
<h3 id="シンタックスの言語拡張">シンタックスの言語拡張</h3>
<ul>
<li>数値リテラルに <code>_</code> が使える: <code>10_000_000</code> とか</li>
<li><code>do</code> 記法の前に <code>$</code> などがいらなくなる: <code>\x -&gt; do ...</code> とか</li>
</ul>
<h1 id="おしまい">おしまい</h1>
<p>時間経ちすぎてめっちゃ適当になってしまった． すいません． ただ，めっちゃ楽しかった．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>詳解 elm/url !!</title>
    <link href="https://matsubara0507.github.io/posts/2018-12-11-detail-elm-url.html" />
    <id>https://matsubara0507.github.io/posts/2018-12-11-detail-elm-url.html</id>
    <published>2018-12-11T00:00:00Z</published>
    <updated>2018-12-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">詳解 elm/url !!</h1>
    <p class="post-meta">
      <time datetime="2018-12-11" itemprop="datePublished">
        Dec 11, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Elm.html">Elm</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>本記事は <a href="https://qiita.com/advent-calendar/2018/elm">Elm Advent Calendar 2018</a> の11日目の記事です． elm-jp の Discord で突如無茶振りされたので頑張ります．</p>
<h2 id="elmurl">elm/url</h2>
<p><a href="https://package.elm-lang.org/packages/elm/url/1.0.0/">elm/url</a> は Elm 0.19 で刷新されたパッケージ群にしれっと混ざってきた URL に関するパッケージ． <a href="https://package.elm-lang.org/packages/elm/browser/latest/Browser#application">Browser.application</a> でも使われているのでみなさんも頑張って使えるようになりましょう．</p>
<p>ちなみに本記事では ver1.0.0 の elm/url を想定している．</p>
<h2 id="url-の型">Url の型</h2>
<p>こんな風に定義されている:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">type</span> alias <span class="dt">Url</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-2" title="2">    { protocol <span class="fu">:</span> <span class="dt">Protocol</span></a>
<a class="sourceLine" id="cb1-3" title="3">    , host <span class="fu">:</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-4" title="4">    , port_ <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-5" title="5">    , path <span class="fu">:</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-6" title="6">    , query <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-7" title="7">    , fragment <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-8" title="8">    }</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">type</span> <span class="dt">Protocol</span> <span class="fu">=</span> <span class="dt">Http</span> <span class="fu">|</span> <span class="dt">Https</span></a></code></pre></div>
<p>超絶わかりやすい ASCII アートまでありエヴァン様神って感じ:</p>
<pre><code>  https://example.com:8042/over/there?name=ferret#nose
  \___/   \______________/\_________/ \_________/ \__/
    |            |            |            |        |
  scheme     authority       path        query   fragment</code></pre>
<p><code>host</code> は <code>example.com</code> の部分で <code>port_</code> は <code>8042</code> の部分． 試しに REPL で <code>Url.fromString</code> してみよう:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Url</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="fu">&gt;</span> Url.fromString <span class="st">&quot;https://example.com:8042/over/there?name=ferret#nose&quot;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="dt">Just</span> { fragment <span class="fu">=</span> <span class="dt">Just</span> <span class="st">&quot;nose&quot;</span>, host <span class="fu">=</span> <span class="st">&quot;example.com&quot;</span>, path <span class="fu">=</span> <span class="st">&quot;/over/there&quot;</span>, port_ <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">8042</span>, protocol <span class="fu">=</span> <span class="dt">Https</span>, query <span class="fu">=</span> <span class="dt">Just</span> <span class="st">&quot;name=ferret&quot;</span> }</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">Url.Url</span></a></code></pre></div>
<h2 id="url.parser-の使い方">Url.Parser の使い方</h2>
<p>さて，ここからが本番． <code>Url.Parser</code> モジュールを利用して <code>Browser.application</code> などから受け取った URL をパースして，任意の型に変換するパーサーを記述する．</p>
<h3 id="パーサーの例">パーサーの例</h3>
<p>次のような型にパースするパーサーを記述する:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">type</span> alias <span class="dt">Post</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-2" title="2">  { <span class="fu">id</span> <span class="fu">:</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-3" title="3">  , name <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-4" title="4">  }</a></code></pre></div>
<p>入力には <code>http://localhost/hoge/1234?name=fuga</code> URL というのを想定している．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">import</span> <span class="dt">Url.Parser</span> <span class="kw">as</span> <span class="dt">Url</span> exposing ((&lt;/&gt;), (&lt;?&gt;))</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">import</span> <span class="dt">Url.Parser.Query</span> <span class="kw">as</span> <span class="dt">Query</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4">parser1 <span class="fu">:</span> <span class="dt">Url.Parser</span> (<span class="dt">Post</span> <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb5-5" title="5">parser1 <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-6" title="6">  Url.map <span class="dt">Post</span> (Url.s <span class="st">&quot;hoge&quot;</span> <span class="fu">&lt;/&gt;</span> Url.string <span class="fu">&lt;?&gt;</span> Query.string <span class="st">&quot;name&quot;</span>)</a></code></pre></div>
<p>これを使ってみると:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">&gt;</span> Url.fromString <span class="st">&quot;http://localhost/hoge/1234?name=fuga&quot;</span> <span class="fu">|&gt;</span> <span class="dt">Maybe</span><span class="fu">.</span>andThen (Url.parse parser1)</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="dt">Just</span> { <span class="fu">id</span> <span class="fu">=</span> <span class="dv">1234</span>, name <span class="fu">=</span> <span class="dt">Just</span> <span class="st">&quot;fuga&quot;</span> }</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">Post</span></a></code></pre></div>
<h3 id="基本的な関数と型">基本的な関数と型</h3>
<p>まずは肝となる <code>Url.parse</code> 関数の型を見てみる:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">parse <span class="fu">:</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a) a <span class="ot">-&gt;</span> <span class="dt">Url</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p><code>Parser a b</code> というのがパーサーの型だ(<code>a</code> と <code>b</code> が何を意味しているかは後述，無論 <code>a</code> と <code>b</code> が同じでもいい)． <code>Parser (a -&gt; a) a</code> という型(この <code>a</code> は全て同じ型)のパーサーを与えて <code>Url</code> という入力を食わせることで <code>Maybe a</code> という結果を受け取れる． 途中でパース失敗した場合は <code>Nothing</code> が返り，成功すると <code>Just a</code> の値が返る．</p>
<h2 id="section"></h2>
<p>次のような関数を組み合わせて，パーサーを構築する:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">string <span class="fu">:</span> <span class="dt">Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb8-2" title="2">int    <span class="fu">:</span> <span class="dt">Parser</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb8-3" title="3">s      <span class="fu">:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a a</a>
<a class="sourceLine" id="cb8-4" title="4">top    <span class="fu">:</span> <span class="dt">Parser</span> a a</a>
<a class="sourceLine" id="cb8-5" title="5">(<span class="fu">&lt;/&gt;</span>)  <span class="fu">:</span> <span class="dt">Parser</span> a b <span class="ot">-&gt;</span> <span class="dt">Parser</span> b c <span class="ot">-&gt;</span> <span class="dt">Parser</span> a c</a>
<a class="sourceLine" id="cb8-6" title="6"><span class="fu">map</span>    <span class="fu">:</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a b <span class="ot">-&gt;</span> <span class="dt">Parser</span> (b <span class="ot">-&gt;</span> c) c</a></code></pre></div>
<p><code>Parser</code> の型が <code>Parser a b</code> の場合と <code>Parser (a -&gt; b) b</code> の場合の2パターンがあることに気づいただろうか？ <code>string</code> や <code>int</code> のような <code>(a -&gt; b)</code> のようなパーサーの場合は， <code>a</code> の部分がパース結果の型と考えられる． 対して <code>s</code> や <code>top</code> のような関数は入力(<code>Url</code>)を消費するだけでパース結果の型(<code>parse</code> の <code>Maybe a</code> の <code>a</code> の部分)に影響を与えない． そして <code>(&lt;/&gt;)</code> が URL の区切り文字(<code>/</code>) である．</p>
<h2 id="section-1"></h2>
<p>試しにいくつか組み合わせてみよう:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">&gt;</span> parser2 <span class="fu">=</span> Url.s <span class="st">&quot;hoge&quot;</span> <span class="fu">&lt;/&gt;</span> Url.string <span class="fu">&lt;/&gt;</span> Url.int</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="dt">Parser</span> <span class="fu">&lt;</span>function<span class="fu">&gt;</span> <span class="fu">:</span> <span class="dt">Url.Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> c) c</a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="fu">&gt;</span> parser3 <span class="fu">=</span> parser2 <span class="fu">&lt;/&gt;</span> Url.int <span class="fu">&lt;/&gt;</span> Url.top</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="dt">Parser</span> <span class="fu">&lt;</span>function<span class="fu">&gt;</span> <span class="fu">:</span> <span class="dt">Url.Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> c) c</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="fu">&gt;</span> <span class="kw">type</span> alias <span class="dt">Hoge1</span> <span class="fu">=</span> { hoge1 <span class="fu">:</span> <span class="dt">String</span>, hoge2 <span class="fu">:</span> <span class="dt">Int</span>, hoge3 <span class="fu">:</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="fu">&gt;</span> parser4 <span class="fu">=</span> Url.map <span class="dt">Hoge1</span> parser3</a>
<a class="sourceLine" id="cb9-10" title="10"><span class="dt">Parser</span> <span class="fu">&lt;</span>function<span class="fu">&gt;</span> <span class="fu">:</span> <span class="dt">Url.Parser</span> (<span class="dt">Hoge1</span> <span class="ot">-&gt;</span> c) c</a></code></pre></div>
<p>このように <code>&lt;/&gt;</code> でパーサーを連結することで <code>Parser a b</code> の <code>a</code> の部分がどんどん伸びてくる． ちなみに，<code>top</code> はURLの末尾かどうかのチェックするパーサーだ:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">Hoge2</span> <span class="fu">=</span> <span class="dt">Hoge2</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="fu">&gt;</span> Url.fromString <span class="st">&quot;http://localhost/&quot;</span> <span class="fu">|&gt;</span> <span class="dt">Maybe</span><span class="fu">.</span>andThen (Url.parse (Url.map <span class="dt">Hoge2</span> Url.top))</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="dt">Just</span> <span class="dt">Hoge2</span> <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">Hoge2</span></a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="fu">&gt;</span> Url.fromString <span class="st">&quot;http://localhost/1&quot;</span> <span class="fu">|&gt;</span> <span class="dt">Maybe</span><span class="fu">.</span>andThen (Url.parse (Url.map <span class="dt">Hoge2</span> Url.top))</a>
<a class="sourceLine" id="cb10-7" title="7"><span class="dt">Nothing</span> <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">Hoge2</span></a></code></pre></div>
<h2 id="url.parser.query-の使い方">Url.Parser.Query の使い方</h2>
<p><code>Parser a b</code> の <code>b</code> 側が仕事をするのはクエリに関するパーサーがある場合だ． なので次にクエリのパーサーを見てみる． 便宜上以降ではクエリの型や関数には <code>Query</code> を付けるようにする．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">(<span class="fu">&lt;?&gt;</span>)  <span class="fu">:</span> <span class="dt">Parser</span> a (query <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Query.Parser</span> query <span class="ot">-&gt;</span> <span class="dt">Parser</span> a b</a>
<a class="sourceLine" id="cb11-2" title="2">string <span class="fu">:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Query.Parser</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb11-3" title="3">int    <span class="fu">:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Query.Parser</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb11-4" title="4"><span class="fu">map</span>    <span class="fu">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Query.Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Query.Parser</span> b</a>
<a class="sourceLine" id="cb11-5" title="5">map2   <span class="fu">:</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> result) <span class="ot">-&gt;</span> <span class="dt">Query.Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Query.Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Query.Parser</span> result</a></code></pre></div>
<p><code>(&lt;?&gt;)</code> という演算子が Url のパーサーとクエリのパーサーを繋ぐ． クエリのパーサーの型は <code>Parser a</code> と JSON デコーダーのような型と同じ仕組みだ．</p>
<p><code>map</code> で連結したものを <code>(&lt;?&gt;)</code> で一気に繋げても良いし，<code>(&lt;?&gt;)</code> で一つずつ繋げても良い:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="fu">&gt;</span> <span class="kw">type</span> alias <span class="dt">Fuga1</span> <span class="fu">=</span> { fuga1 <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">String</span>, fuga2 <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="fu">&gt;</span> parser5 <span class="fu">=</span> Url.top <span class="fu">&lt;?&gt;</span> Query.map2 <span class="dt">Fuga1</span> (Query.string <span class="st">&quot;fuga1&quot;</span>) (Query.int <span class="st">&quot;fuga2&quot;</span>)</a>
<a class="sourceLine" id="cb12-4" title="4"><span class="dt">Parser</span> <span class="fu">&lt;</span>function<span class="fu">&gt;</span> <span class="fu">:</span> <span class="dt">Url.Parser</span> (<span class="dt">Fuga1</span> <span class="ot">-&gt;</span> b) b</a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="fu">&gt;</span> parser5 <span class="fu">=</span> Url.map <span class="dt">Fuga1</span> (Url.top <span class="fu">&lt;?&gt;</span> Query.string <span class="st">&quot;fuga1&quot;</span> <span class="fu">&lt;?&gt;</span> Query.int <span class="st">&quot;fuga2&quot;</span>)</a>
<a class="sourceLine" id="cb12-7" title="7"><span class="dt">Parser</span> <span class="fu">&lt;</span>function<span class="fu">&gt;</span> <span class="fu">:</span> <span class="dt">Url.Parser</span> (<span class="dt">Fuga1</span> <span class="ot">-&gt;</span> c) c</a></code></pre></div>
<h2 id="fragment">Fragment</h2>
<p>フラグメントの部分をパースするには <code>fragment</code> 関数を使う:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">fragment <span class="fu">:</span> (<span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> fragment) <span class="ot">-&gt;</span> <span class="dt">Parser</span> (fragment <span class="ot">-&gt;</span> a) a</a></code></pre></div>
<p>なんでもよければ <code>identity</code> を使えば良い:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="fu">&gt;</span> parser6 <span class="fu">=</span> Url.top <span class="fu">&lt;/&gt;</span> Url.fragment identity</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="dt">Parser</span> <span class="fu">&lt;</span>function<span class="fu">&gt;</span> <span class="fu">:</span> <span class="dt">Url.Parser</span> (<span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> c) c</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="fu">&gt;</span> Url.fromString <span class="st">&quot;http://localhost#abc&quot;</span> <span class="fu">|&gt;</span> <span class="dt">Maybe</span><span class="fu">.</span>andThen (Url.parse parser6)</a>
<a class="sourceLine" id="cb14-5" title="5"><span class="dt">Just</span> (<span class="dt">Just</span> <span class="st">&quot;abc&quot;</span>) <span class="fu">:</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="fu">&gt;</span> Url.fromString <span class="st">&quot;http://localhost&quot;</span> <span class="fu">|&gt;</span> <span class="dt">Maybe</span><span class="fu">.</span>andThen (Url.parse parser6)</a>
<a class="sourceLine" id="cb14-8" title="8"><span class="dt">Just</span> <span class="dt">Nothing</span> <span class="fu">:</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</a></code></pre></div>
<h2 id="中身を読んでいく">中身を読んでいく</h2>
<p>今までの話でなんとなく使い方はわかっただろう． ここからは elm/url の実装について読み解いていく． なので，使い方が分かればもう十分勢の人は以降を読む必要はない．</p>
<h3 id="余談-参考にしたもの">余談: 参考にしたもの</h3>
<p><a href="https://github.com/elm/url#related-work">README曰く</a>，<code>Url.Parser</code> の実装の着想は下記の記事によって得たようだ．</p>
<ul>
<li><a href="https://chrisdone.com/posts/formatting">Formatting in Haskell</a></li>
<li><a href="http://rgrinberg.com/posts/primitive-type-safe-routing/">Type Safe Routing - Baby Steps</a></li>
</ul>
<p>前者は Haskell の <code>printf</code> のようなフォーマット出力ライブラリで，後者は OCaml のルーティングのライブラリに関する記事．</p>
<h3 id="パーサーの型">パーサーの型</h3>
<p>まずは型の中身を見てみる:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">type</span> <span class="dt">Parser</span> a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="dt">Parser</span> (<span class="dt">State</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">State</span> b))</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="kw">type</span> alias <span class="dt">State</span> value <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-5" title="5">  { visited <span class="fu">:</span> <span class="dt">List</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-6" title="6">  , unvisited <span class="fu">:</span> <span class="dt">List</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-7" title="7">  , params <span class="fu">:</span> <span class="dt">Dict</span> <span class="dt">String</span> (<span class="dt">List</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb15-8" title="8">  , frag <span class="fu">:</span> <span class="dt">Maybe</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-9" title="9">  , value <span class="fu">:</span> value</a>
<a class="sourceLine" id="cb15-10" title="10">  }</a></code></pre></div>
<p><code>State a -&gt; List (State b)</code> というのは関数型パーサー(パーサーコンビネーター)でよくある型だ(<code>Functional Parser</code> や <code>Parser Combinator</code> などで調べると良い)． 入力の状態が <code>State a</code> で出力の状態が <code>State b</code>，出力がリストになっているが <code>Maybe</code> と考えて問題ないはずだ．</p>
<p><code>Url.parse</code> や簡単なパーサーの中身を見てみればそれぞれのフィールドの意味がわかるはずだ:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">parse <span class="fu">:</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a) a <span class="ot">-&gt;</span> <span class="dt">Url</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb16-2" title="2">parse (<span class="dt">Parser</span> parser) url <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-3" title="3">  getFirstMatch <span class="fu">&lt;|</span> parser <span class="fu">&lt;|</span></a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="dt">State</span> [] (preparePath url<span class="fu">.</span>path) (prepareQuery url<span class="fu">.</span>query) url<span class="fu">.</span>fragment identity</a>
<a class="sourceLine" id="cb16-5" title="5"></a>
<a class="sourceLine" id="cb16-6" title="6">getFirstMatch <span class="fu">:</span> <span class="dt">List</span> (<span class="dt">State</span> a) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb16-7" title="7">getFirstMatch states <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-8" title="8">  <span class="kw">case</span> states <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-9" title="9">    [] <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-10" title="10">      <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb16-11" title="11"></a>
<a class="sourceLine" id="cb16-12" title="12"><span class="ot">    state ::</span> rest <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-13" title="13">      <span class="kw">case</span> state<span class="fu">.</span>unvisited <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-14" title="14">        [] <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-15" title="15">          <span class="dt">Just</span> state<span class="fu">.</span>value</a>
<a class="sourceLine" id="cb16-16" title="16"></a>
<a class="sourceLine" id="cb16-17" title="17">        [<span class="st">&quot;&quot;</span>] <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-18" title="18">          <span class="dt">Just</span> state<span class="fu">.</span>value</a>
<a class="sourceLine" id="cb16-19" title="19"></a>
<a class="sourceLine" id="cb16-20" title="20">        _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-21" title="21">          getFirstMatch rest</a></code></pre></div>
<p><code>parse</code> の定義より，<code>unvisited</code> と <code>params</code> と <code>frag</code> はそれぞれパスとクエリとフラグメントを与えているのがわかる． <code>getFirstMatch</code> の定義を見ると，最後に <code>Just state.value</code> をしているので，<code>value</code> フィールドが最終的な結果となる． では <code>visited</code> はなんだろうか？ パーサーの実装を見てみる．</p>
<h3 id="組み込みのパーサー">組み込みのパーサー</h3>
<p>例えば <code>Url.string</code> を見てみる:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1">string <span class="fu">:</span> <span class="dt">Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb17-2" title="2">string <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-3" title="3">  custom <span class="st">&quot;STRING&quot;</span> <span class="dt">Just</span></a>
<a class="sourceLine" id="cb17-4" title="4"></a>
<a class="sourceLine" id="cb17-5" title="5">custom <span class="fu">:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> b) b</a>
<a class="sourceLine" id="cb17-6" title="6">custom tipe stringToSomething <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-7" title="7">  <span class="dt">Parser</span> <span class="fu">&lt;|</span> \{ visited, unvisited, params, frag, value } <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-8" title="8">    <span class="kw">case</span> unvisited <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-9" title="9">      [] <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-10" title="10">        []</a>
<a class="sourceLine" id="cb17-11" title="11"></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="ot">      next ::</span> rest <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-13" title="13">        <span class="kw">case</span> stringToSomething next <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-14" title="14">          <span class="dt">Just</span> nextValue <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-15" title="15">            [ <span class="dt">State</span> (<span class="ot">next ::</span> visited) rest params frag (value nextValue) ]</a>
<a class="sourceLine" id="cb17-16" title="16"></a>
<a class="sourceLine" id="cb17-17" title="17">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-18" title="18">            []</a></code></pre></div>
<p><code>custom</code> 関数の定義からわかるように，<code>unvisited</code> を入力にして <code>stringToSomething</code> というパーサーを咬ませて，その結果を <code>value</code> に追加し，元の文字列を <code>visited</code> に追加している． すなわち，<code>visited</code> はパースできたパスをためている． しかし，elm/url のコードを探しても <code>visited</code> が使われているところはないので，今の実装では無くても良いフィールドのはずだ(パースエラーをわかりやすくするときに使えそう)．</p>
<h2 id="section-2"></h2>
<p>ちなみに，クエリやフラグメントのパーサーは入力が違う(<code>unvisited</code> を使うのではない)だけだ:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">query <span class="fu">:</span> <span class="dt">Query.Parser</span> query <span class="ot">-&gt;</span> <span class="dt">Parser</span> (query <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb18-2" title="2">query (<span class="dt">Q.Parser</span> queryParser) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-3" title="3">  <span class="dt">Parser</span> <span class="fu">&lt;|</span> \{ visited, unvisited, params, frag, value } <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-4" title="4">    [ <span class="dt">State</span> visited unvisited params frag (value (queryParser params))</a>
<a class="sourceLine" id="cb18-5" title="5">    ]</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7">fragment <span class="fu">:</span> (<span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> fragment) <span class="ot">-&gt;</span> <span class="dt">Parser</span> (fragment <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb18-8" title="8">fragment toFrag <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-9" title="9">  <span class="dt">Parser</span> <span class="fu">&lt;|</span> \{ visited, unvisited, params, frag, value } <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-10" title="10">    [ <span class="dt">State</span> visited unvisited params frag (value (toFrag frag))</a>
<a class="sourceLine" id="cb18-11" title="11">    ]</a></code></pre></div>
<h3 id="コンビネーター">コンビネーター</h3>
<p>ちなみに，コンビネーター(<code>(&lt;/&gt;)</code>)の定義も見てみる:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">slash <span class="fu">:</span> <span class="dt">Parser</span> a b <span class="ot">-&gt;</span> <span class="dt">Parser</span> b c <span class="ot">-&gt;</span> <span class="dt">Parser</span> a c</a>
<a class="sourceLine" id="cb19-2" title="2">slash (<span class="dt">Parser</span> parseBefore) (<span class="dt">Parser</span> parseAfter) <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="dt">Parser</span> <span class="fu">&lt;|</span> \state <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-4" title="4">    List.concatMap parseAfter (parseBefore state)</a></code></pre></div>
<p><code>(&lt;/&gt;)</code> は <code>slash</code> のエイリアスになっている． <code>Parser</code> の型は <code>State a -&gt; [State b]</code> のラップなので，パーサーの連結は <code>concatMap</code> をするだけになっている．</p>
<p>また，<code>Url.map</code> も見てみる:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="fu">map</span> <span class="fu">:</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a b <span class="ot">-&gt;</span> <span class="dt">Parser</span> (b <span class="ot">-&gt;</span> c) c</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="fu">map</span> subValue (<span class="dt">Parser</span> parseArg) <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-3" title="3">  <span class="dt">Parser</span> <span class="fu">&lt;|</span> \{ visited, unvisited, params, frag, value } <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-4" title="4">    List.map (mapState value) <span class="fu">&lt;|</span> parseArg <span class="fu">&lt;|</span></a>
<a class="sourceLine" id="cb20-5" title="5">      <span class="dt">State</span> visited unvisited params frag subValue</a>
<a class="sourceLine" id="cb20-6" title="6"></a>
<a class="sourceLine" id="cb20-7" title="7">mapState <span class="fu">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">State</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> b</a>
<a class="sourceLine" id="cb20-8" title="8">mapState func { visited, unvisited, params, frag, value } <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-9" title="9">  <span class="dt">State</span> visited unvisited params frag (func value)</a></code></pre></div>
<p><code>map</code> を利用する場合，各型変数は次のようになっていることが多いだろう:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="co">-- parseArg : State (x -&gt; y) -&gt; List (State y)</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="co">-- value を identity と考えれば良い</span></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="fu">map</span> <span class="fu">:</span> (x <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> <span class="dt">Parser</span> (x <span class="ot">-&gt;</span> y) y <span class="ot">-&gt;</span> <span class="dt">Parser</span> (y <span class="ot">-&gt;</span> z) z</a>
<a class="sourceLine" id="cb21-4" title="4"><span class="fu">map</span> subValue (<span class="dt">Parser</span> parseArg) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-5" title="5">  <span class="dt">Parser</span> <span class="fu">&lt;|</span> \{ visited, unvisited, params, frag, value } <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-6" title="6">    List.map (mapState value) <span class="fu">&lt;|</span> parseArg <span class="fu">&lt;|</span></a>
<a class="sourceLine" id="cb21-7" title="7">      <span class="dt">State</span> visited unvisited params frag subValue</a></code></pre></div>
<p>こう考えれば <code>map</code> 関数の定義も読めるはずだ．</p>
<h2 id="結局">結局</h2>
<p>最後に <code>Parser a b</code> の各型変数は何を意味して，従来の <code>Parser a</code> 方式のパーサーではなぜダメなのかについて議論する(まぁあくまでも，実際に実装などを読んでの個人的な肌感なんですけど)．</p>
<h3 id="型変数の意味">型変数の意味</h3>
<p><code>Parser a b</code> の意味は <code>State a -&gt; List (State b)</code> からわかるように，パーサーの入力の状態に使われる型 <code>a</code> と出力の状態に使われる型 <code>b</code> である． ここで，「使われる」というのが肝で，<code>a</code> それ自体は入力ではない． 入力にせよ，出力にせよ，パーサーが行うのは状態 <code>State r1</code> から <code>State r2</code> への変換だ(ただしそれは失敗するかもしれないので <code>List</code> でラップされている)． <code>State r</code> にとって <code>r</code> は <strong>パースの最終結果</strong> を意味している(変化する状態の最終結果)．</p>
<p>なので <code>Parser a b</code> のパーサーがあった場合，このパーサーの最終結果は <code>b</code> であり，<code>a</code> は入力の状態が想定している最終結果である． ただし，<code>Parser (String -&gt; b) b</code> というパーサーの場合，<code>b</code> は <code>String</code> でも良く，このパーサーを <code>Url.parse</code> で実行する場合は <code>b = String</code> と推論される．</p>
<h3 id="parser-a-との違い"><code>Parser a</code> との違い</h3>
<p>大きな違いは <code>map</code> の振る舞いだ． <code>Parser a</code> の場合，レコード型 <code>Hoge = { hoge1 : Int, hoge2 : String }</code> のパーサーを記述するのには次のように書く:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1">intParser <span class="fu">:</span> <span class="dt">Parser</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb22-2" title="2">stringParser <span class="fu">:</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4">parser1 <span class="fu">:</span> <span class="dt">Parser</span> <span class="dt">Hoge</span></a>
<a class="sourceLine" id="cb22-5" title="5">parser1 <span class="fu">=</span> map2 <span class="dt">Hoge</span> intParser stringParser</a></code></pre></div>
<p>フィールドの個数が3つ4つと増えるたびに，<code>map3</code> <code>map4</code> と作る必要がある． また，parser1 を再利用して <code>Fuga = { hoge1 : Int, hoge2 : String, hoge3 : Int }</code> 型のパーサーを記述することはできない．</p>
<h2 id="section-3"></h2>
<p>対して <code>Parser a b</code> の場合は <code>(&lt;/&gt;)</code> を用いて <code>intParser</code> や <code>stringParser</code> をどんどん連結していき，最終的に <code>map</code> をする．</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1">parser0 <span class="fu">:</span> <span class="dt">Parser</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>  <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb23-2" title="2">parser0 <span class="fu">=</span> intParser <span class="fu">&lt;/&gt;</span> stringParser</a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4">parser1 <span class="fu">:</span> <span class="dt">Parser</span> (<span class="dt">Hoge</span> <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb23-5" title="5">parser1 <span class="fu">=</span> <span class="fu">map</span> <span class="dt">Hoge</span> parser0</a>
<a class="sourceLine" id="cb23-6" title="6"></a>
<a class="sourceLine" id="cb23-7" title="7">parser2 <span class="fu">:</span> <span class="dt">Parser</span> (<span class="dt">Fuga</span> <span class="ot">-&gt;</span> a) a</a>
<a class="sourceLine" id="cb23-8" title="8">parser2 <span class="fu">=</span> <span class="fu">map</span> <span class="dt">Fuga</span> (parser0 <span class="fu">&lt;/&gt;</span> intParser)</a></code></pre></div>
<p>すなわち利点は:</p>
<ol type="1">
<li>引数ごとの <code>map</code> がいらない</li>
<li><code>(&lt;/&gt;)</code> で繋いだパーサーの再利用性が高い</li>
</ol>
<h3 id="applicative-スタイル">Applicative スタイル</h3>
<p>Elm で一般的かどうかはわからないが，Haskell では一般的な Applicative スタイルというのがある． ちなみに elm/url を Applicative スタイルにしたパッケージは GitHub に揚げてある．</p>
<ul>
<li><a href="https://github.com/matsubara0507/elm-url-applicative">matsubara0507/elm-url-applicative - GitHub</a></li>
</ul>
<p>Applicative スタイルとは，次のようなコンビネーターを使って関数を構築する:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="fu">map</span>   <span class="fu">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a>
<a class="sourceLine" id="cb24-2" title="2">apply <span class="fu">:</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a></code></pre></div>
<p>ちなみに，今回の話の流れ上 <code>Parser</code> を用いたが，ここが <code>Maybe</code> だろうと <code>List</code> だろうと同じに扱える． この場合，パーサーの構築は次のようになる:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1">parser2 <span class="fu">:</span> <span class="dt">Parser</span> <span class="dt">Fuga</span></a>
<a class="sourceLine" id="cb25-2" title="2">parser2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-3" title="3">  apply (apply (<span class="fu">map</span> <span class="dt">Fuga</span> intParser) stringParser) intParser</a></code></pre></div>
<p>Elm 的にはパイプで連結できるので <code>app</code> の引数の順番を変えた方がいいかもしれない．</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1">andApply <span class="fu">:</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3">parser2 <span class="fu">:</span> <span class="dt">Parser</span> <span class="dt">Fuga</span></a>
<a class="sourceLine" id="cb26-4" title="4">parser2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-5" title="5">  <span class="fu">map</span> <span class="dt">Fuga</span> intParser</a>
<a class="sourceLine" id="cb26-6" title="6">    <span class="fu">|&gt;</span> andApply stringParser</a>
<a class="sourceLine" id="cb26-7" title="7">    <span class="fu">|&gt;</span> andApply intParser</a></code></pre></div>
<p>一見問題なさそうだ． しかし，今回でいう <code>Url.s : String -&gt; Parser a a</code> のような入力を消費するだけで結果に反映しないパーサーがあるとうまく行かない． <code>ignore</code> のようなコンビネーターが必要になる(ちなみに Haskell の Applicative にはもちろんある):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1">s <span class="fu">:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</a>
<a class="sourceLine" id="cb27-2" title="2">ignore <span class="fu">:</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb27-3" title="3"></a>
<a class="sourceLine" id="cb27-4" title="4">parser3 <span class="fu">:</span> <span class="dt">Parser</span> <span class="dt">Fuga</span></a>
<a class="sourceLine" id="cb27-5" title="5">parser3 <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" title="6">  <span class="fu">map</span> <span class="dt">Fuga</span> intParser</a>
<a class="sourceLine" id="cb27-7" title="7">    <span class="fu">|&gt;</span> andApply stringParser</a>
<a class="sourceLine" id="cb27-8" title="8">    <span class="fu">|&gt;</span> ignore (s <span class="st">&quot;fuga&quot;</span>)</a>
<a class="sourceLine" id="cb27-9" title="9">    <span class="fu">|&gt;</span> andApply intParser</a></code></pre></div>
<p>ちなみに，再利用の方もうまくいく:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1">parser0 <span class="fu">:</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb28-2" title="2">parser0 f <span class="fu">=</span> <span class="fu">map</span> f intParser <span class="fu">|&gt;</span> andApply stringParser</a>
<a class="sourceLine" id="cb28-3" title="3"></a>
<a class="sourceLine" id="cb28-4" title="4">parser1 <span class="fu">:</span> <span class="dt">Parser</span> <span class="dt">Hoge</span></a>
<a class="sourceLine" id="cb28-5" title="5">parser1 <span class="fu">=</span> parser0 <span class="dt">Hoge</span></a>
<a class="sourceLine" id="cb28-6" title="6"></a>
<a class="sourceLine" id="cb28-7" title="7">parser2 <span class="fu">:</span> <span class="dt">Parser</span> <span class="dt">Fuga</span></a>
<a class="sourceLine" id="cb28-8" title="8">parser2 <span class="fu">=</span> parser0 <span class="dt">Fuga</span> <span class="fu">|&gt;</span> andApply intParser</a></code></pre></div>
<p>これで <code>Parser a b</code> の場合と同等の能力を持つはずだ． すなわち，<code>Parser a b</code> と Applicative スタイルは見た目以上の差異はない（はず）．</p>
<h1 id="おしまい">おしまい</h1>
<p>Elm には珍しく型がテクニカルなパッケージということで，細かく中を読んでみました． 色々試した結果，Haskell の Applicative スタイルの見た目を変えてるだけのようでした． まだ，エヴァンさんが参考にしたという記事をちゃんと読んでないので，もしかしたら間違っているかも． 時間ができたら読んでみます．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Dhall を試して物足りない部分を補うツールを自作した</title>
    <link href="https://matsubara0507.github.io/posts/2018-12-05-create-dhall-ex.html" />
    <id>https://matsubara0507.github.io/posts/2018-12-05-create-dhall-ex.html</id>
    <published>2018-12-05T00:00:00Z</published>
    <updated>2018-12-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Dhall を試して物足りない部分を補うツールを自作した</h1>
    <p class="post-meta">
      <time datetime="2018-12-05" itemprop="datePublished">
        Dec 5, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/Dhall.html">Dhall</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>本稿は <a href="https://qiita.com/advent-calendar/2018/haskell">Haskell Advent Calendar 2018</a> 5日目の記事です．</p>
<p>Haskell Day 2018 の発表をきっかけに，兼ねてから気になっていた Dhall を試した． いくつかツールが欲しくなったので作りましたっていう話です．</p>
<p>作ったものはこれ:</p>
<ul>
<li><a href="https://github.com/matsubara0507/yaml-to-dhall">matsubara0507/yaml-to-dhall - GitHub</a></li>
<li><a href="https://github.com/matsubara0507/dhall-ex">matsubara0507/dhall-ex - GitHub</a></li>
</ul>
<p>ちなみに，今回作ったツールは現状の stack の stable resolver にある v1.5.1 を利用している．</p>
<h2 id="dhall">Dhall</h2>
<p><a href="https://github.com/dhall-lang/dhall-lang">Dhall</a> は静的型付けされた設定記述言語である． 多くの場合，プログラミング言語やアプリケーションに使われる設定ファイルには JSON や YAML が利用されている． プログラミング言語のビルドシステムのような設定ファイル一つ程度なら問題ないが，Kubernetes や Ansible のような膨大な設定ファイルが依存しあう場合，静的型付けプログラミング言語のようにコンパイルによる型検査を導入したくなるだろう． Dhall はそのための言語であり，また便利な関数が用意されているため，非常に再利用性の高い設定ファイルを記述できる．</p>
<h3 id="例">例:</h3>
<p>Dhall は静的片付け言語なので，まずは型を定義しよう:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" title="1">$ cat ./User.dhall</a>
<a class="sourceLine" id="cb1-2" title="2">{ homeDirectory : Text, privateKeyFile : Text, publicKeyFile : Text }</a></code></pre></div>
<p>このユーザ型の値はユーザ名から一意に生成されることは容易に想像できるだろう:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb2-1" title="1">$ cat ./makeUser.dhall</a>
<a class="sourceLine" id="cb2-2" title="2">  \(user_name : Text)</a>
<a class="sourceLine" id="cb2-3" title="3">-&gt;    <span class="kw">let</span> homeDirectory = <span class="st">&quot;/home/${user_name}&quot;</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="kw">in</span>  <span class="kw">let</span> privateKeyFile = <span class="st">&quot;${homeDirectory}/id_rsa&quot;</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="kw">in</span>  <span class="kw">let</span> publicKeyFile = <span class="st">&quot;${privateKeyFile}.pub&quot;</span></a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="kw">in</span>    { homeDirectory =</a>
<a class="sourceLine" id="cb2-10" title="10">            homeDirectory</a>
<a class="sourceLine" id="cb2-11" title="11">        , privateKeyFile =</a>
<a class="sourceLine" id="cb2-12" title="12">            privateKeyFile</a>
<a class="sourceLine" id="cb2-13" title="13">        , publicKeyFile =</a>
<a class="sourceLine" id="cb2-14" title="14">            publicKeyFile</a>
<a class="sourceLine" id="cb2-15" title="15">        }</a>
<a class="sourceLine" id="cb2-16" title="16">      : ./User.dhall</a></code></pre></div>
<p>この <code>./makeUser.dhall</code> は任意の文字列を与えると，それをユーザ名として <code>./User.dhall</code> 型の値を生成してくれる． さらに，高階関数を使って複数のユーザに対し一気に適用してみよう．</p>
<pre class="dhall"><code>$ cat ./users.dhall
let User = ./User.dhall

in  let map =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/0a7f596d03b3ea760a96a8e03935f4baa64274e1/Prelude/List/map

in  map Text User ./makeUser.dhall [ &quot;alice&quot;, &quot;bob&quot;, &quot;curry&quot; ] : List User</code></pre>
<p><code>map</code> には <a href="https://github.com/dhall-lang/dhall-lang/blob/master/Prelude/List/map">dhall のリポジトリにある標準パッケージの関数</a>を直接インポートしている． <code>map</code> の型は <code>∀(a : Type) → ∀(b : Type) → (a → b) → List a → List b</code> となっている． 基本的に Dhall で多相な高階関数を利用するときは，引数から直接型を与えてあげる必要がある．</p>
<p>さて，これを dhall でビルドすると次のような結果を得る:</p>
<pre class="dhall"><code>$ dhall &lt;&lt;&lt; ./users.dhall
[ { homeDirectory =
      &quot;/home/alice&quot;
  , privateKeyFile =
      &quot;/home/alice/id_rsa&quot;
  , publicKeyFile =
      &quot;/home/alice/id_rsa.pub&quot;
  }
, { homeDirectory =
      &quot;/home/bob&quot;
  , privateKeyFile =
      &quot;/home/bob/id_rsa&quot;
  , publicKeyFile =
      &quot;/home/bob/id_rsa.pub&quot;
  }
, { homeDirectory =
      &quot;/home/curry&quot;
  , privateKeyFile =
      &quot;/home/curry/id_rsa&quot;
  , publicKeyFile =
      &quot;/home/curry/id_rsa.pub&quot;
  }
]</code></pre>
<p>これは次のようなYAMLに対応し，<code>dhall-to-yaml</code> などのツールで変換可能だ:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">-</span> <span class="fu">privateKeyFile:</span><span class="at"> /home/alice/id_rsa</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">publicKeyFile:</span><span class="at"> /home/alice/id_rsa.pub</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="fu">homeDirectory:</span><span class="at"> /home/alice</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">-</span> <span class="fu">privateKeyFile:</span><span class="at"> /home/bob/id_rsa</span></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="fu">publicKeyFile:</span><span class="at"> /home/bob/id_rsa.pub</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="fu">homeDirectory:</span><span class="at"> /home/bob</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">-</span> <span class="fu">privateKeyFile:</span><span class="at"> /home/curry/id_rsa</span></a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="fu">publicKeyFile:</span><span class="at"> /home/curry/id_rsa.pub</span></a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="fu">homeDirectory:</span><span class="at"> /home/curry</span></a></code></pre></div>
<h2 id="section"></h2>
<p>また，ざっくりとしたイメージを得るには、先日あった <a href="https://wiki.haskell.jp/Workshop/HaskellDay/2018">Haskell Day 2018</a> での<a href="https://speakerdeck.com/syocy/dhall-haskellfalsexin-tanakiraapuri">発表資料</a>がわかりやすくてオススメ．</p>
<h3 id="使ってみて思うところ">使ってみて思うところ</h3>
<p>もしかしたら最新のバージョンであれば改善しているものもあるかもしれない．</p>
<ul>
<li>基本的な高階関数があり便利
<ul>
<li>map,fold,filter など</li>
</ul></li>
<li>普通のプログラミングのように式を再利用できる</li>
<li>型推論がザコい
<ul>
<li>パラメトリック多相を挟むとダメみたいですね</li>
</ul></li>
<li>結構ビルドエラーがエスパー
<ul>
<li>慣れの問題か？</li>
</ul></li>
<li>YAML のいわゆる連想配列への変換ができない</li>
<li>日本語が化ける ;;
<ul>
<li>まぁ原因はわかるので最新でも治ってなかったらPRしてみるか</li>
</ul></li>
</ul>
<h2 id="何に導入したか">何に導入したか</h2>
<p>弊社が企画してる学生向けの競技型イベントに関するシステムの設定ファイルを Dhall に置き換えてみた． そのシステムは，インフラ・スコアボード・デプロイツールの3つのリポジトリに別れており，ところどころ重複した設定が3つのリポジトリに存在する． そこで，設定用のリポジトリを作って，そこに Dhall で記述した設定を置き，そこから各リポジトリに設定を撒くような仕組みを考えることにした．</p>
<p><img src="/assets/create-dhall-ex/system-with-dhall.png" /></p>
<p>別に Dhall にしたからといって劇的に何かがよくなるわけでは無いのだが，ちょうど良いサンドボックスがあったのでイロイロと試してみる，というのが本音です（笑）</p>
<h2 id="yaml-to-dhall">yaml-to-dhall</h2>
<p>最初の方はせっせと手作業で変換していたが，何個かやって変換の仕方の勘所がわかって来た． そうなると後は作業でしか無いので，なんとかして大量にある設定ファイルを一括変換したい．</p>
<p>調べた限り，YAML から Dhall に変換するプログラムは無さそう(逆はもちろんあるけど)． なのですっごい雑なものを作った．</p>
<ul>
<li><a href="https://github.com/matsubara0507/yaml-to-dhall">matsubara0507/yaml-to-dhall - GitHub</a></li>
</ul>
<p>これは極めて単純なことしかできない． 数値は全て Float に変換されるし，Optional や空リストの書き方が間違っている． とりあえず変換して，手元のエディタで置換すればいいかなと思ったので雑なままである．</p>
<p>時間ができたらそのうち直すかも．</p>
<h2 id="dhall-ex">dhall-ex</h2>
<p>前述した通り，一組の設定ファイル群から複数のリポジトリの設定ファイルを生成したかったのでその仕組みを作った． dhall-ex は次のような設定ファイルを記述する:</p>
<pre class="dhall"><code>{ GH_TOKEN =
      [ &quot;matsubara0507:XXXX&quot; ] : Optional Text
  , root =
      &quot;configs&quot;
  , exports =
      [ { name =
            &quot;deploy-tool&quot;
        , repo =
            [ &quot;git-challenge/deploy-tool&quot; ] : Optional Text
        , paths =
            [ &quot;settings/orgs/orgs.yml&quot;
            , &quot;settings/orgs/review.yml&quot;
            ...
            ]
        }
      ...
      ]
}</code></pre>
<p>別にどっちでもよかったのだが，せっかくなので dhall-ex の設定ファイルも Dhall で記述するようにした． なので，具体例より<a href="https://github.com/matsubara0507/dhall-ex/blob/master/dhall/dhall-ex-type.dhall">型</a>を見た方が早いだろう．</p>
<pre class="dhall"><code>let Export = { name : Text, repo : Optional Text, paths : List Text }
in  { GH_TOKEN : Optional Text, root : Text, exports : List Export }</code></pre>
<p><code>root</code> は設定ファイル群を置くパスで，<code>exports</code> が設定ファイル群の更新先のリポジトリなどの情報だ． <code>repo</code> で GitHub リポジトリを指定し，<code>paths</code> で関連する設定ファイルを列挙する． 例の場合 <code>./config/settings/orgs/orgs.yml.dhall</code> を <code>./.dhall-ex/git-challenge/deploy-tool/settings/orgs/orgs.yml</code> に dhall でビルドする．</p>
<p>ちなみに Dhall のバージョンが古いので <code>Optional</code> がリストのリテラルを利用しているが，最新の Dhall には <code>Some</code> と <code>None</code> があるはず．</p>
<h3 id="機能">機能</h3>
<p>現状はこんな感じ:</p>
<pre><code>$ dhall-ex --help
dhall-ex - cli tool to support dhall

Usage: dhall-ex [-v|--verbose] [-c|--config PATH] [--only NAME] COMMAND
                [--version]

Available options:
  -v,--verbose             Enable verbose mode: verbosity level &quot;debug&quot;
  -c,--config PATH         Configuration file
  --only NAME              Exec subcommand only NAME in config
  --version                Show version
  -h,--help                Show this help text

Available commands:
  sort                     Sort record keys in dhall file
  echo                     Echo TEXT
  init                     Init dhall-ex work directory
  build                    Build Dhall file to YAML or JSON
  deploy                   Deploy builded config file to remote repository
  checkout                 Checkout repository in dhall workspace
  pull                     Pull repository in dhall workspace</code></pre>
<p><code>echo</code> は設定が正しく読み取れるかどうかにだけ使う雑機能． <code>sort</code> レコードのフィールドの順番を型に合わせて並び替えてくれるコマンドだ． 前述した <code>yaml-to-dhall</code> などを使った後に使った(並び変える必要はないんだけど，なんか読みやすいように)．</p>
<p><code>init</code> でリポジトリなどの初期化をし，<code>build</code> で設定ファイルを変換し，<code>deploy</code> でコミットとプッシュを行ってくれる． <code>checkout</code> や <code>pull</code> はただの git コマンドのラッパーだ．</p>
<p>また，<code>--only deploy-tool</code> などとすることでコマンドの実行を特定のリポジトリに限定できる．</p>
<h3 id="実装">実装</h3>
<p>実は内部実装はそこまで難しいことをしていない． Dhall のファイルを読み込み，ビルドし，それを dhall-ex の設定ファイルに則って出力するだけだ． <code>build</code> 以外のコマンドは <a href="http://hackage.haskell.org/package/shelly"><code>shelly</code></a> を使ってシェルスクリプトもどきを実行している．</p>
<h3 id="todo">ToDo</h3>
<ul>
<li>例外処理が雑なのを直す
<ul>
<li>だいたいこの部分が残る（笑）</li>
</ul></li>
<li>任意のコマンドを各リポジトリのワークスペースで実行できるようにする
<ul>
<li>なんか <code>git status</code> とか <code>git branch</code> とかしたい</li>
</ul></li>
<li>並行処理</li>
</ul>
<h1 id="おしまい">おしまい</h1>
<p>随分雑な記事になってしまった．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Stack の Docker Integration とイメージの自動更新</title>
    <link href="https://matsubara0507.github.io/posts/2018-12-02-stack-docker-travici.html" />
    <id>https://matsubara0507.github.io/posts/2018-12-02-stack-docker-travici.html</id>
    <published>2018-12-02T00:00:00Z</published>
    <updated>2018-12-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Stack の Docker Integration とイメージの自動更新</h1>
    <p class="post-meta">
      <time datetime="2018-12-02" itemprop="datePublished">
        Dec 2, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/Docker.html">Docker</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>本稿は <a href="https://qiita.com/advent-calendar/2018/haskell2">Haskell (その2) Advent Calendar 2018</a> 2日目の記事です．</p>
<p>最近よく CLI ツールを作るんですが，Haskell Stack を持ってなくても CLI ツールが使えるように，ツールを Docker イメージ化するようにしています． その流れを書き留めておこうというの本稿の趣旨です．</p>
<p>ちなみに，以下のリポジトリで実際に試しています．</p>
<ul>
<li><a href="https://github.com/matsubara0507/mdium">matsubara0507/mdium - GitHub</a></li>
<li><a href="https://github.com/matsubara0507/dhall-ex">matsubara0507/dhall-ex - GitHub</a></li>
</ul>
<h2 id="docker-integration">Docker Integration</h2>
<p>Haskell のビルドツール Stack には Dcoker Integration という機能がある（現在最新の安定版である v1.9.1 を想定しています）．</p>
<ul>
<li><a href="https://docs.haskellstack.org/en/v1.9.1/docker_integration/">Docker integration - The Haskell Tool Stack</a></li>
<li><a href="https://docs.haskellstack.org/en/v1.9.1/yaml_configuration/#image">Image - Yaml configuration - The Haskell Tool Stack</a></li>
</ul>
<p>Docker Integration として，ざっくりと次のような機能がある．</p>
<ol type="1">
<li>指定したイメージのコンテナでビルド・実行をする</li>
<li>ビルドした実行ファイルを含めた Docker イメージの作成</li>
</ol>
<p>(2 は正確には Docker Integration とは呼ばない)</p>
<p>ちなみに，Stack はワークスペース内の <code>.stack-work</code> の中に中間結果などを含むビルド結果をバージョンやビルド環境ごとに保存する． そして，<code>--docker</code> オプションでビルドすることで，ローカルではなく Docker のコンテナ内でビルドをしたり，生成したプログラムを実行したりできる． しかも，コンテナ内でビルドした場合でもビルド結果をローカルの <code>.stack-work</code> に保存するのだ．</p>
<h2 id="docker-イメージ内でビルド">Docker イメージ内でビルド</h2>
<p>まず stack.yaml に次のような設定を追加する．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">docker:</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="fu">enable:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">repo:</span><span class="at"> </span><span class="st">&quot;fpco/stack-build&quot;</span></a></code></pre></div>
<p><code>enable: true</code> にすると，以降の <code>--docker</code> オプションを省けるが，逆に普通にローカルでビルドしたい場合は <code>--no-docker</code> オプションが必要になる． <code>repo</code> でビルドするイメージを指定する． [<code>fpco/stack-build</code> はこれだ]（https://hub.docker.com/r/fpco/stack-build/）． stack.yaml の <code>resolver</code> からイメージタグを自動的に選んでくれるはずだ．</p>
<p>あとは次のコマンドでビルドできる．</p>
<pre><code># repo で指定した docker image の pull
$ stack docker pull

# docker コンテナ内でビルド
$ stack build --docker</code></pre>
<p>他にも細かい設定がかけるが割愛（上述したドキュメントを参照してください）．</p>
<h2 id="docker-イメージを作る">Docker イメージを作る</h2>
<p>stack.yaml に次の設定を追加する．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">image:</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="fu">container:</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="fu">name:</span><span class="at"> hoge</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="fu">base:</span><span class="at"> fpco/ubuntu-with-libgmp</span></a></code></pre></div>
<p><code>image.container.name</code> は生成する Docker イメージの名前で，<code>image.container.base</code> は生成する Docker イメージに使うベースイメージだ． ベースイメージは <code>docker.repo</code> などで指定したイメージのOSとあってさえいれば良い（ちなみに <code>fpco/stack-build</code> は <code>ubuntu:16.04</code>）． やってくれることは簡単で， <code>stack build --docker</code> で作成した実行ファイルをベースイメージの <code>local/bin</code> などにコピーするだけだ． なので，もし静的リンクしていない場合はリンクが含まれるベースイメージを指定すると良い(<a href="https://hub.docker.com/r/fpco/ubuntu-with-libgmp/"><code>fpco/ubuntu-with-libgmp</code></a> はそのために使っている)．</p>
<p>あとは次のコマンドでイメージの作成ができる．</p>
<pre><code># repo で指定した docker image の pull
$ stack --docker image container</code></pre>
<p><code>--docker</code> を指定しないとローカルでビルドした実行ファイルをコピーして，生成したイメージのコンテナで実行できなくなるので注意してください（もちろんローカルが ubuntu なら問題ないけど）． あと， stack によるイメージ作成方法では他に Dockerfile の <code>add</code> っぽいことと <code>entrypoints</code> っぽいことができるが，それ以上のことはできない． もっと複雑な設定をしたい場合は，生成したイメージをベースイメージにした Dockerfile を書いたり， Docker のマルチステージビルドを使って設定を上書きしたりするとと良いだろう．</p>
<h2 id="travisci-docker-hub">TravisCI + Docker Hub</h2>
<p>Docker Integration の欠点は Docker Hub の Automated build が使えない点だ． そこで，TravisCI を使って自動ビルドし，Docker Hub にプッシュするようにした． 次のような設定を travis.yml に書くと良いだろう．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">-</span> <span class="fu">stage:</span><span class="at"> push docker image</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">if:</span><span class="at"> branch = master</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="fu">script:</span></a>
<a class="sourceLine" id="cb5-4" title="4">   <span class="kw">-</span> stack docker pull</a>
<a class="sourceLine" id="cb5-5" title="5">   <span class="kw">-</span> stack --docker image container</a>
<a class="sourceLine" id="cb5-6" title="6">   <span class="kw">-</span> echo <span class="st">&quot;$DOCKER_PASSWORD&quot;</span> | docker login -u <span class="st">&quot;$DOCKER_USERNAME&quot;</span> --password-stdin</a>
<a class="sourceLine" id="cb5-7" title="7">   <span class="kw">-</span> docker push $TRAVIS_REPO_SLUG</a></code></pre></div>
<p>実は <code>stack --docker image container</code> でビルドまでしてくれる． Docker Hub には Token のようなものはないので <code>--password-stdin</code> とパイプを使って普通のパスワードでログインする． あとは <code>image.container.name</code> で指定する名前を <code>hoge</code> ではなく <code>user_name/repo_name</code> としておけば良い． もちろんこれは GitHub と Docker Hub のユーザ名が同じ場合にしか使えない． 違う場合は直接書いてね．</p>
<h1 id="おしまい">おしまい</h1>
<p>この方法なら実行ファイルしか入ってないイメージが出来上がるので軽いし， stack のビルド遅すぎて利用者側は厳しい問題も緩和するので最近のマイブームです．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell Day 2018 に参加してきた</title>
    <link href="https://matsubara0507.github.io/posts/2018-11-17-join-haskell-day-2018.html" />
    <id>https://matsubara0507.github.io/posts/2018-11-17-join-haskell-day-2018.html</id>
    <published>2018-11-17T00:00:00Z</published>
    <updated>2018-11-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell Day 2018 に参加してきた</h1>
    <p class="post-meta">
      <time datetime="2018-11-17" itemprop="datePublished">
        Nov 17, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>11月10日にあった「<a href="https://haskell-jp.connpass.com/event/92617/">Haskell Day 2018</a>」に参加してきたのでメモ書きです．</p>
<h2 id="午前中-ハンズオン">午前中 : ハンズオン</h2>
<p><a href="https://github.com/igrep">igrep</a> 氏が中心になって作成した <a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell"><code>makeMistakesToLearnHaskell</code></a> を使ったハンズオン． ぼくも少しだけコミットした．</p>
<p>当日の様子は，みなさんかなり黙々と作業してて静かだったが，Twitter 上で質問している人がチラチラいた． それらの Twitter の様子などをみてリアルタイムに修正を行なっていたのはすごい．</p>
<h2 id="午後">午後</h2>
<p>そのうちログミーが公開されるそうなので，概要と感想だけ．</p>
<h3 id="haskellを導入した話hrrの話">Haskellを導入した話/HRRの話</h3>
<p><a href="https://htmlpreview.github.io/?https://github.com/khibino/haskell-day-2018/blob/master/presentation.html">発表資料はこちら</a>．</p>
<p>10年近く職業 Haskeller をやっていた <a href="https://github.com/khibino">khibino</a> 氏が，当時 Haskell を導入するに至った話と，彼が作った <a href="https://hackage.haskell.org/package/relational-record">HRR</a> というライブラリの紹介 Perl に変わるグルー言語を求めて Haskell に行き着いたそうだ． 「GHC6.8 ですよ，GHC8.6 じゃなく，すごく無いですか？」すごい． HRRは面白そうだけど，使うタイミングがないや．</p>
<h3 id="servantで実現する高速かつ安全なapi">Servantで実現する高速かつ安全なAPI</h3>
<p><a href="https://speakerdeck.com/daishi/servantdexing-uan-quan-katugao-su-naapikai-fa">発表資料はこちら</a>．</p>
<p>同様に職業 Haskeller の <a href="https://github.com/nakaji-dayo">nakaji</a> 氏の発表． <a href="https://haskell-servant.github.io/">Servant</a> という型レベルに RSETful API を定義できるパッケージを実際にどのように使っているかという話． Servant は僕もよく使う． 「実際に依存してるパッケージの紹介」や「実運用する上で困ったこと」などもあって興味深い．</p>
<h3 id="並列並行言語haskell">並列並行言語Haskell</h3>
<p><a href="https://speakerdeck.com/syocy/bing-lie-bing-xing-yan-yu-haskell">発表資料はこちら</a>．</p>
<p>次のも含めて2本連続で <a href="https://github.com/syocy">syocy</a> 氏の発表． Haskell における並行・並列プログラミングについての紹介． 並行・並列プログラミングとして最近は Go・Elixir/Erlang・Rust などが注目されているが，Haskell は20年近く前から並行・並列に対して意識してる． おまけとして，ツールの話や並行並列系パッケージの話があって勉強になる． 余談として「<a href="https://a-tour-of-go-in-haskell.syocy.net/ja_JP/index.html">A Tour of Go in Haskell</a>」というのを作ったが，英語版も作ったところめっさ PR が来たという話をしてくれた． やっぱ分母の大きい自然言語は強い．</p>
<h3 id="dhall-haskellの新たなキラーアプリ">Dhall: Haskellの新たなキラーアプリ</h3>
<p><a href="https://speakerdeck.com/syocy/dhall-haskellfalsexin-tanakiraapuri">発表資料はこちら</a>．</p>
<p>個人的に今回一番面白かった． <a href="https://github.com/dhall-lang/dhall-lang">Dhall</a> というアプリケーションの紹介． Dhall は設定ファイルを記述するための DSL である． 設定ファイルの多くは YAML や JSON などで書かれるが，複数の YAML が複雑な依存関係を持っている場合(k8sとか)は静的解析したいよね？ しかし逆に「設定ファイルとしての領分」を守って欲しいという要求もある(汎用プログラミング言語としての役割はいらない)． そこで Dhall です！って感じの発表だった． 最後の導入事例として，自社の設定ファイル群を書き換えた話も面白かった．</p>
<h3 id="semigroupとはmonoidとは環とは">Semigroupとは？Monoidとは？環とは？</h3>
<p><a href="https://aiya000.github.io/Maid/haskell-day-2018-algebra/">発表資料はこちら</a>．</p>
<p><a href="https://github.com/aiya000">aiya</a> 氏の発表． 群や環などの代数的構造についての話． ステップバイステップに要件が増えていくのでわかりやすい説明だった．</p>
<p>ちなみに個人的な肌感として，このような数学的な素養がないと Haskell プログラミングができないかというと，そうでもないと思う． 僕自身は教養としてそのあたりを知ってはいるので微妙なところだが，普段 Haskell プログラミングしてる時に意識してはいないはず． ただ，いくつかの言語機能やライブラリは数学や論理学など学術的なバックグランドを持ってることがある． そのような場合は「なぜこのような仕様なのか」「どうしてこのような仕組みでうまくいくかのか」などは，学術論文にしか書いてないことが多い． そのため，そういう機能やライブラリの仕組みを <strong>ちゃんと</strong> 追おうとする場合は数学的素養がないと厳しいかもしれない．</p>
<h3 id="haskellで作るcli">Haskellで作るCLI</h3>
<p>僕の発表．後述します．</p>
<h3 id="gloss-動かして遊んで学ぶhaskell">gloss: 動かして遊んで学ぶHaskell</h3>
<p><a href="https://qiita.com/lotz/items/bdb04c771efc8919b79c">発表資料はこちら</a>．</p>
<p><a href="https://github.com/lotz84">lotz</a> 氏の発表． Haskell を勉強したあと何するかシリーズ，GUI 編． 作りたいものがはっきりないときは <a href="http://hackage.haskell.org/package/gloss">gloss</a> で振り子やライフゲームを作って遊んでみよう，という感じ． 僕自身はあんまり GUI に関心がないけど，実際に作りたいものがない場合はこういうので色々出力して手をうごしてみるのは正しい． 時間あるときになんか変なことできないか調べてみようかな．</p>
<h3 id="liszt-あるいは永続データ構造を真に永続させる方法">Liszt あるいは永続データ構造を真に永続させる方法</h3>
<p><a href="https://shared-assets.adobe.com/link/353213c2-281a-4a53-6cff-a52bff1314c1">発表資料はこちら</a>．</p>
<p>僕が愛用している extensible というライブラリの作者，<a href="https://github.com/fumieval">fumieval</a> 氏の発表． <a href="https://github.com/fumieval/liszt">liszt</a> を作り始めていたことは知っていたので気になっていた． Liszt は Kafka のような大量のデータを収集・配信するためのプログラムだそうだ(名前も <a href="https://ja.wikipedia.org/wiki/フランツ・カフカ">Franz Kafka</a> に対抗して <a href="https://ja.wikipedia.org/wiki/フランツ・リスト">Franz Liszt</a> らしい)． 内部のデータ構造として Skew binary random access list を要素としてもつ 2-3 木 を用いている． このあたりの詳しい話は「<a href="https://asciidwango.jp/post/160831986220/純粋関数型データ構造">純粋関数型データ構造</a>」を読むと良いとのこと(本の名前が上がった瞬間「ですよね〜」となってたw)．</p>
<h2 id="自分の話">自分の話</h2>
<p>Haskell で CLI を作るうえでの小話をした。 スライドはこれ． <iframe src="//www.slideshare.net/slideshow/embed_code/key/FQE1QxbCST8kYi" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe></p>
<p>実はどれも，既に記事におこしたことのあるネタだった．</p>
<ol type="1">
<li>コマンドライン引数
<ul>
<li><code>getArgs</code>・<code>GetOpt</code>・<code>optparse-applicative</code> について紹介</li>
<li><code>optparse-applicative</code> + <code>extensible</code> でサブコマンドも網羅性をチェック</li>
<li>「<a href="2018-05-10-make-cli-with-haskell-in-2018">オレ的 Haskell で CLI を作る方法 2018</a>」</li>
</ul></li>
<li>Alt. Prelude
<ul>
<li>Prelude 微妙だなって思ったら Alt. Prelude なパッケージを使ってみようという話</li>
<li>具体的には愛用している RIO を紹介した</li>
<li>「<a href="2018-04-13-try-rio-1">rio ライブラリを試す その１</a>」</li>
</ul></li>
<li>Stack Template
<ul>
<li>よく使う依存パッケージやアプリのインターフェースの書き方がパターン化してきたら Stack Template 化しようという話</li>
<li>Stack 1.9 から GitHub にあるテンプレートを参照できるようになった</li>
<li>GitHub にあるテンプレートを出力する stack-tpls コマンドの紹介</li>
<li>「<a href="2018-10-14-collect-stack-templates">stack-templates を集める with GraphQL</a>」</li>
</ul></li>
</ol>
<p>Haskell を知ってる人にとってはあんまり面白くない話題だったかもしれないが，まぁまぁ(発言が)ウケていたのでよかった(?)．</p>
<h2 id="おしまい">おしまい</h2>
<p>初心者がわかりやすく，玄人にもウケるネタってなんだろうね． 来年もやるかもしれないから考えておこう．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Markdownで書いたテキストをMediumへポストする(mdium)</title>
    <link href="https://matsubara0507.github.io/posts/2018-11-04-create-mdium.html" />
    <id>https://matsubara0507.github.io/posts/2018-11-04-create-mdium.html</id>
    <published>2018-11-04T00:00:00Z</published>
    <updated>2018-11-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Markdownで書いたテキストをMediumへポストする(mdium)</h1>
    <p class="post-meta">
      <time datetime="2018-11-04" itemprop="datePublished">
        Nov 4, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/application.html">application</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>完全な二番煎じです。</p>
<ul>
<li><a href="https://namaraii.com/markdownで書いたテキストをmediumへポストする-md2mid-60c6ff9efde">Markdownで書いたテキストをMediumへポストする(md2mid) – namaraii.com</a></li>
</ul>
<p>上記記事は，Go 言語で作った「Markdownで書いたテキストをMediumへポストする」CLIツールです． 弊社の技術記事置き場が Medium だったので，なんとか，ここのように Markdown で書けないかと調べていたら上記記事が出て来ました． もっといいのできないかなと車輪の再発明してみたけど，正直大して変わらなかったと思います．</p>
<h2 id="作ったもの">作ったもの</h2>
<p>md2mid と同様に Markdown で書いた記事を Medium に送信する CLI ツールを作った． 言わずもがな Haskell 製．</p>
<ul>
<li><a href="https://github.com/matsubara0507/mdium">matsubara0507/mdium - GitHub</a></li>
</ul>
<p>違いがあるとすれば:</p>
<ul>
<li>Haskell 製（しつこい）</li>
<li>環境変数を使ったトークンの管理</li>
<li><a href="https://hub.docker.com/r/matsubara0507/mdium/">Docker Image</a> 化してる</li>
</ul>
<h2 id="使い方">使い方</h2>
<p>まず CLI ツールをインストールするには，リポジトリをクローンして Haskell Stack で直接ビルド・インストールする:</p>
<pre><code>$ git clone https://github.com/matsubara0507/mdium.git
$ cd mdium
$ stack install mdium</code></pre>
<p>あるいは，Docker Image をプルしてくる:</p>
<pre><code>$ docker pull matsubara0507/mdium</code></pre>
<p>コマンドを使うには，まず Medium のトークンを<a href="https://medium.com/me/settings">設定</a>から生成する．</p>
<p><img src="/assets/create-mdium/generate-token.png" /></p>
<p>これを環境変数 <code>MEDIUM_TOKEN</code> にセットする． 直接でも良いし，<code>./.env</code> か <code>~/.env</code> に描いても良い． 下記のコマンドを実行することでトークンをチェックできる:</p>
<pre><code>$ mdium --me
Hi MATSUBARA Nobutada!!</code></pre>
<p>Docker イメージを使う場合にはこう:</p>
<pre><code>$ docker run --rm --env-file=&quot;$HOME/.env&quot; matsubara0507/mdium /bin/bash -c &quot;mdium --me&quot;</code></pre>
<p>トークンを渡すのは <code>--env-file</code> オプションでも <code>-e</code> オプションでも何でも良い． 実際に送信するには引数に送信したいファイルのパスを渡すだけ:</p>
<pre><code>$ medium example.md
post success, browse to: https://medium.com/@nobutada/e31f70013b36</code></pre>
<p>こうすることで指定した Markdown ファイルを draft として記事にしてくれる． ちなみに，<a href="https://github.com/matsubara0507/mdium/blob/master/example/example.md">これ</a>が下記のようになる．</p>
<p><img src="https://github.com/matsubara0507/mdium/raw/master/example/example.png" /></p>
<h2 id="medium-api">Medium API</h2>
<p>こっからは中身の話を少し． 中では Medium の API を使っている．</p>
<ul>
<li><a href="https://github.com/Medium/medium-api-docs#readme">Medium’s API documentation - GitHub</a></li>
</ul>
<p>その中に記事を送信する API があるのだが，驚いたことに送信できるファイルフォーマットに HTML と <strong>Markdown</strong> があったのだ． つまり，特別な処理をせずともこの API を使ってマークダウンを送信すれば良い．</p>
<h2 id="dockerise">Dockerise</h2>
<p>Haskell Stack には Docker integration というのがある（あんまりドキュメントにまとまっていない機能）． これを使うことで，指定した Docker image 内で Haskell プロジェクトをビルドしたり，ビルドした実行ファイルを突っ込んだ Docker image を作成したりできる．</p>
<p>今回は次のような設定を書き:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">docker:</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="fu">repo:</span><span class="at"> fpco/stack-build</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="fu">enable:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="fu">image:</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="fu">container:</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="fu">name:</span><span class="at"> matsubara0507/mdium</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="fu">base:</span><span class="at"> fpco/ubuntu-with-libgmp</span></a></code></pre></div>
<p>次のようなコマンドを実行することで Docker image を作成している:</p>
<pre><code>$ stack docker pull
$ stack --docker image container</code></pre>
<p>作成した Image は <code>docker push</code> コマンドでアップロードしている． また，この一連の流れを TravisCI で自動化している．</p>
<h2 id="todo">ToDo</h2>
<p>突貫で作ったのでいくつかやり残しがある．</p>
<ul>
<li>エラーハンドリング : 特に何も例外処理していないので</li>
<li>記事の更新 : 今はひたすら新しい記事を生成してしまう</li>
<li>タグやファイルフォーマットなどの細かい指定</li>
</ul>
<h1 id="おしまい">おしまい</h1>
<p>だいたい1日とちょっとでサクッと作った割にはいい感じのものができて満足． どんどん再発明していこ．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Hacktoberfest 2018 なので PR を5つ以上出してみた</title>
    <link href="https://matsubara0507.github.io/posts/2018-10-29-join-hacktoberfest-2018.html" />
    <id>https://matsubara0507.github.io/posts/2018-10-29-join-hacktoberfest-2018.html</id>
    <published>2018-10-29T00:00:00Z</published>
    <updated>2018-10-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Hacktoberfest 2018 なので PR を5つ以上出してみた</h1>
    <p class="post-meta">
      <time datetime="2018-10-29" itemprop="datePublished">
        Oct 29, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>去年に引き続き，Hacktoberfest に参加しました． 2017 は PR を4つでしたが，2018 は5つになったようです．</p>
<p>ちなみに Hacktoberfest がなんなのかや，参加方法については<a href="https://matsubara0507.github.io/posts/2017-10-11-join-hacktoberfest-2017.html">過去記事</a>を見てください（多分変わってなかったはず）．</p>
<h2 id="マイステータス">マイステータス</h2>
<p>10月29日時点のステータスはこんな感じ．</p>
<p><img src="/assets/join-hacktoberfest-2018/status.png" /></p>
<p><a href="https://hacktoberfest.digitalocean.com/stats/matsubara0507">ここから見れる</a>が，毎年同じリンクを使ってるっぽいので，2019年にこの記事を見にきた人は役に立たないリンクです(笑)</p>
<h2 id="出した-pr">出した PR</h2>
<p>自分のリポジトリに対する PR もカウントされてしまうので，それを除くと4リポジトリ7PRです．</p>
<ul>
<li><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/10">haskell-jp/makeMistakesToLearnHaskell ＃10</a></li>
<li><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/14">haskell-jp/makeMistakesToLearnHaskell ＃14</a></li>
<li><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/16">haskell-jp/makeMistakesToLearnHaskell ＃16</a></li>
<li><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/30">haskell-jp/makeMistakesToLearnHaskell ＃30</a></li>
<li><a href="https://github.com/commercialhaskell/stackage/pull/4078">commercialhaskell/stackage ＃4078</a></li>
<li><a href="https://github.com/Hacktoberfest-2018/Hello-world/pull/2483">Hacktoberfest-2018/Hello-world ＃2483</a></li>
<li><a href="https://github.com/stackbuilders/dotenv-hs/pull/101">stackbuilders/dotenv-hs ＃101</a></li>
</ul>
<p>とはいえ，haskell-jp は僕が活動しているコミュニティだし，stackage は Haskell 版 Gem の登録申請みたいなものだし，Hacktoberfest-2018/Hello-world はただの遊びだし． ちゃんと OSS に出した PR は一つだ…</p>
<h3 id="haskell-jpmakemistakestolearnhaskell">haskell-jp/makeMistakesToLearnHaskell</h3>
<p>このリポジトリは，2018/11/10 に開催予定の <a href="https://haskell-jp.connpass.com/event/92617/">Haskell Day 2018</a> の午前中で行われる予定のハンズオンで使うものです． <a href="https://github.com/igrep">igrep</a> 氏がメインで作っており，僕は CI を設定したり，Cabal から hpack に移行したり，コンテンツをいじるより環境周りをいじった．</p>
<h3 id="commercialhaskellstackage">commercialhaskell/stackage</h3>
<p>このリポジトリは Haskell のパッケージマネージャーである <a href="https://www.stackage.org/">Stackage</a> の管理リポジトリだ． <a href="http://hackage.haskell.org/">Hackage</a> というのもあるが，Hackage はパッケージストレージで，Stackage は Hackage にある各パッケージのバージョンのリゾルバを提供している（ビルド可能な組み合わせのこと）． 他の言語と異なり，リゾルバがあることで Haskell アプリケーションの作者が常に各パッケージ間のバージョンなどを細かく管理する必要はなく，特定のリゾルバを設定するだけで良い．</p>
<p>最近，Haskell のデファクトスタンダードなコンパイラ，GHC の最新バージョンである GHC 8.6 がリリースされた． それに伴い，Stackage の Nightly 版が GHC 8.6 へ移行され，多くのパッケージが disable された． 徐々にメジャーパッケージが reenable されたので，<a href="http://hackage.haskell.org/package/servant-kotlin">僕の作成したパッケージ</a>も reenable する PR を送ったのだ．</p>
<h3 id="hacktoberfest-2018hello-world">Hacktoberfest-2018/Hello-world</h3>
<p>これは Hacktoberfest が作ったお遊びリポジトリだ（多分）． いろんな言語の <code>Hello, world!</code> と出力するプログラムを集めるリポジトリのようだ．</p>
<p>僕は <a href="https://hacktoberfest.digitalocean.com/stats">Hacktoberfest のグローバルステータス</a>の「Highest Pull Request Count Repos」で見かけた（今は read-only になっているので PR は出せない）． 面白そうだったので，まだ無かった <a href="https://www.egison.org/">Egison</a> のプログラムを PR として出した．</p>
<pre class="egison"><code>(define $main
  (lambda [$args]
    (write &quot;Hello, world!\n&quot;)))</code></pre>
<p>Egison は江木さんという方が学生のころから作ってるパターンマッチ志向という独特のパラダイムを持つプログラミング言語だ． 全然関係ない話だが，今度<a href="https://connpass.com/event/102061/">ワークショップ</a>も行われる．</p>
<h3 id="stackbuildersdotenv-hs">stackbuilders/dotenv-hs</h3>
<p>唯一のまともな OSS な PR． <a href="http://hackage.haskell.org/package/dotenv">dotenv</a> という Haskell パッケージのリポジトリだ． 自分が作ってる <a href="https://github.com/matsubara0507/stack-tpls">CLI ツール</a>に使おうと思って README に書いてある通りに書いて見たら，動かなかったので，その修正 PR を出した．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Configuration.Dotenv</span> (loadFile, defaultConfig)</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">loadFile defaultConfig</a></code></pre></div>
<p>こう書くと <code>defaultConfig</code> が無いと怒られる．</p>
<pre class="shell"><code>Main.hs:17:42: error:
    Module ‘Configuration.Dotenv’ does not export ‘defaultConfig’
   |                             
17 | import           Configuration.Dotenv   (defaultConfig, loadFile)
   |                                          ^^^^^^^^^^^^^</code></pre>
<p>コードを見に行ったら <code>defaultConfig</code> を Reexport し忘れていたので，Reexport し直す PR を出した． 無事マージされ，最新バージョンでリリースされたので，もし同じバグを踏んだ人がいた場合はバージョン <code>0.6.0.3</code> 以上を試してほしい．</p>
<h2 id="t-shirt">T-shirt</h2>
<p>去年と同様に「You’ve completed the Hacktoberfest challenge!」というメールが届いた（10/27に）． メール本文にあるユニークなリンクを踏んでTシャツのリクエストを出せる． Tシャツのサイズと，自分の住所などを英語で記載するだけだ．</p>
<p>アメリカ以外はだいたいひと月ほどで届くらしい． ちなみに，去年は12月20日ぐらいに届いてた．</p>
<h3 id="おしまい">おしまい</h3>
<p>あんまり OSS っぽい PR を出せなくて残念…</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>GHC 8.6 がインストールできなかった</title>
    <link href="https://matsubara0507.github.io/posts/2018-10-28-ghc-8-6-error-no-gmp.html" />
    <id>https://matsubara0507.github.io/posts/2018-10-28-ghc-8-6-error-no-gmp.html</id>
    <published>2018-10-28T00:00:00Z</published>
    <updated>2018-10-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">GHC 8.6 がインストールできなかった</h1>
    <p class="post-meta">
      <time datetime="2018-10-28" itemprop="datePublished">
        Oct 28, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>対したことではないんだけど，日本語の記事が無っかたのでメモ． ちなみに OS は macOS Sierra (10.12.6) です．</p>
<h2 id="ghc-8.6-でビルドできない">GHC 8.6 でビルドできない</h2>
<p>現在 stackage の Nightly は最新の GHC バージョンである 8.6 がインストールされる． 結構パッケージも揃ってきたので，自分のパッケージもビルドしてみようかなと思って，resolver を Nightly に変えて <code>stack build</code> したら下記のようなエラーが出た．</p>
<pre class="shell"><code>$ stack build
Downloaded nightly-2018-10-26 build plan.    
Preparing to install GHC to an isolated location.
This will not interfere with any system-level installation.
Downloaded ghc-8.6.1.                                      
Installing GHC ...                                                                         
Received ExitFailure 2 when running
Raw command: /usr/bin/make install
Run from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/</code></pre>
<p><code>--vebose</code> を付けて詳細を見てみる．</p>
<pre class="shell"><code>$ stack build --verbose
Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0
2018-10-28 13:31:22.068195: [debug] Checking for project config at: /Users/username/git/haskell/servant-kotlin/stack.yaml
2018-10-28 13:31:22.069706: [debug] Loading project config file stack.yaml
 .
 .
 .
2018-10-28 13:32:21.355443: [debug] /Library/Developer/CommandLineTools/usr/bin/ranlib: file: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/lib/ghc-8.6.1/rts/libHSrts_thr_p.a(Select.thr_p_o) has no symbols
2018-10-28 13:32:21.621133: [debug] &quot;utils/ghc-cabal/dist-install/build/tmp/ghc-cabal-bindist&quot; copy libraries/ghc-prim dist-install &quot;strip&quot; &#39;&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/lib/ghc-8.6.1&#39; &#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/share/doc/ghc-8.6.1/html/libraries&#39; &#39;v p dyn&#39;  
2018-10-28 13:32:21.841900: [debug] dyld: Library not loaded: /usr/local/opt/gmp/lib/libgmp.10.dylib
2018-10-28 13:32:21.842003: [debug]   Referenced from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/libraries/base/dist-install/build/libHSbase-4.12.0.0-ghc8.6.1.dylib
2018-10-28 13:32:21.842062: [debug]   Reason: image not found
2018-10-28 13:32:21.842273: [debug] make[1]: *** [install_packages] Abort trap: 6
2018-10-28 13:32:21.844303: [debug] make: *** [install] Error 2
Installing GHC ...
Received ExitFailure 2 when running
Raw command: /usr/bin/make install
Run from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/</code></pre>
<p>どうやら <code>/usr/local/opt/gmp/lib/libgmp.10.dylib</code> が無いみたいだ．</p>
<pre class="shell"><code>$ ls /usr/local/opt/gmp/lib/libgmp.10.dylib
ls: /usr/local/opt/gmp/lib/libgmp.10.dylib: No such file or directory</code></pre>
<p>これで検索すると，Ruby に関することだが <a href="https://stackoverflow.com/questions/34912946">StackOverflow があった</a>． 曰く，<code>gmp</code> パッケージを入れれば良いらしい（多くの人は他のどこかのタイミングで入ってるのかも）．</p>
<pre class="shell"><code>$ brew reinstall gmp
==&gt; Reinstalling gmp
==&gt; Downloading https://homebrew.bintray.com/bottles/gmp-6.1.2_2.sierra.bottle.tar.gz
######################################################################## 100.0%
==&gt; Pouring gmp-6.1.2_2.sierra.bottle.tar.gz
🍺  /usr/local/Cellar/gmp/6.1.2_2: 18 files, 3.1MB

$ ls /usr/local/opt/gmp/lib/libgmp.10.dylib
/usr/local/opt/gmp/lib/libgmp.10.dylib</code></pre>
<p>これで GHC 8.6 で <code>stack build</code> できるようになった．</p>
<h2 id="おしまい">おしまい</h2>
<p>まぁ一応ね，一応メモした．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>stack-templates を集める with GraphQL</title>
    <link href="https://matsubara0507.github.io/posts/2018-10-14-collect-stack-templates.html" />
    <id>https://matsubara0507.github.io/posts/2018-10-14-collect-stack-templates.html</id>
    <published>2018-10-14T00:00:00Z</published>
    <updated>2018-10-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">stack-templates を集める with GraphQL</h1>
    <p class="post-meta">
      <time datetime="2018-10-14" itemprop="datePublished">
        Oct 14, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/GraphQL.html">GraphQL</a> <a href="/tags/application.html">application</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Haskell Day の仕込みパート1です(2があるかは知らない)． stack の次期バージョン v1.9 で追加される namespaced template を試してみました．</p>
<p>ちなみに，現在 v1.9 はプレリリースになったので，下記コマンドで簡単にアップデートできます．</p>
<pre><code>$ stack upgrade --binary-version 1.9.0.1</code></pre>
<h2 id="namespaced-template">namespaced template</h2>
<p><code>stack new</code> で指定できるテンプレートを，GitHub などのオンラインからも取ってこれるようになった機能． 詳しくは開発段階からキャッチアップしてる e-bigmoon さんの記事を読むと良い．</p>
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html">namespaced templates - BIGMOON haskellers blog</a></li>
</ul>
<h3 id="作ってみた">作ってみた</h3>
<p>GitHub などで <code>stack-templates</code> という名前のリポジトリを作り，<code>hsfiles</code> という拡張子のテンプレートファイルをトップレベルに置く． 今回ぼくは <a href="https://github.com/matsubara0507/stack-templates">matsubara0507/stack-templates</a> というリポジトリを作り，２つ程作ってみた．</p>
<ul>
<li><code>get-opt-cli.hsfiles</code> : <a href="http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html"><code>System.Console.GetOpt</code></a> を用いたCLIのテンプレート</li>
<li><code>optparse-applicative-cli.hsfiles</code> : <a href="http://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> を用いたCLIのテンプレート</li>
</ul>
<p>どちらも，よくCLIを作るときの書き方をテンプレートとして起こしたもの． 普段は <a href="http://hackage.haskell.org/package/rio">rio</a> と <a href="http://hackage.haskell.org/package/extensible">extensible</a> を使っているので，単純に optparse-applicative などを使ったテンプレートという訳でもない．</p>
<h3 id="テストする">テストする</h3>
<p>できれば，テンプレートを <code>stack new</code> して <code>stack build</code> した時点ではコンパイルを通ってほしい． ということで <code>stack new</code> して <code>stack build</code> を試してくれるテストを <a href="https://github.com/matsubara0507/stack-templates/blob/7abc95184241c2df9f81ec1a45f9a662a98db05a/.travis.yml">TravisCI</a> に書いた．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">matrix:</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="kw">-</span> <span class="fu">env:</span><span class="at"> TEMPLATE=&quot;get-opt-cli&quot; ARGS=&quot;--resolver lts-12&quot;</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="fu">compiler:</span><span class="at"> </span><span class="st">&quot;: #stack 8.4.3&quot;</span></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="fu">addons:</span><span class="at"> </span><span class="kw">{</span><span class="fu">apt:</span><span class="at"> </span><span class="kw">{</span><span class="fu">packages:</span><span class="at"> </span><span class="kw">[</span>libgmp-dev<span class="kw">]}}</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="kw">-</span> <span class="fu">env:</span><span class="at"> TEMPLATE=&quot;optparse-applicative-cli&quot; ARGS=&quot;--resolver lts-12&quot;</span></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="fu">compiler:</span><span class="at"> </span><span class="st">&quot;: #stack 8.4.3&quot;</span></a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="fu">addons:</span><span class="at"> </span><span class="kw">{</span><span class="fu">apt:</span><span class="at"> </span><span class="kw">{</span><span class="fu">packages:</span><span class="at"> </span><span class="kw">[</span>libgmp-dev<span class="kw">]}}</span></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="fu">before_install:</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co"># install stack</span></a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="fu">install:</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="kw">-</span> stack new sample <span class="st">&quot;./$TEMPLATE&quot;</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="kw">- </span><span class="st">|</span></a>
<a class="sourceLine" id="cb2-16" title="16">  set -ex</a>
<a class="sourceLine" id="cb2-17" title="17">  cd sample</a>
<a class="sourceLine" id="cb2-18" title="18">  stack --no-terminal --install-ghc $ARGS test --bench --only-dependencies</a>
<a class="sourceLine" id="cb2-19" title="19">  set +ex</a>
<a class="sourceLine" id="cb2-20" title="20"><span class="fu">script:</span></a>
<a class="sourceLine" id="cb2-21" title="21"><span class="kw">- </span><span class="st">|</span></a>
<a class="sourceLine" id="cb2-22" title="22">  set -ex</a>
<a class="sourceLine" id="cb2-23" title="23">  stack --no-terminal $ARGS test --bench --no-run-benchmarks --no-haddock-deps</a>
<a class="sourceLine" id="cb2-24" title="24">  set +ex</a></code></pre></div>
<p><a href="https://github.com/commercialhaskell/stack-templates/blob/879f95dc44b24201bc64fcf8f4b9e2192c23dad4/test-templates.hs">commercialhaskell/stack-templates でもテストは書いてある</a>がぼくのはすごいシンプルだ．</p>
<h2 id="stack-templates-を集める">stack-templates を集める</h2>
<p>さて，これだけでは完全に e-bigmoon さんの劣化記事だ． なので，stack-templates を GitHub から集めてくる CLI ツールを作ることにした．</p>
<p>試したところ，GitHub の検索で <code>stack-template in:name</code> と検索すれば，それなりにヒットすることがわかった(間違いも多いが)． なので，ざっくりとした手順は:</p>
<ol type="1">
<li>検索系の GitHub API を叩く</li>
<li>stack-templates という名前のリポジトリの <code>*.hsfiles</code> というファイルだけ抽出</li>
<li>それらを出力</li>
</ol>
<p>ここで GitHub API v3 (RESTful API)を利用すると，リポジトリのファイル群を取得するのに検索系の API を叩いてから，各リポジトリの API を叩く必要がある． それは面倒だ． なので，ここ数年注目を集めている(？) GraphQL API (GitHub API v4)を試してみることにした．</p>
<h3 id="graphql">GraphQL</h3>
<p>ちょうどこの前に，友人から「GraphQL はいいぞ，API をなんども叩く必要がない．」と紹介されたので試してみた．</p>
<p>GitHub の API では <code>api.github.com/graphql</code> というエンドポイントに対し，POST メソッドでクエリを送信する．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">$ <span class="ex">curl</span> \</a>
<a class="sourceLine" id="cb3-2" title="2">  -H <span class="st">&quot;Authorization: bearer token&quot;</span> \</a>
<a class="sourceLine" id="cb3-3" title="3">  -X POST \</a>
<a class="sourceLine" id="cb3-4" title="4">  -d <span class="st">&quot;{ </span><span class="dt">\&quot;</span><span class="st">query</span><span class="dt">\&quot;</span><span class="st">: </span><span class="dt">\&quot;</span><span class="st"> ... </span><span class="dt">\&quot;</span><span class="st"> }&quot;</span> \</a>
<a class="sourceLine" id="cb3-5" title="5">  https://api.github.com/graphql</a></code></pre></div>
<p><code>...</code> のところにクエリを記述する． クエリは簡単な DSL のようになっており，クエリによってどんな形の JSON が返ってくるか(型のようなもの)やどんな値が返ってくるかが決まる． 例えば <code>stack-template in:name</code> 検索してヒットしたリポジトリの名前だけを取得してみよう． その場合は次のようなクエリを書く．</p>
<pre><code>query{
  search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 2) {
    repositoryCount,
    edges{
      node{ ... on Repository{ nameWithOwner } }
    }
  }
}</code></pre>
<p><code>first</code> は検索にヒットした最初の2つを返すという意味． 上限は 100 で，<code>first</code> ないしは逆の意味の <code>last</code> のどちらかは指定をする必要がある(そういうエラーが返ってくる)． <code>repositoryCount</code> は検索でヒットしたリポジトリの総数で，<code>edges</code> のところはリポジトリの <code>nameWithOwner</code> を返すように指定している． このように <code>{}</code> の中ではカンマ区切りで，返す JSON の形を指定できる． 具体的に何が指定できるかは <a href="https://developer.github.com/v4/query/">GitHub API v4 のドキュメント</a>を見ると良い． 試しに curl で叩いてみる(クエリ内の <code>&quot;</code> をエスケープすることを忘れずに):</p>
<pre><code>$ curl -H &quot;Authorization: bearer XXX&quot; -X POST -d &quot;{ \&quot;query\&quot;: \&quot; ... \&quot; }&quot; https://api.github.com/graphql
{&quot;data&quot;:{&quot;search&quot;:{&quot;repositoryCount&quot;:76,&quot;edges&quot;:[{&quot;node&quot;:{&quot;nameWithOwner&quot;:&quot;Azure/AzureStack-QuickStart-Templates&quot;}},{&quot;node&quot;:{&quot;nameWithOwner&quot;:&quot;commercialhaskell/stack-templates&quot;}}]}}}</code></pre>
<p>Connection とか Fields とかの用語については自分もよくわかってないので自分で調べてください． 今のところ，雰囲気で使ってる(笑)</p>
<h3 id="ファイルを集める">ファイルを集める</h3>
<p>さて，前述した結果(リポジトリ名)だけが欲しいなら GitHub API v3 でも十分だ． さらに，ファイルも取得してみよう． <a href="https://developer.github.com/v4/object/repository/">Repository のドキュメント</a> を眺めると <code>object</code> という Field がある． 察するに，リポジトリの任意のブランチ(<code>expression</code> で指定したもの)のコミットオブジェクトを返してくれるのだろう． (たぶん)stack-templates は全部 master が前提なので，master のコミットオブジェクトを取ってくる．</p>
<pre><code>... on Repository{
  nameWithOwner,
  object(expression:&quot;master&quot;){
    ... on Commit { }
  }
}</code></pre>
<p>ちなみに <code>... on Commit</code> というのは Inline Fragments と呼ばれるもので，object の型(サブタイプ？)が <code>Commit</code> だった場合に <code>Commit{}</code> 以下の Field を返すそうだ． git オブジェクトなので他にも <code>Tree</code> や <code>Blob</code> がある．</p>
<p>さて，あとは git オブジェクトの知識があれば簡単にかける． コミットオブジェクトにはツリーオブジェクト，要するにトップレベルのディレクトリのハッシュが記載されているので<a href="https://developer.github.com/v4/object/commit/">ドキュメント</a>からそれっぽいのを見つける． ツリーオブジェクトには，そのディレクトリに含まれるブロブオブジェクト(ファイル)とツリーオブジェクト(ディレクトリ)のハッシュが記載されてる． stack-templates は(今のところ)トップレベルに <code>*.hsfiles</code> を置かないといけないので，トップレベルのオブジェクトたちの名前を取得しよう:</p>
<pre><code>... on Repository{
  nameWithOwner,
  object(expression:&quot;master&quot;){
    ... on Commit { tree{ entries{ name, type } } }
  }
}</code></pre>
<p><code>type</code> には <code>blob</code> やら <code>tree</code> やらが入る． これで，検索にヒットした全てのリポジトリから <code>master</code> のトップレベルにあるファイルを取得するクエリが出来上がった．</p>
<h3 id="ページネーション">ページネーション</h3>
<p>今のところ，検索にヒットするリポジトリ数は76個なので <code>first: 100</code> とすれば全て取得できるが，今後ヒット数が100を超えたときようにページネーションの仕組みを整えておく． やり方は簡単で，<code>search</code> Connection のところで <a href=""><code>pageInfo</code></a> という Field を追加する．</p>
<pre><code>search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 1) {
  repositoryCount,
  pageInfo{
    endCursor,
    hasNextPage
  },
  edges{
    node{ ... on Repository{ .... } }
  }
}</code></pre>
<p><code>hasNextPage</code> は次のページが存在するかどうかを真偽値で返してくれる． <code>endCursor</code> はこのページの最後を表すハッシュ値？で，<code>search</code> Connection の引数(<code>type</code> とか <code>first</code> とかのとこ)に <code>after</code> で指定することで，それ以降の結果を取ってくる． このような <code>pageInfo</code> の情報さえあれば，プログラム内でループさせることは容易だろう．</p>
<h3 id="まとめると">まとめると</h3>
<p>次のようなクエリになった:</p>
<pre><code>query{
  search(query: &quot;stack-template in:name&quot;, type: REPOSITORY, first: 100) {
    repositoryCount,
    pageInfo{
      endCursor,
      hasNextPage
    },
    edges{
      node{ ... on Repository{
        nameWithOwner,
        object(expression:&quot;master&quot;){
          ... on Commit { tree{ entries{ name, type } } }
        }
      } }
    }
  }
}</code></pre>
<p>これを curl の引数に与えて叩くだけで 100 個分のリポジトリの全てのトップレベルファイル群を取得できる．</p>
<h3 id="stack-tpls">stack-tpls</h3>
<p>実際に作った CLI ツールは <a href="https://github.com/matsubara0507/stack-tpls"><code>matsubara0507/stack-tpls</code></a> というリポジトリに置いてある． 使い方は README に書いてある． 一覧を取得するには <code>stack-tpls --list</code> と打てば良い．</p>
<pre><code>$ stack-tpls --list
github:commercialhaskell/chrisdone.hsfiles
github:commercialhaskell/foundation.hsfiles
 .
 .
 .</code></pre>
<p>この結果を <code>stack new</code> の引数に与えることでそのまま利用できる． また，テンプレートの中身を確認したい場合は，<code>stack-tpls github:commercialhaskell/chrisdone.hsfiles</code> と引数に与えることで Raw を取ってきてくれる． リンクだけが欲しい場合は <code>--link</code> オプションを指定すると良い．</p>
<pre><code>$ stack-tpls --link github:commercialhaskell/rio.hsfiles
https://github.com/commercialhaskell/stack-templates/blob/master/rio.hsfiles</code></pre>
<h3 id="todo">ToDo</h3>
<p>一週間ほど前の思いつきからの突貫で作ったのでイロイロと抜けてる箇所があって:</p>
<ul>
<li>エラーハンドリングが雑</li>
<li>GitLab と BitBucket には対応していない</li>
<li>GraphQL の使い方がエレガントじゃない</li>
</ul>
<p>特に最後のがすごい気になっていて，現状は完全に文字列を埋め込んでいるだけなのだ． できれば，強力な型システムを利用した GitHub GraphQL Client ライブラリを作りたい(なんか昔に Haskell-jp で話題に上がったなぁ)．</p>
<h2 id="おしまい">おしまい</h2>
<p>GraphQL，クライアント側に取ってすごい便利．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell Servant で GitHub Webhook</title>
    <link href="https://matsubara0507.github.io/posts/2018-08-18-haskell-github-webhook.html" />
    <id>https://matsubara0507.github.io/posts/2018-08-18-haskell-github-webhook.html</id>
    <published>2018-08-18T00:00:00Z</published>
    <updated>2018-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell Servant で GitHub Webhook</h1>
    <p class="post-meta">
      <time datetime="2018-08-18" itemprop="datePublished">
        Aug 18, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/rio.html">rio</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>久々の投稿． とある事情で GitHub Webhook 用のサーバーを Haskell で書いたのでそのメモ書きです．</p>
<h2 id="やったこと">やったこと</h2>
<ul>
<li><a href="http://hackage.haskell.org/package/rio">rio</a> のロガーを Servant で使う</li>
<li><a href="http://hackage.haskell.org/package/servant-github-webhook">servant-github-webhook</a> を使って Webhook 用の Servant サーバーの構築</li>
</ul>
<p>実際に書いたコードは<a href="https://github.com/matsubara0507/git-plantation/commit/b93ed3398b30dbba105a580d58e947f131cf1a9a">この辺り</a>を見ると良いかな． 色々と途中のうえ，そもそも GitHub Webhook がメインではないリポジトリなので見にくい気がするけど．</p>
<h2 id="servant-で-rio-モナド">Servant で rio モナド</h2>
<p>これはまぁおまけですね． rio はロギングとかが便利なので，先に紹介して以降で利用する．</p>
<h3 id="ロガーの準備">ロガーの準備</h3>
<p>まずはロギング用のモナドを定義する．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE DataKinds        #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">{-# LANGUAGE TypeOperators    #-}</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb1-9" title="9">  &#39;[ <span class="st">&quot;logger&quot;</span> <span class="fu">&gt;:</span> <span class="dt">LogFunc</span></a>
<a class="sourceLine" id="cb1-10" title="10">   ]</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">instance</span> <span class="dt">HasLogFunc</span> <span class="dt">Env</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-13" title="13">  logFuncL <span class="fu">=</span> lens (view <span class="fu">#</span>logger) (\x y <span class="ot">-&gt;</span> x <span class="fu">&amp;</span> <span class="fu">#</span>logger <span class="ot">`set`</span> y)</a></code></pre></div>
<p>いわゆる Has パターンというやつ． これで <code>RIO Env</code> というのがロガーを扱えるモナドとなる．</p>
<h3 id="servant-でカスタムモナド">Servant でカスタムモナド</h3>
<p>Servent Server のメイン関数は下記のように定義できる．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.Wai.Handler.Warp</span> <span class="kw">as</span> <span class="dt">Warp</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">import</span>           <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-8" title="8">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-9" title="9">  logOpts <span class="ot">&lt;-</span> logOptionsHandle stdout <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-10" title="10">  withLogFunc logOpts <span class="fu">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>logger <span class="fu">@=</span> logger</a>
<a class="sourceLine" id="cb2-12" title="12">           <span class="fu">&lt;:</span><span class="ot"> nil ::</span> <span class="dt">Env</span></a>
<a class="sourceLine" id="cb2-13" title="13">    hPutBuilder stdout <span class="st">&quot;Listening on port 8080&quot;</span></a>
<a class="sourceLine" id="cb2-14" title="14">    Warp.run <span class="dv">8080</span> <span class="fu">$</span> app env</a>
<a class="sourceLine" id="cb2-15" title="15"></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb2-17" title="17">app <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p>さて，問題はこの <code>app</code> 関数だ． 普通は <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#t:Server"><code>Server</code></a> 型と <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#v:serve"><code>serve</code></a> 関数を用いて次のように書く．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb3-4" title="4">api <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb3-7" title="7">server <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="ot">app ::</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb3-10" title="10">app <span class="fu">=</span>  serve api server</a></code></pre></div>
<p><code>Server</code> 型の代わりに，カスタムモナドを利用するには <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#t:ServerT"><code>ServerT</code></a> 型と <a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#v:hoistServer"><code>hoistServer</code></a> 関数を用いる． それぞれの型定義は次のようになっている．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">type</span> <span class="dt">Server</span> api <span class="fu">=</span> <span class="dt">ServerT</span> api <span class="dt">Handler</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">serve ::</span> <span class="dt">HasServer</span> api &#39;[] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> <span class="dt">Server</span> api <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="ot">hoistServer ::</span> <span class="dt">HasServer</span> api &#39;[] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> m x <span class="ot">-&gt;</span> n x) <span class="ot">-&gt;</span> <span class="dt">ServerT</span> api m <span class="ot">-&gt;</span> <span class="dt">ServerT</span> api n</a></code></pre></div>
<p>さぁあとは型パズルだ！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb5-2" title="2">server <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb5-5" title="5">app env <span class="fu">=</span> serve api <span class="fu">$</span> hoistServer api (runRIO env) server</a></code></pre></div>
<p>これで　<code>server</code> 関数で呼び出す， API ごとの関数で <code>logInfo</code> のような rio のロギング関数を呼ぶことができる．</p>
<h2 id="servant-で-github-webhhok">Servant で GitHub Webhhok</h2>
<p>さて色々準備ができたので，いよいよ GitHub Webhook の方に話を移す． Haskell Servant で GitHub Webhook を使うには <a href="http://hackage.haskell.org/package/servant-github-webhook">servant-github-webhook</a>というパッケージを使う． 意外と，このパッケージの使い方を書いた記事がなく手間取ったのでまとめる．</p>
<h3 id="ping-api-を作る">ping API を作る</h3>
<p>ping API は GitHub Webhook の設定がうまくできてるかを確認する API だ．</p>
<p><img src="/assets/haskell-github-webhook/ping-event.jpg" /></p>
<p>ping API は次のように設定すれば良い．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">import</span>           <span class="dt">GitHub.Data.Webhooks.Events</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">import</span>           <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">import</span>           <span class="dt">Servant.GitHub.Webhook</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;hook&quot;</span> <span class="fu">:&gt;</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">type</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb6-8" title="8">      <span class="fu">=</span> <span class="dt">GitHubEvent</span> &#39;[ <span class="dt">&#39;WebhookPingEvent</span> ]</a>
<a class="sourceLine" id="cb6-9" title="9">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">PublicEvent</span></a>
<a class="sourceLine" id="cb6-10" title="10">        <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">JSON</span>] ()</a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb6-13" title="13">server <span class="fu">=</span> pingWebhook</a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="ot">pingWebhook ::</span></a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="dt">RepoWebhookEvent</span> <span class="ot">-&gt;</span> ((), <span class="dt">PublicEvent</span>) <span class="ot">-&gt;</span> <span class="dt">Plant</span> ()</a>
<a class="sourceLine" id="cb6-17" title="17">pingWebhook _ (_, ev) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-18" title="18">  logInfo <span class="fu">$</span> <span class="st">&quot;Hook Ping Event: &quot;</span> <span class="fu">&lt;&gt;</span> displayShow ev</a></code></pre></div>
<p>GitHub Webhook を使うには Servant の Context 機能でシークレットキーを渡す必要がある．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">import</span>           <span class="dt">System.Environment</span>       (getEnv)</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-4" title="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">let</span> key <span class="fu">=</span> gitHubKey <span class="fu">$</span> fromString <span class="fu">&lt;$&gt;</span> getEnv <span class="st">&quot;GH_SECRET&quot;</span></a>
<a class="sourceLine" id="cb7-7" title="7">    Warp.run <span class="dv">8080</span> <span class="fu">$</span> app env key</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span> <span class="dt">PublicEvent</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb7-10" title="10">app env key <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-11" title="11">  serveWithContext api (key <span class="fu">:.</span> <span class="dt">EmptyContext</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-12" title="12">    hoistServerWithContext api context (runRIO env) server</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="ot">context ::</span> <span class="dt">Proxy</span> &#39;[ <span class="dt">GitHubKey</span> <span class="dt">PublicEvent</span> ]</a>
<a class="sourceLine" id="cb7-15" title="15">context <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>実行するときは <code>GH_SECRET</code> 環境変数に設定した文字列を GitHub Webhook の設定の Secret に書き込む．</p>
<h3 id="push-api-を加える">push API を加える</h3>
<p>もう一個 API を生やしてみよう．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">type</span> <span class="dt">WebhookAPI</span></a>
<a class="sourceLine" id="cb8-2" title="2">      <span class="fu">=</span> <span class="dt">GitHubEvent</span> &#39;[ <span class="dt">&#39;WebhookPingEvent</span> ]</a>
<a class="sourceLine" id="cb8-3" title="3">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">PublicEvent</span></a>
<a class="sourceLine" id="cb8-4" title="4">        <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">JSON</span>] ()</a>
<a class="sourceLine" id="cb8-5" title="5">   <span class="fu">:&lt;|&gt;</span> <span class="dt">GitHubEvent</span> &#39;[ <span class="dt">&#39;WebhookPushEvent</span> ]</a>
<a class="sourceLine" id="cb8-6" title="6">        <span class="fu">:&gt;</span> <span class="dt">GitHubSignedReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">PushEvent</span></a>
<a class="sourceLine" id="cb8-7" title="7">        <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">JSON</span>] ()</a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="ot">server ::</span> <span class="dt">ServerT</span> (<span class="dt">RIO</span> <span class="dt">Env</span>) <span class="dt">API</span></a>
<a class="sourceLine" id="cb8-10" title="10">server <span class="fu">=</span> pingWebhook <span class="fu">:&lt;|&gt;</span> pushWebhook</a>
<a class="sourceLine" id="cb8-11" title="11"></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="ot">pushWebhook ::</span> <span class="dt">RepoWebhookEvent</span> <span class="ot">-&gt;</span> ((), <span class="dt">PushEvent</span>) <span class="ot">-&gt;</span> <span class="dt">Plant</span> ()</a>
<a class="sourceLine" id="cb8-13" title="13">pushWebhook _ (_, ev) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-14" title="14">  logInfo <span class="fu">$</span> <span class="st">&quot;Hook Push Event: &quot;</span> <span class="fu">&lt;&gt;</span> displayShow ev</a></code></pre></div>
<p>これでビルドすると次のようなエラーが出てくる．</p>
<pre><code>Main.hs:38:3: error:
    • No instance for (HasContextEntry &#39;[] (GitHubKey&#39; () PushEvent))
        arising from a use of ‘serveWithContext’
    • In the expression: serveWithContext api (key :. EmptyContext)
      In the expression:
        serveWithContext api (key :. EmptyContext)
          $ hoistServerWithContext api context (runRIO env) server
      In an equation for ‘app’:
          app env key
            = serveWithContext api (key :. EmptyContext)
                $ hoistServerWithContext api context (runRIO env) server
   |
38 |   serveWithContext api (key :. EmptyContext) $ hoistServerWithContext api context (runRIO env) server
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
<p><a href="https://github.com/tsani/servant-github-webhook/issues/13#issuecomment-408463124">ググった結果</a>，こうするといいらしい．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">import</span>           <span class="dt">Servant.GitHub.Webhook</span>    <span class="kw">hiding</span> (<span class="dt">GitHubKey</span>, gitHubKey)</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Servant.GitHub.Webhook</span>   (<span class="dt">GitHubKey</span>, gitHubKey)</a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="ot">app ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb10-7" title="7">app env key <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="ot">context ::</span> <span class="dt">Proxy</span> &#39;[ <span class="dt">GitHubKey</span> ]</a>
<a class="sourceLine" id="cb10-10" title="10">context <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb10-11" title="11"></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="co">-- HACK</span></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="kw">newtype</span> <span class="dt">GitHubKey</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-14" title="14">  <span class="dt">GitHubKey</span> (<span class="kw">forall</span> result<span class="fu">.</span> <span class="dt">Servant.GitHub.Webhook.GitHubKey</span> result)</a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16"><span class="ot">gitHubKey ::</span> <span class="dt">IO</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">GitHubKey</span></a>
<a class="sourceLine" id="cb10-17" title="17">gitHubKey k <span class="fu">=</span> <span class="dt">GitHubKey</span> (Servant.GitHub.Webhook.gitHubKey k)</a>
<a class="sourceLine" id="cb10-18" title="18"></a>
<a class="sourceLine" id="cb10-19" title="19"><span class="kw">instance</span> <span class="dt">HasContextEntry</span> &#39;[<span class="dt">GitHubKey</span>] (<span class="dt">Servant.GitHub.Webhook.GitHubKey</span> result) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-20" title="20">  getContextEntry (<span class="dt">GitHubKey</span> x <span class="fu">:.</span> _) <span class="fu">=</span> x</a></code></pre></div>
<h1 id="おしまい">おしまい</h1>
<p>ちなみに，手元で試すときには ngrok を使った． 便利．</p>
  </div>
</div>
</article>
]]></summary>
</entry>

</feed>
