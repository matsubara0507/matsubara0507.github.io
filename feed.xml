<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>ひげメモ</title>
    <link href="https://matsubara0507.github.io/feed.xml" rel="self" />
    <link href="https://matsubara0507.github.io" />
    <id>https://matsubara0507.github.io/feed.xml</id>
    <author>
        <name>MATSUBARA Nobutada</name>
        <email></email>
    </author>
    <updated>2018-05-13T00:00:00Z</updated>
    <entry>
    <title>Haskell で型安全に YAML ファイルをビルド時に埋め込む</title>
    <link href="https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html" />
    <id>https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html</id>
    <published>2018-05-13T00:00:00Z</published>
    <updated>2018-05-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell で型安全に YAML ファイルをビルド時に埋め込む</h1>
    <p class="post-meta">
      <time datetime="2018-05-13" itemprop="datePublished">
        May 13, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/haskell.html">haskell</a> <a href="/tags/extensible-package.html">extensible-package</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>ザックリ言えば「<a href="https://ryota-ka.hatenablog.com/entry/2018/02/14/103000">Template Haskell でコード中に JSON を埋め込んだりコンパイル時にファイルから型安全に読み込んだりする - ryota-ka’s blog</a>」という記事の YAML 版です．</p>
<p>ただし，ryota さんの記事では Template Haskell を解説しながら JSON を読み込む関数を定義していますが， YAML 版は <a href="https://hackage.haskell.org/package/yaml">yaml</a> パッケージに同様の関数が既にあるので特に解説はしません． あくまでも Haskell の型システムとメタプログラミングを感じてもらえたらなぁと．</p>
<h2 id="section"></h2>
<p>ソースコードは全てこの<a href="https://github.com/matsubara0507/sample-yaml-th">リポジトリ</a>にまとめてある．</p>
<h1 id="yaml-を埋め込む">YAML を埋め込む</h1>
<p>次のような設定ファイルに関する型があったとします．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  {<span class="ot"> columns ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ,<span class="ot"> languageExtensions ::</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>yaml パッケージで YAML にデコードするためには <a href="https://hackage.haskell.org/package/aeson">aeson</a> の <a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson.html#t:FromJSON"><code>FromJSON</code></a> 型クラスのインスタンスである必要がある． <code>FromJSON</code> のインスタンスに凝ってもしょうがないので，今回は <code>Generics</code> を使って適当に定義する．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">import</span> <span class="dt">GHC.Generics</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  {<span class="ot"> columns ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  ,<span class="ot"> languageExtensions ::</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Config</span></a></code></pre></div>
<p><code>Config</code> 型のデフォルト値を YAML ファイルで記述したいとする．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># template/.config.yaml</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="fu">columns:</span><span class="at"> 80</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="fu">languageExtensions:</span><span class="at"> </span><span class="kw">[]</span></a></code></pre></div>
<p>これをコンパイル時に埋め込んでかつ型検査も行いたい． そのためには Template Haskell と yaml パッケージの <a href="https://hackage.haskell.org/package/yaml-0.8.30/docs/Data-Yaml-TH.html#v:decodeFile"><code>Data.Yaml.TH.decodeFile</code></a> 関数を用いる．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">decodeFile ::</span> (<span class="dt">Lift</span> a, <span class="dt">FromJSON</span> a) <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Q</span> (<span class="dt">TExp</span> a)</a></code></pre></div>
<p><code>TExp a</code> 型というのは型付きの <code>Exp</code> 型らしいが，ぼくはあまりよく分からないので割愛． 型を見ればわかるように，<code>Lift</code> 型クラスのインスタンスにもなってなきゃいけない． <code>DerivingLift</code> 言語拡張を使えば簡単に定義できる．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveLift #-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> import <span class="dt">Language.Haskell.TH.Syntax</span> <span class="co">-- template-haskell package</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  {<span class="ot"> columns ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  ,<span class="ot"> languageExtensions ::</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>, <span class="dt">Lift</span>)</a></code></pre></div>
<p>使い方は簡単で，次のようにすればよい．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">defaultConfig ::</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">defaultConfig <span class="fu">=</span> <span class="fu">$$</span>(decodeFile <span class="st">&quot;./template/.config.yaml&quot;</span>)</a></code></pre></div>
<p>注意点として，Template Haskell の制約より <code>Config</code> 型の定義と <code>defaultConfig</code> 関数の定義は別ファイルに分けなければいけない．</p>
<h2 id="試す">試す</h2>
<pre><code>$ stack ghci
&gt;&gt; defaultConfig
Config {columns = 80, languageExtensions = []}</code></pre>
<p>試しに間違えてみよう</p>
<pre><code>$ cat template/.config.yaml
column: 80
languageExtensions: []
$ stack build
sample-yaml-th-0.1.0.0: build (lib)
Preprocessing library for sample-yaml-th-0.1.0.0..
Building library for sample-yaml-th-0.1.0.0..
[1 of 2] Compiling Sample.Config.Internal ( src\Sample\Config\Internal.hs, .stack work\dist\5c8418a7\build\Sample\Config\Internal.o )
[2 of 2] Compiling Sample.Config    ( src\Sample\Config.hs, .stack-work\dist\5c8418a7\build\Sample\Config.o )

C:\Users\hoge\haskell\sample-yaml-th\src\Sample\Config.hs:14:20: error:
    • Aeson exception:
Error in $: key &quot;columns&quot; not present
    • In the Template Haskell splice
        $$(Y.decodeFile &quot;./template/.config.yaml&quot;)
      In the expression: $$(Y.decodeFile &quot;./template/.config.yaml&quot;)
      In an equation for ‘defaultConfig’:
          defaultConfig = $$(Y.decodeFile &quot;./template/.config.yaml&quot;)
   |
14 | defaultConfig = $$(Y.decodeFile &quot;./template/.config.yaml&quot;)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
<h1 id="おまけ-with-extensible">おまけ : with Extensible</h1>
<p>さぁココからが本題！ <a href="https://hackage.haskell.org/package/extensible">extensible</a> という神パッケージを使ってリファクタリングをしてみよう！！</p>
<h2 id="問題点">問題点</h2>
<p>大した問題ではないんだけど</p>
<ol type="1">
<li>ファイルを分けなければいけないのが悲しい</li>
<li>YAML のキーがキャメルケース(<code>languageExtensions</code>)</li>
</ol>
<h2 id="extensible-パッケージ">extensible パッケージ</h2>
<p>言わずもがな，拡張可能なレコードやバリアントを提供するパッケージだ． (詳しくは，最近急ピッチで充実されている<a href="https://wiki.hask.moe/">攻略Wiki</a>を読むといいんじゃないんかな？)</p>
<p>例えば，さっきから使っている <code>Config</code> 型を <code>extensible</code> レコード型で書くと次のように書ける</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds     #-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="ch">&#39;[ &quot;root&quot; &gt;: Text</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">   , <span class="st">&quot;path-format&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">   ]</a></code></pre></div>
<p>地味にうれしいことに，extensible であれば関数名では許されないハイフンが含んだフィールド名も定義できるのだ．</p>
<h2 id="リファクタリング">リファクタリング</h2>
<p><code>Data.Yaml.TH.decodeFile</code> を使うには <code>FromJSON</code> 型クラスと <code>Lift</code> 型クラスのインスタンスにしなければいけない． でも安心して欲しい． どちらも最新の extensible-0.4.9 では定義済みだ(そして extensible のレコードは <code>type</code> 宣言なので追加でインスタンスを定義する必要は無い)．</p>
<p>ただし，extensible-0.4.9 はまだ Stackage の LTS にも nightly にも追加されていないので <code>stack.yaml</code> に追加する必要がある．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-11.9</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">-</span> extensible-0.4.9</a></code></pre></div>
<p><code>Lift</code> 型クラスのインスタンスは extensible で定義済みなので1つ目のファイルを分けるはクリアーだ． 実は2つもクリアーしている． 拡張可能レコードの <code>FromJson</code> 型クラスのインスタンスは <code>&quot;path-format&quot;</code> のようなハイフンを含んだ文字列もそのまま扱ってくれる．</p>
<p>以下が extensible 版の <code>Config</code> 型に対応する YAML ファイルだ．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co"># template/.extensible-config.yaml</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="fu">columns:</span><span class="at"> 80</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="fu">language-extensions:</span><span class="at"> </span><span class="kw">[]</span></a></code></pre></div>
<p>試しに実行してみよう！</p>
<pre><code>$ stack ghci
&gt;&gt; Sample.Extensible.Config.defaultConfig
columns @= 80 &lt;: language-extensions @= [] &lt;: nil</code></pre>
<h2 id="デフォルトで置き換える">デフォルトで置き換える</h2>
<p>最後に簡単な実行ファイルを実装してみる． 設定ファイルのパスを与えると読みに行き，足りない部分は先ほどから埋め込んでるデフォルト値に置き換えて出力するモノだ．</p>
<pre><code>$ cat &quot;./template/.example.yaml&quot;
columns: 100
$ stack exec -- pconfig &quot;./template/.example.yaml&quot;
columns @= 100 &lt;: language-extensions @= [] &lt;: nil
$ stack exec -- pconfig
columns @= 80 &lt;: language-extensions @= [] &lt;: nil</code></pre>
<p>もちろんパスにファイルが無ければデフォルトのモノを出力するだけだ．</p>
<h2 id="section-1"></h2>
<p>さてどうすれば良いだろうか？ 例えば，<code>FromJSON</code> 型クラスの <code>Meybe a</code> 型のインスタンスはフィールドが無い場合に <code>Nothing</code> を与えてくれるので， <code>Config</code> 型の各フィールドを <code>Maybe</code> でラップするというのはどうだろう．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="ch">&#39;[ &quot;root&quot; &gt;: Maybe Text</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">   , <span class="st">&quot;path-format&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">   ]</a></code></pre></div>
<p>フィールドが2つなら良いが多くなってきたら辛そうだ…</p>
<h3 id="必殺-nullable">必殺 Nullable</h3>
<p>全てを <code>Meybe</code> でラップする場合は <a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Nullable.html"><code>Nullable</code></a> を使うと良いだろう(ないしは <code>RecordOf Maybe</code>)．</p>
<p><code>Nullable h :* xs</code> も既に <code>FromJson</code> 型クラスのインスタンスになっているのでそのまま YAML を読み込める． あとは次のようなデフォルト値と <code>Nullable</code> を与えたら <code>Nothing</code> の部分だけデフォルト値で置き換えた値を返す関数を実装してやればよい．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">fromNullable ::</span> <span class="dt">RecordOf</span> h xs <span class="ot">-&gt;</span> <span class="dt">Nullable</span> (<span class="dt">Field</span> h) <span class="fu">:*</span> xs <span class="ot">-&gt;</span> <span class="dt">RecordOf</span> h xs</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">fromNullable def <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  hmapWithIndex <span class="fu">$</span> \m x <span class="ot">-&gt;</span> fromMaybe (hlookup m def) (getNullable x)</a></code></pre></div>
<p>extensible ならこうやって全てのフィールドに対し走査する関数が使える．</p>
<h2 id="section-2"></h2>
<p>あとはこんな感じ</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">{-# LANGUAGE PolyKinds         #-}</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">RIO.Directory</span>      (doesFileExist)</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"></a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Yaml</span>          <span class="kw">as</span> <span class="dt">Y</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  path <span class="ot">&lt;-</span> fromMaybe <span class="st">&quot;&quot;</span> <span class="fu">.</span> listToMaybe <span class="fu">&lt;$&gt;</span> getArgs</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">  config <span class="ot">&lt;-</span> readConfigWith defaultConfig path</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">  hPutBuilder stdout <span class="fu">$</span> encodeUtf8Builder (tshow config)</a>
<a class="sourceLine" id="cb16-19" data-line-number="19"></a>
<a class="sourceLine" id="cb16-20" data-line-number="20"><span class="ot">readConfigWith ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb16-21" data-line-number="21">readConfigWith def path <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-22" data-line-number="22">  file <span class="ot">&lt;-</span> readFileBinaryWith <span class="st">&quot;&quot;</span> path</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">  <span class="kw">if</span> Y.decodeEither file <span class="fu">==</span> <span class="dt">Right</span> <span class="dt">Y.Null</span> <span class="kw">then</span></a>
<a class="sourceLine" id="cb16-24" data-line-number="24">    pure def</a>
<a class="sourceLine" id="cb16-25" data-line-number="25">  <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-26" data-line-number="26">    config <span class="ot">&lt;-</span> either (error <span class="fu">.</span> show) pure <span class="fu">$</span> Y.decodeEither&#39; file</a>
<a class="sourceLine" id="cb16-27" data-line-number="27">    pure <span class="fu">$</span> fromNullable def config</a>
<a class="sourceLine" id="cb16-28" data-line-number="28"></a>
<a class="sourceLine" id="cb16-29" data-line-number="29"><span class="ot">readFileBinaryWith ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb16-30" data-line-number="30">readFileBinaryWith def path <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-31" data-line-number="31">  doesFileExist path <span class="fu">&gt;&gt;=</span> bool (pure def) (readFileBinary path)</a></code></pre></div>
<p>いろいろとインポートするのがめんどくさくて <code>rio</code> ライブラリを使っているが，あんまり気にしないで．</p>
<h1 id="おしまい">おしまい</h1>
<p>ちなみに，<a href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html">前回の記事</a>に書いた <a href="https://github.com/matsubara0507/taskpad"><code>taskpad</code></a> にこの機能を追加してる．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>オレ的 Haskell で CLI を作る方法 2018</title>
    <link href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html" />
    <id>https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html</id>
    <published>2018-05-10T00:00:00Z</published>
    <updated>2018-05-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">オレ的 Haskell で CLI を作る方法 2018</h1>
    <p class="post-meta">
      <time datetime="2018-05-10" itemprop="datePublished">
        May 10, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/extensible-package.html">extensible-package</a> <a href="/tags/rio.html">rio</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>現在 <a href="https://github.com/matsubara0507/taskpad">TaskPad</a> という簡易的なタスク管理(編集)ツールを Haskell で作っていて，少し CLI を作るうえでのオレ的ノウハウが溜まったのでメモっとく．</p>
<h2 id="taskpad">TaskPad</h2>
<p>先に，何を作ってるかを書いておく． まだ完成していないが，気持ちは次のような Yaml ファイルを編集して自身のタスク管理をしようかなと考えている．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">memo:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="fu">tasks:</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">1:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="fu">done:</span><span class="at"> true</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="fu">children:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="fu">name:</span><span class="at"> hello</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="fu">2:</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="fu">done:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    <span class="fu">children:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    <span class="fu">name:</span><span class="at"> world</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="fu">date:</span><span class="at"> </span><span class="st">&#39;20180504&#39;</span></a></code></pre></div>
<p>現状できている CLI は次のような感じ</p>
<pre><code>$ taskpad --help
taskpad - operate daily tasks

Usage: taskpad [-v|--verbose] [-d|--date DATE] COMMAND [--version]

Available options:
  -v,--verbose             Enable verbose mode: verbosity level &quot;debug&quot;
  -d,--date DATE           Task&#39;s date
  --version                Show version
  -h,--help                Show this help text

Available commands:
  new                      Create a new task file. Note: if don&#39;t use --date
                           option then use today&#39;s date.
  add                      Add Task
  done                     Done Task
  tasks                    Show Tasks</code></pre>
<p><code>taskpad new</code> で Yaml ファイルを生成し，<code>taskpad add &quot;hoge&quot;</code> “hoge” というタスクを追加し，<code>taskpad done 1</code> で1番目のタスクを完了したことにし，<code>taskpad tasks</code> でタスクの一覧を出力する．</p>
<h2 id="ノウハウ">ノウハウ？</h2>
<p>たぶん他ではあんまり書いてない，いくつかのことを書いておく．</p>
<ul>
<li>optparse-applicative + extensible を使った CLI のオプションパーサー
<ul>
<li>特にサブコマンドをバリアントで表現しているのが面白い</li>
</ul></li>
<li>optparse-applicative でバージョンを表示</li>
<li>バリアントと型クラスを用いた分岐</li>
<li>rio + extensible で大域変数</li>
<li>rio を用いてロギング</li>
</ul>
<p>オプションパーサーに <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> を用いている． オプションパーサーには <a href="https://hackage.haskell.org/package/optparse-simple">optparse-simple</a> や <a href="https://hackage.haskell.org/package/optparse-generic">optparse-generics</a> など他にもいくつかあるが，サブコマンドのような多少込み入ったコトをしようとすると optparse-applicative が欲しくなる． <a href="https://hackage.haskell.org/package/rio">rio</a> ライブラリは，なんとなく最近使っている alt. Prelude ライブラリ(詳しくは<a href="https://github.com/commercialhaskell/rio#readme">本家の README</a> か<a href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html">前の僕の記事</a>を読んで)． <a href="https://hackage.haskell.org/package/extensible">extensible</a> は Haskell の残念なレコード構文や直和型の代わりに，拡張可能なレコード・バリアント型を提供してくれる面白いパッケージだ．</p>
<h3 id="import-と言語拡張">import と言語拡張</h3>
<p>extensible はかなり言語拡張を用いる． 以降では，めんどくさいので <code>import</code> も含め明示的に扱わない． 以下のコードが先頭にくっついてるとビルドはできるはずだ(たぶん，試してない)．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds             #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">{-# LANGUAGE FlexibleContexts      #-}</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">{-# LANGUAGE OverloadedLabels      #-}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">{-# LANGUAGE TypeApplications      #-}</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">{-# LANGUAGE TypeFamilies          #-}</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="ot">{-# LANGUAGE TypeOperators         #-}</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span>          <span class="kw">as</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">RIO.Time</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="kw">import</span>           <span class="dt">Data.Functor.Identity</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="kw">import</span>           <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17"><span class="kw">import</span>           <span class="dt">GHC.TypeLits</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="kw">import</span>           <span class="dt">Options.Applicative</span></a></code></pre></div>
<h3 id="extensible-で-optparse-applicative">extensible で optparse-applicative</h3>
<p>少しだけ <code>optparse-applicative</code> について説明しておく． optparse-applicative は CLI オプションをパースして任意の型にマッピングしてくれる． 主に次のようにして用いる．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">main <span class="fu">=</span> run <span class="fu">=&lt;&lt;</span> execParser opts</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    opts <span class="fu">=</span> info (options <span class="fu">&lt;**&gt;</span> helper)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">         <span class="fu">$</span> fullDesc</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="fu">&lt;&gt;</span> header <span class="st">&quot;taskpad - operate daily tasks&quot;</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="ot">options ::</span> <span class="dt">Parser</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">options <span class="fu">=</span> undefined</a></code></pre></div>
<p><a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:execParser"><code>execParser</code></a> 関数は <code>ParserInfo a -&gt; IO a</code> という型を持つ． <a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:helper"><code>helper :: Parser (a -&gt; a)</code></a> は <code>--help</code> オプションを与えてくれる関数だ． <code>info</code> 関数と <code>fullDesc</code> や <code>header</code> により，<code>Parser a</code> 型のパーサーに対し <code>--help</code> で出力する情報を追加して <code>ParserInfo a</code> 型に変換する．</p>
<h4 id="型の定義">型の定義</h4>
<p><code>extensible</code> で <code>optparse-applicative</code> を使うとは即ち，任意の型，ここでいう <code>Options</code> 型が拡張可能レコードや拡張可能バリアントであるというシチュエーションだ． 今回は <code>Options</code> 型をまずは次のように定義した．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Options</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ch">&#39;[ &quot;verbose&quot; &gt;: Bool</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">   , <span class="st">&quot;date&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">   , <span class="st">&quot;subcmd&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">   ]</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">type</span> <span class="dt">SubCmd</span> <span class="fu">=</span> <span class="dt">Variant</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  <span class="ch">&#39;[ &quot;new&quot;   &gt;: ()</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">   , <span class="st">&quot;add&quot;</span>   <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">   , <span class="st">&quot;done&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">   , <span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">   ]</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="kw">type</span> <span class="dt">Date</span> <span class="fu">=</span> <span class="dt">Text</span></a></code></pre></div>
<p><code>SubCmd</code> 型が拡張可能なバリアント型だ． ちなみに，Haskell のプリミティブな代数型データ構造で記述すると以下のようになる．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Options</span> <span class="fu">=</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  {<span class="ot"> verbose ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  ,<span class="ot"> date    ::</span> <span class="dt">Maybe</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  ,<span class="ot"> subcmd  ::</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">data</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="fu">=</span> <span class="dt">New</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  <span class="fu">|</span> <span class="dt">Done</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  <span class="fu">|</span> <span class="dt">Tasks</span></a></code></pre></div>
<p>自分的に，extensible を使う利点は3つある．</p>
<ol type="1">
<li>フィールド名と関数名の名前空間が別なので衝突が無い</li>
<li><code>type</code> 宣言によりレコードに対しいちいち型クラスのインスタンスを定義する必要が無い(既にあるものは)</li>
<li>型レベルリストによってフィールド全体に対する走査を行える</li>
</ol>
<p>逆にデメリットは，(2) にも関係するのだが，<code>type</code> 宣言のためインスタンスの定義が衝突することがしばしばある(これはインスタンスのスコープをコントロールできないという Haskell 全体での問題でもある)．</p>
<h4 id="拡張可能レコードのパーサー">拡張可能レコードのパーサー</h4>
<p>まずは拡張可能レコード(<code>Options</code> 型)のパーサーを書いてみる． バリアント(<code>SubCmd</code> 型)のは <code>undefined</code> としておこう． 細かい <code>optparse-applicative</code> の構文は割愛する．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">options ::</span> <span class="dt">Parser</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">options <span class="fu">=</span> hsequence</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="fu">$</span> <span class="fu">#</span>verbose <span class="fu">&lt;@=&gt;</span> switch (long <span class="st">&quot;verbose&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">&#39;v&#39;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Enable verbose mode: verbosity level \&quot;debug\&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">   <span class="fu">&lt;:</span> <span class="fu">#</span>date    <span class="fu">&lt;@=&gt;</span> optional (strOption (long <span class="st">&quot;date&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">&#39;d&#39;</span> <span class="fu">&lt;&gt;</span> metavar <span class="st">&quot;DATE&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Task&#39;s date&quot;</span>))</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">   <span class="fu">&lt;:</span> <span class="fu">#</span>subcmd  <span class="fu">&lt;@=&gt;</span> subcmdParser</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">subcmdParser <span class="fu">=</span> undefined</a></code></pre></div>
<p>拡張可能レコードの値を構築するには <code>#fieldName @= fieldValue</code> というの <code>&lt;:</code> で直列につないでいく(細かくは extensible の解説記事を読んで)． <code>&lt;@=&gt;</code> 演算子はモナドなフィールドの値を持ち上げてくれるバージョンの <code>@=</code> 演算子だ． <code>$</code> の右側は，正確には違うが，次の型のようなイメージとなる．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ch">&#39;[ Parser (&quot;verbose&quot; &gt;: Bool)</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"> , <span class="dt">Parser</span> (<span class="st">&quot;date&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Date</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"> , <span class="dt">Parser</span> (<span class="st">&quot;subcmd&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">SubCmd</span>)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"> ]</a></code></pre></div>
<p>Haskeller っであれば，後はリスト型で言う <code>sequence</code> できれば良さそうとわかるだろう． その型レベルリスト版が <code>hsequence</code> だ．</p>
<h4 id="拡張可能バリアントのパーサー">拡張可能バリアントのパーサー</h4>
<p>さて，今回の自分的なメインディッシュだ． 仮に通常の直和型であれば次のように書くだろう．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">subcmdParser <span class="fu">=</span> subparser</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">$</span> command <span class="st">&quot;new&quot;</span>   (pure <span class="dt">New</span> <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;add&quot;</span>   (<span class="dt">Add</span> <span class="fu">&lt;$&gt;</span> strArgument (metavar <span class="st">&quot;TEXT&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;done&quot;</span>  (<span class="dt">Done</span> <span class="fu">&lt;$&gt;</span> argument auto (metavar <span class="st">&quot;ID&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;tasks&quot;</span> (pure <span class="dt">Tasks</span> <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="ot">withInfo ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ParserInfo</span> a</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">withInfo opts <span class="fu">=</span> info (helper <span class="fu">&lt;*&gt;</span> opts) <span class="fu">.</span> progDesc</a></code></pre></div>
<p>この程度のサブコマンドならそこまで複雑じゃなく書けた． しかし悲しいことに，例えば <code>command &quot;tasks&quot;</code> の行が無くてもビルドは通る． 即ち，<strong>直和型に対し網羅性を型検査で保証することが出来ない</strong>．</p>
<h2 id="section"></h2>
<p>対して extensible のバリアントならどうだろうか． 理想的にはバリアントと同じフィールドを持つレコードの各要素が <code>ParserInfo a</code> であるような値から自動で導出してくれると良い． つまり次のように扱いたい．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">subcmdParser <span class="fu">=</span> variantFrom</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="fu">$</span> <span class="fu">#</span>new   <span class="fu">@=</span> (pure () <span class="ot">`withInfo`</span> <span class="st">&quot;Create a new task file. Note: if don&#39;t use --date option then use today&#39;s date.&quot;</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">   <span class="fu">&lt;:</span> <span class="fu">#</span>add   <span class="fu">@=</span> (strArgument (metavar <span class="st">&quot;TEXT&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Task contents&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;Add Task&quot;</span>)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">   <span class="fu">&lt;:</span> <span class="fu">#</span>done  <span class="fu">@=</span> (argument auto (metavar <span class="st">&quot;ID&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Done task from id&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;Done Task&quot;</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">   <span class="fu">&lt;:</span> <span class="fu">#</span>tasks <span class="fu">@=</span> (pure () <span class="ot">`withInfo`</span> <span class="st">&quot;Show Tasks&quot;</span>)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">variantFrom ::</span> <span class="dt">RecordOf</span> <span class="dt">ParserInfo</span> xs <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Variant</span> xs)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">variantFrom <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Wrapper</span> <span class="dt">ParserInfo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">  <span class="kw">type</span> <span class="dt">Repr</span> <span class="dt">ParserInfo</span> a <span class="fu">=</span> <span class="dt">ParserInfo</span> a</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">  _Wrapper <span class="fu">=</span> id</a></code></pre></div>
<p><code>@=</code> と <code>&lt;:</code> で構築したレコードが <code>Record = RecordOf Identity</code> ではなく，<code>RecordOf h</code> であるためには <code>h</code> が <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Wrapper.html#t:Wrapper"><code>Wrapper</code></a> 型クラスのインスタンスである必要がある(というかインスタンスでありさえすれば良い)．</p>
<h2 id="section-1"></h2>
<p>さてキモは <code>variantFrom</code> だ． 通常の直和型版の <code>subcmdParser</code> 関数を見ればわかるように，<code>command</code> 関数で作成した値をモノイドで畳み込めばいいので，お察しの通り(??) <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#v:hfoldMap"><code>hfoldMap</code></a> を使う． ついでに <code>command</code> の一引数目に渡すサブコマンドの文字列はフィールド名から取得するようにしよう． この場合，インデックスと <code>KnownSymbol</code> 制約を渡す必要があるので <code>hfoldMap</code> の代わりに <code>hfoldMapWithIndexFor</code> 関数を使う．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">variantFrom ::</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="dt">Forall</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>) xs <span class="ot">=&gt;</span> <span class="dt">RecordOf</span> <span class="dt">ParserInfo</span> xs <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Variant</span> xs)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">variantFrom <span class="fu">=</span> subparser <span class="fu">.</span> subcmdVariant</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    subcmdVariant <span class="fu">=</span> hfoldMapWithIndexFor (<span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>)) <span class="fu">$</span> \m x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">      <span class="kw">let</span> k <span class="fu">=</span> symbolVal (proxyAssocKey m)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">      <span class="kw">in</span> command k ((<span class="dt">EmbedAt</span> m <span class="fu">.</span> <span class="dt">Field</span> <span class="fu">.</span> pure) <span class="fu">&lt;$&gt;</span> getField x)</a></code></pre></div>
<p>結果として，<strong>extensible のバリアント版は網羅性を型検査によって検証できるようになった！</strong></p>
<h3 id="バージョンの表示">バージョンの表示</h3>
<p>バージョンの表示は他のコマンドと違い，コマンドが間違って(例えばサブコマンドが無い)いても <code>--version</code> という引数さえあれば優先的にバージョンを表示する必要がある． そのようなオプションを追加する場合には <a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:infoOption"><code>infoOption</code></a> 関数を使う．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Paths_taskpad</span>       <span class="kw">as</span> <span class="dt">Meta</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Data.Version</span>        (<span class="dt">Version</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Version</span>        <span class="kw">as</span> <span class="dt">Version</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Development.GitRev</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">main <span class="fu">=</span> run <span class="fu">=&lt;&lt;</span> execParser opts</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    opts <span class="fu">=</span> info (options <span class="fu">&lt;**&gt;</span> version Meta.version <span class="fu">&lt;**&gt;</span> helper)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">         <span class="fu">$</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="ot">version ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">version v <span class="fu">=</span> infoOption (showVersion v)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    <span class="fu">$</span> long <span class="st">&quot;version&quot;</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">   <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Show version&quot;</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17"><span class="ot">showVersion ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">showVersion v <span class="fu">=</span> unwords</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">  [ <span class="st">&quot;Version&quot;</span></a>
<a class="sourceLine" id="cb12-20" data-line-number="20">  , Version.showVersion v <span class="fu">++</span> <span class="st">&quot;,&quot;</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">  , <span class="st">&quot;Git revision&quot;</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22">  , <span class="fu">$</span>(gitHash)</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">  , <span class="st">&quot;(&quot;</span> <span class="fu">++</span> <span class="fu">$</span>(gitCommitCount) <span class="fu">++</span> <span class="st">&quot; commits)&quot;</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24">  ]</a></code></pre></div>
<p><code>&lt;**&gt;</code> 演算子はただの <code>flip (&lt;*&gt;)</code> だ． ちなみに，<code>version</code> と <code>helper</code> の適用順を入れ替えると <code>--help</code> の表示がほんの少しだけ変わる．</p>
<h3 id="バリアントと型クラス">バリアントと型クラス</h3>
<p>こっからは <code>run :: Options -&gt; IO ()</code> 関数を考える．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">run ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  date <span class="ot">&lt;-</span> maybe getTodaysDate pure <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  matchField</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    undefined <span class="co">-- ???</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>getTodaysDate</code> 関数は自身で定義しているとする． <code>--date</code> オプションを指定しなかった場合には今日の日付を取得する． 問題はサブコマンドの分岐だ．</p>
<p>バリアントの分岐には <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"><code>matchField</code></a> 関数を用いる． <code>matchField</code> 関数の型は <code>RecordOf (Match h r) xs -&gt; VariantOf h xs -&gt; r</code> となる． 一引数目のレコードと二引数目のバリアントの <code>xs</code> が等しいということから共通のフィールドを期待しているのが分かるだろう． レコード側の各フィールドに，各バリアントに対するフィールドの値を受け取り <code>r</code> 型の返り値の関数を記述するといった具合だ(この部分が <code>Match h r</code> に集約されている)．</p>
<h2 id="section-2"></h2>
<p>今回は，このレコードの構築に型クラスを用いる． 以下のような型クラスを定義する．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Run</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="ot">  run&#39; ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">Date</span> <span class="ot">-&gt;</span> <span class="dt">AssocValue</span> kv <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>実装は置いておいて，インスタンスを与えてみよう．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  run&#39; _ _ _ <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;add&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  run&#39; _ _ _ <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;done&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  run&#39; _ _ _ <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  run&#39; _ _ _ <span class="fu">=</span> undefined</a></code></pre></div>
<p><code>run</code> 関数の <code>matchField</code> 関数の引数は次のようになる．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">run ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  date <span class="ot">&lt;-</span> maybe getTodaysDate pure <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  matchField</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run&#39; m date <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>Proxy @ Run</code> の <code>@</code> の部分は <code>TypeApplications</code> 拡張のモノだ． フィールドの値は <code>Identity x</code> 型として来るので <code>runIdentity</code> 関数を用いて剥がし，<code>run' m date</code> へと適用する． もちろんサブコマンドのインスタンスを書き忘れていた場合は，ちゃんと型検査に引っかかる！</p>
<h3 id="rio-で大域変数">rio で大域変数</h3>
<p><code>rio</code> で大域変数を扱うには <code>RIO env</code> モナドを用いる． 適当なアプリケーションモナドを定義してやろう． 今回はひとつしか大域変数が無いのであんまりメリットを感じないかもしれないが…</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TaskPad</span> <span class="fu">=</span> <span class="dt">RIO</span> <span class="dt">Env</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="ch">&#39;[ &quot;date&quot; &gt;: Date</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">   ]</a></code></pre></div>
<p><code>run</code> 関数も書き直してやる．</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">run ::</span> <span class="dt">MonadUnliftIO</span> m <span class="ot">=&gt;</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  date <span class="ot">&lt;-</span> maybe getTodaysDate pure <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>date   <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">         <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  runRIO env <span class="fu">$</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    matchField</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run&#39; m <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">      (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a>
<a class="sourceLine" id="cb18-10" data-line-number="10"></a>
<a class="sourceLine" id="cb18-11" data-line-number="11"><span class="kw">class</span> <span class="dt">Run</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="ot">  run&#39; ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">AssocValue</span> kv <span class="ot">-&gt;</span> <span class="dt">TaskPad</span> ()</a></code></pre></div>
<p>試しに <code>new</code> サブコマンドを書いてみよう．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  run&#39; _ _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    date <span class="ot">&lt;-</span> asks (view <span class="fu">#</span>date)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    writeMemo <span class="fu">$</span> mkMemo date</a></code></pre></div>
<p><code>mkMemo</code> や <code>writeMemo</code> については次のように定義している． <code>Memo</code> 型も拡張可能レコードだ． 最近の extensible のアップデートで拡張可能レコードが <code>ToJson</code> 型クラスと <code>FromJson</code> 型クラスのインスタンスになったので，Yaml への変換は特にインスタンスを書くことなく行えるようになった．</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Yaml</span> <span class="kw">as</span> <span class="dt">Y</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Memo</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  <span class="ch">&#39;[ &quot;date&quot;  &gt;: Date</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">   , <span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">   , <span class="st">&quot;memo&quot;</span>  <span class="fu">&gt;:</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">   ]</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9"><span class="kw">type</span> <span class="dt">Task</span> <span class="fu">=</span> <span class="dt">Record</span> (<span class="dt">TaskFields</span> <span class="fu">++</span> <span class="ch">&#39;[&quot;children&quot; &gt;: [SubTask]])</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="kw">type</span> <span class="dt">SubTask</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="dt">TaskFields</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11"></a>
<a class="sourceLine" id="cb20-12" data-line-number="12"><span class="kw">type</span> <span class="dt">TaskFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  <span class="ch">&#39;[ &quot;name&quot; &gt;: Text</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">   , <span class="st">&quot;done&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-15" data-line-number="15">   ]</a>
<a class="sourceLine" id="cb20-16" data-line-number="16"></a>
<a class="sourceLine" id="cb20-17" data-line-number="17"><span class="ot">mkMemo ::</span> <span class="dt">Date</span> <span class="ot">-&gt;</span> <span class="dt">Memo</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18">mkMemo date</a>
<a class="sourceLine" id="cb20-19" data-line-number="19">    <span class="fu">=</span> <span class="fu">#</span>date  <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">   <span class="fu">&lt;:</span> <span class="fu">#</span>tasks <span class="fu">@=</span> mempty</a>
<a class="sourceLine" id="cb20-21" data-line-number="21">   <span class="fu">&lt;:</span> <span class="fu">#</span>memo  <span class="fu">@=</span> mempty</a>
<a class="sourceLine" id="cb20-22" data-line-number="22">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb20-23" data-line-number="23"></a>
<a class="sourceLine" id="cb20-24" data-line-number="24"><span class="ot">writeMemo ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Memo</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">writeMemo memo <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-26" data-line-number="26">  writeFileBinary (Text.unpack <span class="fu">$</span> memo <span class="fu">^.</span> <span class="fu">#</span>date <span class="fu">&lt;&gt;</span> <span class="st">&quot;.yaml&quot;</span>) (Y.encode memo)</a></code></pre></div>
<h3 id="rio-でロギング">rio でロギング</h3>
<p>ロギングは実用アプリケーションの重要な要素だろう． <code>rio</code> であればまぁまぁ簡単に書ける．</p>
<p>まずは <code>Env</code> にロギング用の関数を足してやる． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogFunc"><code>LogFunc</code></a> 型や <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:HasLogFunc"><code>HasLogFunc</code></a> 型クラスは <code>rio</code> ライブラリに定義されているものだ．</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="ch">&#39;[ &quot;date&quot;   &gt;: Date</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">   , <span class="st">&quot;logger&quot;</span> <span class="fu">&gt;:</span> <span class="dt">LogFunc</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">   ]</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">HasLogFunc</span> <span class="dt">Env</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  logFuncL <span class="fu">=</span> lens (view <span class="fu">#</span>logger) (\x y <span class="ot">-&gt;</span> x <span class="fu">&amp;</span> <span class="fu">#</span>logger <span class="ot">`set`</span> y)</a></code></pre></div>
<p>実はこれだけで <code>TaskPad</code> モナド(すなわち <code>RIO Env</code> モナド)の中で自由にロギング関数を呼べるようになる． 試しに <code>new</code> サブコマンドにロギングを足してみよう． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logInfo"><code>logInfo</code></a> 関数がロギング関数のひとつだ．</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  run&#39; _ _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    date <span class="ot">&lt;-</span> asks (view <span class="fu">#</span>date)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    writeMemo <span class="fu">$</span> mkMemo date</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    logInfo (display <span class="fu">$</span> <span class="st">&quot;create new task&#39;s file: &quot;</span> <span class="fu">&lt;&gt;</span> date <span class="fu">&lt;&gt;</span> <span class="st">&quot;.yaml&quot;</span>)</a></code></pre></div>
<p>あとは <code>run</code> 関数を書き換えよう(<code>Env</code> 型の中身が変わったので)．</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">run ::</span> <span class="dt">MonadUnliftIO</span> m <span class="ot">=&gt;</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  date    <span class="ot">&lt;-</span> maybe getTodaysDate pure <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  logOpts <span class="ot">&lt;-</span> logOptionsHandle stdout (opts <span class="fu">^.</span> <span class="fu">#</span>verbose)</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  withLogFunc logOpts <span class="fu">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>date   <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">           <span class="fu">&lt;:</span> <span class="fu">#</span>logger <span class="fu">@=</span> logger</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">           <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    runRIO env <span class="fu">$</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">      matchField</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">        (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run&#39; m <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">        (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>LogFunc</code> 型の値を得るには <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:withLogFunc"><code>withLogFunc</code></a> 関数を用いるのが良いだろう． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogOptions"><code>LogOptions</code></a> 型の値(ここでいう <code>logOpts</code>)を生成する <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logOptionsHandle"><code>logOptionsHandle</code></a> 関数の二引数目に <code>True</code> を与えることでログがデバッグ仕様になる(そういえば <code>Options</code> 型には <code>--verbose</code> オプションがあった)． ちなみに，デバッグ仕様のときにだけ表示するロギング関数として <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logDebug"><code>logDebug</code></a> 関数がある．</p>
<h2 id="おしまい">おしまい</h2>
<p>早く完成させるぞ</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>rio ライブラリを試す その１</title>
    <link href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html" />
    <id>https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html</id>
    <published>2018-04-13T00:00:00Z</published>
    <updated>2018-04-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">rio ライブラリを試す その１</h1>
    <p class="post-meta">
      <time datetime="2018-04-13" itemprop="datePublished">
        Apr 13, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/rio.html">rio</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>先日，alt. <code>Prelude</code> を目指している <a href="https://hackage.haskell.org/package/rio"><code>rio</code></a> ライブラリの ver.0.1 がリリースされました． 自作している CLI ツールを試しに <code>rio</code> で置き換えようかとしてまして，自分の整理のためにまとめてみようと思います．</p>
<h2 id="section"></h2>
<p>ただし，<code>rio</code> 作者ではないし，全部をちゃんと追っていないので間違っているかも． 間違っている場合は<a href="https://github.com/matsubara0507/source-gh-pages">このリポジトリに Issue</a> するか <a href="https://www.reddit.com/r/haskell_jp">Reddit</a> でコメントでもしてください m(_ _ )m</p>
<h1 id="readme-でひとめぐり">README でひとめぐり</h1>
<p>もともとはビルドツール Stack を作成するために考えたデザインパターンをまとめたものっぽい．</p>
<ul>
<li><a href="https://www.fpcomplete.com/blog/2017/07/the-rio-monad">The RIO Monad</a></li>
</ul>
<p><code>rio</code> ライブラリの README にはライブラリのゴール・目的の他に(彼らにとっての)ベストプラクティスが書いてある(<code>rio</code> 自体がそれに則って作られてる)． ここには翻訳というより，README の各項目の要約を記述する．</p>
<h2 id="goal">Goal</h2>
<p><code>rio</code> ライブラリのゴール(目的)は以下の3つ．</p>
<ol type="1">
<li>よく設計された信頼できるライブラリのコレクション</li>
<li>より優れた Prelude の代替え</li>
<li>高品質な Haskell コードを書くためのベストプラクティス</li>
</ol>
<p>(1)により <code>text</code> や <code>bytesyring</code> のような，ほとんど <code>base</code> のようなパッケージを <code>dependencies</code> に列挙する必要が無くなる． (3)は大域変数(<code>Reader</code> モナド)やロガーのような実用モナド回りのベストプラクティスが目玉かな(他にもあるけど)．</p>
<h2 id="標準ライブラリ">標準ライブラリ</h2>
<p>いくつかのパッケージを「標準」ライブラリとして再エクスポートしている． <code>rio</code> の<a href="https://github.com/commercialhaskell/rio/blob/311549f5a7c29abf6fc25e3ba7ec5ab6647e2d96/rio/package.yaml#L14">依存関係</a>を見る限り，次のパッケージを再エクスポートしているようだ．</p>
<ul>
<li>bytestring</li>
<li>containers</li>
<li>deepseq</li>
<li>directory</li>
<li>exceptions</li>
<li>filepath</li>
<li>hashable</li>
<li>lens(microlens)</li>
<li>process</li>
<li>text</li>
<li>time</li>
<li>unliftio</li>
<li>unordered-containers</li>
<li>vector</li>
</ul>
<p>もちろん，元のパッケージの全ての関数や型を再エクスポートしているのではなく，取捨選択して再エクスポートしている． また，後述する <code>Prelude</code> の代わりである <a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html"><code>RIO</code></a> モジュールに含まれるものもあれば，<code>RIO.XXX</code> として別のモジュールとして提供されているものもある．</p>
<h3 id="lens">Lens</h3>
<p><code>lens</code> の場合，申し訳程度の関数しか再エクスポートされていない． 基本的に <code>set</code>・<code>sets</code>・<code>over</code>・<code>to</code> だけだ． 演算子は参照の <code>(.^)</code> しかない． 今後どうなるか分からないが，現状 <code>(.~)</code> や <code>(%~)</code> は無いので替わりに関数を中置演算子にして使うしか無さそうだ．</p>
<h2 id="prelude-の代替え"><code>Prelude</code> の代替え</h2>
<p><code>Prelude</code> の代替えとして <a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html"><code>RIO</code></a> モジュールというのがある． README には部分関数や遅延 I/O のような，よく問題になるものを削除していると書いてある． また，<code>Data.Maybe</code> や <code>Control.Arrow</code> のような良く使う <code>base</code> ライブラリのモジュールが再エクスポートされていたり，<code>mapLeft</code> や <code>whenM</code> のような良く使いそうなのに <code>base</code> には無い関数が<a href="https://github.com/commercialhaskell/rio/blob/e8c4cba69599aecd9f91c4398aea47ab4eadbb07/rio/src/RIO/Prelude/Extra.hs">定義されている</a>． 正直，この辺りがすごい便利．</p>
<h2 id="ベストプラクティス">ベストプラクティス</h2>
<p>ココからが長い + 意見の分かれるところ． 結構 <code>TODO</code> と書いてあるところも多いので彼らの中でもまとまってないのかな？？</p>
<h3 id="インポートプラクティス">インポートプラクティス</h3>
<p>以下をやってほしいらしい</p>
<ul>
<li><code>NoImplicitPrelude</code> 言語拡張をオン</li>
<li>全てのモジュールに <code>import RIO</code> を追加 (すごいめんどい)</li>
<li>必要に応じて <code>RIO.XXX</code> モジュールを <code>qualified</code> を使ってインポート
<ul>
<li>適切な <code>qualified</code> の付け方は各モジュールの Haddock の冒頭に書いてある</li>
<li>例えば <a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO-ByteString.html"><code>import qualified RIO.ByteString as B</code></a> とか</li>
<li>ドキュメントに <code>qualified</code> が書いてない場合は <code>qualified</code> しなくていいのかな？？(例えば <a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO-Directory.html"><code>RIO.Directory</code></a> とか)</li>
</ul></li>
<li>中置演算子は <code>qualified</code> しなくていい(他のモジュールと衝突しない限りは)</li>
</ul>
<h3 id="言語拡張">言語拡張</h3>
<p>「言語拡張を使わないプロジェクトなんて，最近じゃほとんどないよね」とか書いてある． 以下の観点を基にデフォルトで利用しても良さそうな言語拡張を選定したそうだ．</p>
<ul>
<li>コミュニティで受け入れられている</li>
<li>コードを壊すようなことが <strong>ほとんど</strong> ない</li>
<li><strong>一般的に</strong> 安全だと考えられている</li>
</ul>
<p>割と断言していないのが面白い(笑) 推奨する言語拡張はこちら</p>
<pre><code>AutoDeriveTypeable
BangPatterns
BinaryLiterals
ConstraintKinds
DataKinds
DefaultSignatures
DeriveDataTypeable
DeriveFoldable
DeriveFunctor
DeriveGeneric
DeriveTraversable
DoAndIfThenElse
EmptyDataDecls
ExistentialQuantification
FlexibleContexts
FlexibleInstances
FunctionalDependencies
GADTs
GeneralizedNewtypeDeriving
InstanceSigs
KindSignatures
LambdaCase
MultiParamTypeClasses
MultiWayIf
NamedFieldPuns
NoImplicitPrelude
OverloadedStrings
PartialTypeSignatures
PatternGuards
PolyKinds
RankNTypes
RecordWildCards
ScopedTypeVariables
StandaloneDeriving
TupleSections
TypeFamilies
TypeSynonymInstances
ViewPatterns</code></pre>
<p><code>RecordWildCards</code> と <code>OverloadedStrings</code> は議論の余地あり的なことが書いてある(詳しくはもとの README を見て)．</p>
<h3 id="ghcオプション">GHCオプション</h3>
<p>以下を使いなさいとのコト．</p>
<pre><code>-Wall
-Wcompat
-Wincomplete-record-updates
-Wincomplete-uni-patterns
-Wredundant-constraints</code></pre>
<p>どういう形で指定してもいいけど，<code>package.yaml</code> で書くと楽だし，後述するテンプレートにも書く予定だそうだ． あと，プロダクションコードなら <code>-Werror</code> をオンにして，最後には確認した方が良いとも書いてある(CIとかでチェックしたいよね)．</p>
<h3 id="monads">Monads</h3>
<p>まってました！ モナドです． 実用的なプロジェクトを考えるとき，必要になってくるのが大域変数・ロガー・例外・IO だと思うので，気になるのはこの辺りだよね．</p>
<p>全体としての推奨事項は以下の通り．</p>
<ul>
<li><code>IO</code> を使いたいときは <code>RIO</code> モナドを使いなさい．
<ul>
<li><code>RIO</code> モナドは <code>ReaderT env IO</code> と同じだけど，<code>rio</code> には <code>RIO</code> モナドに対する補助関数が含まれるのでぜひ使って．<br />
</li>
</ul></li>
<li><code>RIO</code> モナドで <code>env</code> の参照関数を書くときは，具体的な型に対する参照関数を書かずに，型クラスを用いた多相的な関数を書くべき(詳しくは後述)
<ul>
<li><code>Has</code> スタイルの型クラスを使えば lens を利用することが出来るよ</li>
</ul></li>
<li>いくつかの良い <code>mtl</code> スタイルの型クラスも利用する必要は出てくるはず
<ul>
<li>ただし，推奨しているのは <code>MonadReader</code> <code>MonadIO</code> <code>MonadUnliftIO</code> <code>PrimMonad</code></li>
<li><code>MonadReader</code> + <code>Has</code> の方が <code>MonadLogger</code> のように新しい型クラスを作るより優れていると思う</li>
<li>特に <code>MonadBase</code> <code>MonadBaseControl</code> <code>MonadMask</code> <code>MonadCatch</code> は避けるべき</li>
</ul></li>
</ul>
<h4 id="大域変数">大域変数</h4>
<p><code>env</code> 回りについて． <code>Has</code> スタイル(パターン)というのがあって，それ自体はこの<a href="https://hackernoon.com/the-has-type-class-pattern-ca12adab70ae">ページ</a>が参考になるのかな？ <code>env</code> から何らかの値を参照する場合には</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">myFunction ::</span> <span class="dt">RIO</span> <span class="dt">Config</span> <span class="dt">Foo</span></a></code></pre></div>
<p>のような関数は <strong>やめて</strong> ，次のように書くのを推奨している．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">class</span> <span class="dt">HasConfig</span> env <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  configL ::</span> <span class="dt">Lens&#39;</span> env <span class="dt">Config</span> <span class="co">-- more on this in a moment</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">myFunction ::</span> <span class="dt">HasConfig</span> env <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Foo</span></a></code></pre></div>
<p>ここで，<code>env</code> は次のようなレコードを想定しており</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Env</span> {<span class="ot"> envConfig ::</span> <span class="fu">!</span><span class="dt">Config</span> }</a></code></pre></div>
<p>こうすることで，<code>env</code> に複数の大域変数を持たせても，うまく機能させることが出来る． また，次のように <code>Env</code> と <code>Config</code> それぞれでインスタンスを定義することで，それぞれで利用できる．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">HasConfig</span> <span class="dt">Config</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  configL <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">HasConfig</span> <span class="dt">Env</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  configL <span class="fu">=</span> lens envConfig (\x y <span class="ot">-&gt;</span> x { envConfig <span class="fu">=</span> y })</a></code></pre></div>
<h4 id="ロガー">ロガー</h4>
<p>ロガーも同様に <code>Has</code> スタイルを推奨している． <code>env</code> にログを出力するための関数(<a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#t:LogFunc"><code>LogFunc</code></a> 型のもの)を持たせる．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Env</span> {<span class="ot"> envLogFunc ::</span> <span class="fu">!</span><span class="dt">LogFunc</span>,<span class="ot"> envConfig ::</span> <span class="fu">!</span><span class="dt">Config</span> }</a></code></pre></div>
<p>これの <code>Has</code> スタイル型クラスは <code>RIO</code> モジュールに<a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#t:HasLogFunc">定義してある</a>．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">HasLogFunc</span> <span class="dt">Env</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  logFuncL <span class="fu">=</span> lens envLogFunc (\x y <span class="ot">-&gt;</span> x { envLogFunc <span class="fu">=</span> y })</a></code></pre></div>
<p><code>LogFunc</code> 型の値を渡すには <a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:withLogFunc"><code>withLogFunc</code></a> 関数を用いるようだ(<a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:mkLogFunc"><code>mkLogFunc</code></a> 関数もあるがアドバンスドと書いてある．)．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  envConfig <span class="ot">&lt;-</span> getConfig</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  logOpts <span class="ot">&lt;-</span> logOptionsHandle stdout <span class="dt">False</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  withLogFunc logOpts <span class="fu">$</span> \envLogFunc <span class="ot">-&gt;</span> runRIO <span class="dt">Env</span>{<span class="fu">..</span>} action</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="ot">action ::</span> <span class="dt">RIO</span> <span class="dt">Env</span> ()</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">action <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<h4 id="例外">例外</h4>
<p>例外をどのように表現すべきかは結構議論されており，今のところの基本的アイデアは以下の通り．</p>
<ul>
<li><code>lookup</code> のような単純に失敗する関数(部分関数になり得る？)の場合は <code>Maybe</code> や <code>Either</code> を返そう</li>
<li>それらを使いたくない場合(大域脱出とか？)は例外を使って
<ul>
<li>純粋なコード(IOではなく)の場合は <code>MonadThrow</code> 制約を使う</li>
<li><code>IO</code> の場合は <code>thorowIO</code> を介した実行時例外を使う(<code>RIO</code> モナドも同じ)</li>
</ul></li>
<li>「IOアクションがどのように失敗するかを正確に把握できないことにより，不安と不満を感じるかもしれない．しかし，その痛みを受け入れて共存し内在化して，<code>tryAny</code> を用いて移動してください．これは非同期例外に対して支払う代償です．」
<ul>
<li>ちょっと何言ってるかよくわからない…</li>
</ul></li>
<li>全てのリソース割り当ては <code>bracket</code> や <code>finally</code> のような関数で行う</li>
</ul>
<p>以下のようにして，アプリ専用の例外を定義し使用することが推奨されている．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">AppExceptions</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">NetworkChangeError</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">FilePathError</span> FilePath</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">ImpossibleError</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="kw">deriving</span> (<span class="dt">Typeable</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">AppExceptions</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">AppExceptions</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">  show <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    <span class="dt">NetworkChangeError</span> err <span class="ot">-&gt;</span> <span class="st">&quot;network error: &quot;</span> <span class="fu">&lt;&gt;</span> (unpack err)</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    <span class="dt">FilePathError</span> fp <span class="ot">-&gt;</span> <span class="st">&quot;error accessing filepath at: &quot;</span> <span class="fu">&lt;&gt;</span> fp</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    <span class="dt">ImpossibleError</span> <span class="ot">-&gt;</span> <span class="st">&quot;this codepath should never have been executed. Please report a bug.&quot;</span></a></code></pre></div>
<p>ちなみに，<code>Exception</code> 型クラス(というか <a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/Control-Exception-Base.html#t:SomeException"><code>SomeException</code></a> 型)は，いわゆる存在型を利用して具体型(<code>AppExceptions</code> とか)を隠蔽している．</p>
<h2 id="section-1"></h2>
<p>疑問なところは，投げた例外を <code>catch</code> してからディスパッチして良いのだろうか？ 実行時例外じゃなくて大域脱出をしたいだけなんだけどな． ちょっとイマイチ使い方が分からない．</p>
<h3 id="strict">Strict</h3>
<p>特別な理由が無い限り，データフィールド(レコードのフィールド？？)は正格にすべき，とのこと． 割と重要そうなのに一文しかない．</p>
<h3 id="プロジェクトテンプレート">プロジェクトテンプレート</h3>
<p>そのうち，新しい Stack テンプレートを作るそうだ． もちろん，<code>cabal</code> ファイルは使わず <code>hpack</code> を使用する．</p>
<h3 id="安全第一">安全第一</h3>
<p><code>rio</code> は安全性を最優先しており，そのため部分関数と遅延 I/O を全力で避けている． もし，遅延 I/O を使いたい場合は <code>conduit</code> のようなストリーミングライブラリを使いなさい，とのこと．</p>
<h3 id="一般化">一般化</h3>
<p>Haskell のよくある疑問として，いつ一般化すべきか，というのがある(いつ？)． README にはいくつかの簡単なガイドラインが書いてある．</p>
<p>パラメトリック多相の場合，わりと議論の余地が無く，多相的な方が有用． つまり，<code>reverse :: [a] -&gt; [a]</code> は <code>reverse :: [Int] -&gt; [Int]</code> より優れている．</p>
<p>型クラスの場合は話が微妙になる． <code>Foldable</code> や <code>Traversable</code> のような <code>RIO</code> で定義済みの型クラスには可能な限り一般化(インスタンスを定義)するのが良いだろう． しかし，本当の疑問は <strong>自身で型クラスを定義すべきかどうか</strong> の場合． 原則としては可能な限りそれは避けるべきだ． もし，自身で型クラスを定義している場合は，<strong>自分が期待していなかった型がインスタンス化されてもバグが起きないよう</strong> に気を付けること，とのこと．</p>
<h3 id="コーディングスタイル">コーディングスタイル</h3>
<p>議論中だそうだ．</p>
<h3 id="モジュール階層">モジュール階層</h3>
<p><code>RIO.Prelude.XXX</code> モジュールはドキュメントを Haddock で読みやすくするための階層で，個別にインポートすることを想定しているわけではない． と書いてあるが，結局 <a href="https://github.com/commercialhaskell/rio/pull/72">ver.0.1 からは Haddock からも消えてしまった</a>ので気にする必要はない．</p>
<h1 id="io-まわり">I/O まわり</h1>
<p>(この話は README に書いてあるわけではないです)</p>
<p><code>RIO</code> モジュールには文字列型(<code>String</code>)の一般的な <code>putStr</code> や <code>getLine</code> のような I/O 関数は無い． 実用コードの場合，これらの関数を直接呼ぶことは稀だろうが，例えば CLI を作ったときに <code>--version</code> オプションでバージョン情報を出力したい場合などがある．</p>
<p>替わりとして次のような I/O 関数が提供されている．</p>
<ul>
<li><code>Strict.ByteString</code> 型の <code>putStr</code> や <code>getLine</code> であれば <code>RIO.ByteString</code> モジュールで再定義されている</li>
<li>ファイルの入出力であれば <code>RIO</code> モジュールに <code>Strict.ByteString</code> 版と <code>Text</code> 版が提供されている</li>
<li><code>Builder</code> 型の標準出力 <a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:hPutBuilder"><code>hPutBuilder</code></a> 関数ならある</li>
</ul>
<p>コンソールに対する I/O はどれを使うべきかはまだ<a href="https://github.com/commercialhaskell/rio/issues/5">議論中</a>みたいだ．</p>
<h1 id="おしまい">おしまい</h1>
<p>何となく<a href="https://github.com/matsubara0507/scrapbook/tree/rio">置き換えはできた</a>けど，例外や I/O 回りは良く分かってない… また試していこう．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>ML Day ＃1 に行ってきた</title>
    <link href="https://matsubara0507.github.io/posts/2018-04-02-ml-day-1.html" />
    <id>https://matsubara0507.github.io/posts/2018-04-02-ml-day-1.html</id>
    <published>2018-04-02T00:00:00Z</published>
    <updated>2018-04-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">ML Day ＃1 に行ってきた</h1>
    <p class="post-meta">
      <time datetime="2018-04-02" itemprop="datePublished">
        Apr 2, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/event.html">event</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://ml-lang.connpass.com/event/78199/">ML Day #1</a> というイベントに参加してきたので，そのメモ？まとめ？みたいな感じの記事です．</p>
<h2 id="section"></h2>
<p>ML Day は毎年やってるML勉強会というML系の発表会形式の勉強会のこと． (なぜか)名前を変えたらしい． ちなみに，今後は半年に一回ペースでやりたいらしい．</p>
<h2 id="ぼくのはなし">ぼくのはなし</h2>
<p>新設された LT 枠で発表してきた．</p>
<p>スライドはこれ</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/o84VhGTUREO4No" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen>
</iframe>
<p>さすがに Haskell の話をするのはアレだったので，Haskell の新しいモジュールシステム Backpack のベースになった MixML の話をした． この日までに(Haskellで)実装完了してドヤ顔する予定だったのだが全然終わらなかった orz (Alt braif*ck じゃなくて)ちゃんとした規模の処理系を実装するのって，大変なんですね…</p>
<h2 id="section-1"></h2>
<p>ちなみに，<a href="https://github.com/rossberg/mixml">SML/NJ で実装されたもの</a>があり，実質これを参考に Haskell で書き直すだけの作業． だけど SML -&gt; Haskell に直すのって大変，非純粋なものを純粋な世界にするって大変(そりゃそう)． 気軽に状態を持ちやがって…</p>
<h2 id="自分的ハイライト">自分的ハイライト</h2>
<p>濃い目の話が多かったのでざっくりと．</p>
<p>資料は既に<a href="https://ml-lang.connpass.com/event/78199/presentation/">ほとんど上がっている</a>．</p>
<h3 id="ml型付の基礎の基礎">ML型付の基礎の基礎</h3>
<ul>
<li>発表者は <a href="https://twitter.com/haochenxie">Haochen</a> くん
<ul>
<li>名〇屋で <a href="https://sicss.connpass.com/event/71199/">TaPL の読書会</a>を主催してるひと</li>
<li>こんど<a href="https://nupsc.sicss.org/">名古屋でプロコン</a>やるんだって</li>
</ul></li>
<li><a href="https://haochenxie.name/dl/the_introduction_of_foundation_of_ml_type_checking.pdf">資料はコレ</a></li>
<li>基礎 (foundation) の 基礎 (introduction) の話
<ol type="1">
<li>型は素晴らしい</li>
<li>でも型を書きたくない
<ul>
<li>プログラマは怠惰を美徳にしている生き物だもんね</li>
</ul></li>
<li>再構築すればいいじゃない！
<ul>
<li><del>型検査無しにもどるなんてのは論外</del></li>
</ul></li>
</ol></li>
<li>素晴らしい本(TaPL)と素晴らしい先生(ピアース先生)
<ul>
<li><del>ML Day 出る以上読め</del></li>
</ul></li>
<li>おまけとして let 多相の話もしてた</li>
<li><a href="https://sicss.connpass.com/event/83801/">5/6に論理プログラミング言語の第一人者の講演</a>を企画しているらしい
<ul>
<li><a href="https://readcoqart.connpass.com/event/83722/">Coq 勉強会</a>と被ってるのがなぁぁぁぁ</li>
</ul></li>
</ul>
<h2 id="tba">TBA</h2>
<ul>
<li>発表者は<a href="https://twitter.com/pi8027">坂口和彦</a>さん
<ul>
<li>PPL2018 のポスター賞の人でその話を</li>
</ul></li>
<li>発表スライドは上がってないけど <a href="http://logic.cs.tsukuba.ac.jp/~sakaguchi/posters/ppl2018.pdf">PPL2018 のポスター</a>はあった</li>
<li>Coq でリストの置換(permutation)の自動証明(だったかな)
<ul>
<li>証明の過程をいろいろ話してくれた</li>
<li>(がぼくはよくわかってない)</li>
</ul></li>
<li><a href="http://www.sqlab.jp/FLOPS2018/">FLOPS’18</a> に通ったので発表するらしい</li>
<li>質問: 項書き換えでできないの？
<ul>
<li>中野先生に聞かれた(PPLで？？)</li>
<li>出来たら教えてといって何もないのでできないんじゃない？</li>
</ul></li>
</ul>
<h2 id="型つき組版処理システムsatysfi">型つき組版処理システムSATySFi</h2>
<ul>
<li>発表者は <a href="https://twitter.com/bd_gfngfn">bd_gfngfn</a> 氏</li>
<li>資料は<a href="https://drive.google.com/file/d/1BB7ZAiwPO3hVtq7PGImPtMs1-kOd7SzW/view">コレ</a></li>
<li>彼の有名な <a href="https://github.com/gfngfn/SATySFi">型つき組版処理システムSATySFi</a> の話
<ul>
<li>目標: L〇TeX を倒す</li>
<li>目標: エラーの可読性向上(大事)</li>
<li>ML系に似た組版用型システムが載っている
<ul>
<li>let 多相もレコード多相もある</li>
<li>しかし GADT や Functor はまだ</li>
</ul></li>
<li>「いきなり PDF がでまして」をよく言っていた(笑)<br />
</li>
</ul></li>
<li>質問: 構文にポリシーはあるの？
<ul>
<li>ML系の文法にしたい(けど LaTeX に寄せたほうが…)</li>
</ul></li>
</ul>
<h2 id="mlでつくる拡張可能インタプリタ">MLでつくる拡張可能インタプリタ</h2>
<ul>
<li>発表者は <a href="https://twitter.com/linerlock">linerlock</a> 氏
<ul>
<li>今日までつくば大生
<ul>
<li><del>これのせいで二番煎じに</del></li>
</ul></li>
</ul></li>
<li>資料は<a href="https://speakerdeck.com/takahisa/extensible-interpreter-in-ml">コレ</a></li>
<li>言語開発 <strong>も</strong> モジュラーにしたいので拡張可能なインタプリタを作ればいいじゃない
<ul>
<li><a href="https://github.com/takahisa/kennel">コレ</a>のことかな？</li>
<li>例えば超簡易的な自作言語に新しくリスト追加してと言われても簡単にできるように</li>
<li>評価器は楽しいので(拡張可能な評価器の)研究が多い</li>
<li>構文解析は無い…なのでここをサイボウズラボユースでやった(？)
<ul>
<li>構文解析の無い言語なんてないのにね</li>
<li>作ったの<a href="https://github.com/takahisa/finale">コレ</a>かな？</li>
</ul></li>
<li>「(BNFに新しい構文を)上に足すか下に足すか、花火じゃないけど」
<ul>
<li>上に足すか下に足すかで意味が変わることが…</li>
<li>そこで最長一致法 : 全部試して一番長いのをとる</li>
</ul></li>
<li>型とか最適化とかできてない</li>
</ul></li>
</ul>
<h3 id="lt">LT</h3>
<p>は割愛(つかれた)． ラインナップは</p>
<ul>
<li>自作言語を OCaml で作り直したら ML みたいなコア言語になってしまったという話</li>
<li>Elm の紹介</li>
<li>OCaml の祖先 CAML の解説</li>
<li>自作したパーサージェネレーターの紹介</li>
<li>Verifastの辛い話(<del>古いOCamlを使うのつらいという愚痴</del>)</li>
</ul>
<p>LT の資料は全部 connpass にあがっている．</p>
<h3 id="コンパイラバックエンド">コンパイラバックエンド</h3>
<ul>
<li>発表者は<a href="">インターネットの闇</a>さん
<ul>
<li>この会の主催者(？)</li>
</ul></li>
<li>OCaml のソースコードを皆で読もうの会
<ul>
<li><strong>バックエンドはコンパイラのコト</strong>
<ul>
<li>not Webバックエンド</li>
</ul></li>
<li>ガリグ先生しか読めない化け物(type系)</li>
<li>OCaml のバックは副作用ガンガン使う、FPとは？GC付きのC</li>
</ul></li>
</ul>
<h3 id="bucklescriptでノベルゲームdslを作る">BuckleScriptでノベルゲームDSLを作る</h3>
<ul>
<li>発表者は[pocketberserker]氏
<ul>
<li>普段は F# の人</li>
<li>F# ネタが切れた</li>
</ul></li>
<li>資料は<a href="https://github.com/pocketberserker/ml_day_1">ココ</a>
<ul>
<li>資料もこの DSL で書かれたもの(？？)</li>
<li>ノベルゲーなのでバックができない(笑)</li>
<li>発表者はデバッグモードで戻ってた</li>
</ul></li>
<li>ノベルゲーDSLを作りたい遺伝子を持ってしまったので作るという話
<ul>
<li><a href="https://github.com/cowlick/cowlick">つくったやつ</a></li>
<li>自分が今書いてるのはS式なのか？？？？S式が分からなくなる</li>
<li><del><strong>Reason を ML ユーザーが触るべきではない！</strong></del></li>
</ul></li>
</ul>
<h2 id="感想">感想</h2>
<ul>
<li>濃い(誉め言葉)</li>
<li>後半は疲れてしまった(ごめん)</li>
<li><strong>質問時間を含めて発表時間(律儀に終わる必要はない)</strong></li>
</ul>
<h2 id="おしまい">おしまい</h2>
<p>MixML 完成させてリベンジ発表したい</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>多相バリアントを使いこなそう with Haskell</title>
    <link href="https://matsubara0507.github.io/posts/2018-03-24-poly-variant-with-haskell.html" />
    <id>https://matsubara0507.github.io/posts/2018-03-24-poly-variant-with-haskell.html</id>
    <published>2018-03-24T00:00:00Z</published>
    <updated>2018-03-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">多相バリアントを使いこなそう with Haskell</h1>
    <p class="post-meta">
      <time datetime="2018-03-24" itemprop="datePublished">
        Mar 24, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/extensible-package.html">extensible-package</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://sampou.connpass.com/event/80492/">この前の「『Haskellによる関数プログラミングの思考法』読書会」</a>の後の懇親会(？)で <strong>多相バリアント</strong> の話になりまして，その時に以下の記事が話題にあがった．</p>
<ul>
<li><a href="http://osiire.hatenablog.com/entry/20090510/1241957550">多相バリアントを使いこなそう(1) - osiire’s blog</a></li>
<li><a href="http://osiire.hatenablog.com/entry/20090512/1242055541">多相バリアントを使いこなそう(2) - osiire’s blog</a></li>
<li><a href="http://osiire.hatenablog.com/entry/20090514/1242235108">多相バリアントを使いこなそう(3) - osiire’s blog</a></li>
<li><a href="http://osiire.hatenablog.com/entry/20090516/1242456737">多相バリアントを使いこなそう(4) - osiire’s blog</a></li>
</ul>
<p>これらの記事は OCaml で多相バリアントの紹介をしています． ということで，同様の議論を Haskell でもしてみた！というのが，この記事の内容です．</p>
<h2 id="section"></h2>
<p>(2018.04.13 追記アリ)</p>
<h3 id="haskell-と多相バリアント">Haskell と多相バリアント</h3>
<p>悲しいことに，Haskell には組み込みで多相バリアントは無い(バリアントとは Haskell の代数的データ型における直和型と概ね一緒)． なので，多相バリアントを Haskell で模倣するために，毎度おなじみ <a href="https://hackage.haskell.org/package/extensible"><code>extensible</code></a> パッケージを用いる．</p>
<h2 id="section-1"></h2>
<p>ネタバレをすると Haskell で同じことをするのは難しかった． なので，本質的な議論は osiire’s blog の方を読んだ方がいいと思うよ． 結局，本記事は osiire’s blog のと同様のことを Haskell もとい，<code>extensible</code> パッケージでどのように行うか，という記事って感じになった．</p>
<h2 id="多相バリアントの基本">多相バリアントの基本</h2>
<p>多相バリアントとは，名前の通り，多相的なバリアントである． バリアントは前述したとおり，直和型と基本的に同じ．</p>
<p>例えば，普通の直和型として次のようなものがあったとする．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Joker</span> <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span> <span class="dt">InData</span> <span class="fu">=</span> <span class="dt">Str</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Int</span></a></code></pre></div>
<p>「最初の型はジョーカーと数字札があるトランプの型，次の型は何かファイルからデータを読み込む時に文字列と数字のデータを統一的に扱うための型」だそうです(<a href="http://osiire.hatenablog.com/entry/20090510/1241957550">多相バリアントを使いこなそう(1)</a> より)． どちらの型にも <code>Number Int</code> という部分があるので次のような関数を両方に適用できそうな気がする．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">getNumber (<span class="dt">Number</span> n) <span class="fu">=</span> <span class="dt">Just</span> n</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">getNumber _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>もちろん，そんなことはできない(そもそも，Haskell の値コンストラクタは名前空間を共有してしまうので同時に利用はできないのだが…)． そこで多相バリアントを用いれば，このような関数を実装することが出来るようになる．</p>
<h3 id="多相バリアントを定義">多相バリアントを定義</h3>
<p><code>extensible</code> パッケージを使って多相バリアント(拡張可能バリアント)を定義すると次のようになる(<code>DataKinds</code> と <code>TypeOperators</code> 言語拡張が必要)．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="ch">&#39;[ &quot;joker&quot; &gt;: (), &quot;number&quot; &gt;: Int ]</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">type</span> <span class="dt">InData</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="ch">&#39;[ &quot;str&quot; &gt;: String, &quot;number&quot; &gt;: Int ]</span></a></code></pre></div>
<p>とくに細かい説明はしないが，なんとなく意味が読み取れるだろう． <code>getNumber</code> 関数の実装は難しいので後回しにするとして，<code>getNumber</code> 関数の型は <code>extensible</code> パッケージの <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#t:-8838-"><code>⊆</code></a> 型クラスを用いて次のように書ける(意味は見た通り)．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">getNumber ::</span> (<span class="ch">&#39;[&quot;number&quot; &gt;: Int] ⊆ xs) =&gt; Variant xs -&gt; Maybe Int</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">getNumber <span class="fu">=</span> undefined</a></code></pre></div>
<p>GHCi で試してみる．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t getNumber (undefined<span class="ot"> ::</span> <span class="dt">Card</span>)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">getNumber (undefined<span class="ot"> ::</span> <span class="dt">Card</span>)<span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t getNumber (undefined<span class="ot"> ::</span> <span class="dt">InData</span>)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">getNumber (undefined<span class="ot"> ::</span> <span class="dt">InData</span>)<span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a></code></pre></div>
<p>確かに動作する．</p>
<h2 id="包含関係">包含関係</h2>
<p>さて，<code>getNumber</code> 関数をどのように実装するかだが，その前に多相バリアントの包含関係を議論しておく(この議論は<a href="http://osiire.hatenablog.com/entry/20090514/1242235108">多相バリアントを使いこなそう(3)</a>に対応する)．</p>
<p>次のような簡単なバリアント型を考える．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Hoge</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">HogeFields</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">type</span> <span class="dt">HogeFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="ch">&#39;[ &quot;hoge&quot; &gt;: ()</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">   , <span class="st">&quot;fuga&quot;</span> <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">   ]</a></code></pre></div>
<p>このバリアント型に対し，<code>⊆</code> を用いて多相的な関数は2種類考えれる．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">toInt1 ::</span> (<span class="dt">HogeFields</span> ⊆ xs) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">toInt1 <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="ot">toInt2 ::</span> (xs ⊆ <span class="dt">HogeFields</span>) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">toInt2 <span class="fu">=</span> undefined</a></code></pre></div>
<p><code>toInt1</code> は <code>&quot;hoge&quot; &gt;: ()</code> と <code>&quot;fuga&quot; &gt;: ()</code> を要素に持つバリアント型全てが利用できる関数である(さっきの <code>getNumber</code> と同じ)． <code>toInt2</code> は <code>&quot;hoge&quot; &gt;: ()</code> か <code>&quot;fuga&quot; &gt;: ()</code> のどれかを要素に持つ(それ以外は持ってはいけない)バリアント型全てに利用できる関数である． 試しに，次の3つのバリアント型の値を定義し，GHCi で試してみよう．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">hoge1 ::</span> <span class="dt">Hoge</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">hoge1 <span class="fu">=</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>hoge <span class="fu">@=</span> ()</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">hoge2 ::</span> <span class="dt">Variant</span> (<span class="st">&quot;piyo&quot;</span> <span class="fu">&gt;:</span> () <span class="ch">&#39;: HogeFields)</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">hoge2 <span class="fu">=</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>piyo <span class="fu">@=</span> ()</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">hoge3 ::</span> <span class="dt">Variant</span> <span class="ch">&#39;[&quot;hoge&quot; &gt;: ()]</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">hoge3 <span class="fu">=</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>hoge <span class="fu">@=</span> ()</a></code></pre></div>
<p>見てわかるように(？)，<code>hoge3 ⊆ hoge1 ⊆ hoge2</code> である(厳密にはバリアントの要素の集合で成り立つ関係だが)．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt1 hoge1</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">toInt1<span class="ot"> hoge1 ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt1 hoge2</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">toInt1<span class="ot"> hoge2 ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt1 hoge3</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    <span class="fu">?</span> <span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘<span class="ch">&#39;Missing (&quot;fuga&quot; &#39;</span><span class="fu">:&gt;</span> ())’</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">                     with ‘<span class="ch">&#39;Expecting pos0’</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        arising from a use <span class="kw">of</span> ‘toInt1’</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    <span class="fu">?</span> <span class="dt">In</span> the expression<span class="fu">:</span> toInt1 hoge3</a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt2 hoge1</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">toInt2<span class="ot"> hoge1 ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt2 hoge2</a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    <span class="fu">?</span> <span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘<span class="ch">&#39;Missing (&quot;piyo&quot; &#39;</span><span class="fu">:&gt;</span> ())’</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">                     with ‘<span class="ch">&#39;Expecting pos0’</span></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">        arising from a use <span class="kw">of</span> ‘toInt2’</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">    <span class="fu">?</span> <span class="dt">In</span> the expression<span class="fu">:</span> toInt2 hoge2</a>
<a class="sourceLine" id="cb9-21" data-line-number="21"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt2 hoge3</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">toInt2<span class="ot"> hoge3 ::</span> <span class="dt">Int</span></a></code></pre></div>
<p>確かに，<code>toInt1</code> は <code>hoge1</code> と <code>hoge2</code> に適用でき，<code>toInt2</code> は <code>hoge1</code> と <code>hoge3</code> に適用できている．</p>
<h2 id="section-2"></h2>
<p>さて，<code>toInt1</code> と <code>toInt2</code> の実装を与えてみる． 実は簡単なのは後者 <code>toInt2</code> だ．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">toInt2 ::</span> (xs ⊆ <span class="dt">HogeFields</span>) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">toInt2 <span class="fu">=</span> flip matchField (spread<span class="ot"> xs ::</span> <span class="dt">Hoge</span>)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="fu">$</span> <span class="fu">#</span>hoge <span class="fu">@=</span> (const <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">   <span class="fu">&lt;:</span> <span class="fu">#</span>fuga <span class="fu">@=</span> (const <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">   <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p>(<a href="https://matsubara0507.github.io/posts/2017-11-28-fun-of-extensible-1.html">昔の記事</a>でも紹介した) <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#v:spread"><code>spread</code></a> 関数を用いることで <strong>バリアント型を拡張できる</strong> (<a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"><code>matchField</code></a> 関数の使い方についてはこの<a href="https://matsubara0507.github.io/posts/2018-01-31-fun-of-extensible-2.html">記事</a>を参照して)．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">shrink ::</span> (xs ⊆ ys) <span class="ot">=&gt;</span> <span class="dt">Record</span> ys <span class="ot">-&gt;</span> <span class="dt">Record</span> xs</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">spread ::</span> (xs ⊆ ys) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Variant</span> ys</a></code></pre></div>
<p><del>拡縮する関数 <code>spread</code> や <code>shrink</code> は強力なのだが，多相的すぎて前後の型が分からないとエラーになる(気がする(パッケージの作者じゃないので細かいことはよくわからん))ので，型注釈 (<code>spread xs :: Hoge</code> の部分)を与える必要がある．</del></p>
<p>(2018.04.13 追記) <code>spread</code> や <code>shrink</code> の代わりに <code>shrinkAssoc</code> や <code>spreadAssoc</code> を使えば値が多相でもうまく扱えるとのコトを<a href="https://www.reddit.com/r/haskell_jp/comments/86rx9b/多相バリアントを使いこなそう_with_haskell/dwaq3cw/">作者様よりコメント</a>いただいた． 感謝．</p>
<h3 id="必殺-coinclusion">必殺 Coinclusion</h3>
<p>前者が難しいのは，<code>spread</code> や <code>shrink</code> とは逆の振る舞いを要求するからだ． そのために(この前作者から教えてもらった隠し技(別に隠してない)) <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Nullable.html"><code>Nullable</code></a> を使う！ <code>Nullable</code> を使うとバリアントやレコードの全ての要素を簡単に <code>Maybe</code> でラップできる(なんかいいテーマがあったら，そのうち解説する)． さらに <code>Nullable</code> を用いることで，Coinclusion を定義できる！</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">wrench ::</span> (<span class="dt">Generate</span> ys, xs ⊆ ys) <span class="ot">=&gt;</span> (h <span class="fu">:*</span> xs) <span class="ot">-&gt;</span> <span class="dt">Nullable</span> h <span class="fu">:*</span> ys</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">retrench ::</span> (<span class="dt">Generate</span> ys, xs ⊆ ys) <span class="ot">=&gt;</span> (h <span class="fu">:|</span> ys) <span class="ot">-&gt;</span> <span class="dt">Nullable</span> ((<span class="fu">:|</span>) h) xs</a></code></pre></div>
<p><code>wrench</code> や <code>retrench</code> は <code>shrink</code> と <code>spread</code> の逆向きの変換になっているのが分かるだろうか？ 逆向きにしたせいで足りない部分は <code>Nullable</code> によって <code>Nothing</code> となる． 例えば <code>Variant (&quot;piyo&quot; &gt;: () ': HogeFields)</code> から <code>Hoge</code> に縮小する場合は，<code>embedAssoc (#piyo @= ())</code> が <code>Nothing</code> となり，他が <code>Just</code> でラップされる．</p>
<h2 id="section-3"></h2>
<p>Coinclusion を用いて <code>toInt2</code> 関数を実装してみると次のようになる．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">{-# LANGUAGE PolyKinds           #-}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">{-# LANGUAGE RankNTypes          #-}</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ot">toInt1 ::</span> (<span class="dt">Generate</span> xs, <span class="dt">HogeFields</span> ⊆ xs) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">toInt1 <span class="fu">=</span> matchFieldWithDefault <span class="dv">0</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="fu">$</span> <span class="fu">#</span>hoge <span class="fu">@=</span> (const <span class="dv">1</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">   <span class="fu">&lt;:</span> <span class="fu">#</span>fuga <span class="fu">@=</span> (const <span class="dv">2</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="ot">matchFieldWithDefault ::</span> forall xs ys h r <span class="fu">.</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  (<span class="dt">Generate</span> ys, xs ⊆ ys) <span class="ot">=&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">RecordOf</span> (<span class="dt">Match</span> h r) xs <span class="ot">-&gt;</span> <span class="dt">VariantOf</span> h ys <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">matchFieldWithDefault defaultValue pat <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">  fromMaybe defaultValue <span class="fu">.</span> matchFieldWithMaybe pat</a>
<a class="sourceLine" id="cb13-15" data-line-number="15"></a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="ot">matchFieldWithMaybe ::</span> forall xs ys h r <span class="fu">.</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">  (<span class="dt">Generate</span> ys, xs ⊆ ys) <span class="ot">=&gt;</span> <span class="dt">RecordOf</span> (<span class="dt">Match</span> h r) xs <span class="ot">-&gt;</span> <span class="dt">VariantOf</span> h ys <span class="ot">-&gt;</span> <span class="dt">Maybe</span> r</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">matchFieldWithMaybe pat <span class="fu">=</span> matchWith func (wrench pat)</a>
<a class="sourceLine" id="cb13-19" data-line-number="19">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="ot">    func ::</span> forall x <span class="fu">.</span> <span class="dt">Nullable</span> (<span class="dt">Field</span> (<span class="dt">Match</span> h r)) x <span class="ot">-&gt;</span> <span class="dt">Field</span> h x <span class="ot">-&gt;</span> <span class="dt">Maybe</span> r</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">    func fx gx <span class="fu">=</span> (\x <span class="ot">-&gt;</span> runMatch (getField x) <span class="fu">$</span> getField gx) <span class="fu">&lt;$&gt;</span> getNullable fx</a></code></pre></div>
<p>めんどくさいので細かい解説はしない(そもそももっといい方法があるかもしれない)． この <code>matchFieldWithMaybe</code> を用いれば <code>getNumber</code> も簡単に実装できるだろう．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">getNumber ::</span> (<span class="dt">Generate</span> xs, <span class="ch">&#39;[&quot;number&quot; &gt;: Int] ⊆ xs) =&gt; Variant xs -&gt; Maybe Int</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">getNumber <span class="fu">=</span> matchFieldWithMaybe <span class="fu">$</span> <span class="fu">#</span>number <span class="fu">@=</span> id <span class="fu">&lt;:</span> nil</a></code></pre></div>
<h2 id="例-イベントを拡張する">例 : イベントを拡張する</h2>
<p>ここからは「多相バリアントを使いこなそう」で取り上げられてた例を Haskell で示そう． ひとつ目は次のふたつのイベント型を考える．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">type</span> <span class="dt">KeyboardEvent</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">KeyboardEventFields</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">type</span> <span class="dt">KeyboardEventFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ch">&#39;[ &quot;keyPress&quot; &gt;: Char</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">   , <span class="st">&quot;keyRelease&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   ]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">type</span> <span class="dt">MouseEvent</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">MouseEventFields</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="kw">type</span> <span class="dt">MouseEventFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="ch">&#39;[ &quot;mousePress&quot; &gt;: (Int, Int)</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">   , <span class="st">&quot;mouseRelease&quot;</span> <span class="fu">&gt;:</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">   , <span class="st">&quot;click&quot;</span> <span class="fu">&gt;:</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">   ]</a></code></pre></div>
<p>さて，これらの両方の型許容する型 <code>Event</code> を作りたい． 普通の直和型を用いて次のように書くことが出来る．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Event</span> <span class="fu">=</span> <span class="dt">Key</span> <span class="dt">KeyboardEvent</span> <span class="fu">|</span> <span class="dt">Mouse</span> <span class="dt">MouseEvent</span></a></code></pre></div>
<p>もちろん，これでは元のふたつの型をうまく再利用できていない． 既に何度か登場している型レベルリストの連結 <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#t:-43--43-"><code>++</code></a> を使って次のように書くこともできる．</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Event</span> <span class="fu">=</span> <span class="dt">Variant</span> (<span class="dt">KeyboardEventFields</span> <span class="fu">++</span> <span class="dt">MouseEventFields</span>)</a></code></pre></div>
<p>こうすると，<code>Event</code> 型と <code>KeyboardEvent</code> 型・<code>MouseEvent</code> 型には包含関係ができ，前述した <code>Hoge</code> 型で示した方法により各々で関数を共有することが出来る． 例えば次の <code>getCharFromEvent</code> 関数は <code>KeyboardEvent</code> 型と <code>Event</code> 型の両方で利用できる．</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">getCharFromEvent ::</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  (<span class="dt">Generate</span> xs, <span class="dt">KeyboardEventFields</span> ⊆ xs) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">getCharFromEvent <span class="fu">=</span> matchFieldWithDefault (error <span class="st">&quot;not a key&quot;</span>)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="fu">$</span> <span class="fu">#</span>keyPress   <span class="fu">@=</span> id</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">   <span class="fu">&lt;:</span> <span class="fu">#</span>keyRelease <span class="fu">@=</span> id</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">   <span class="fu">&lt;:</span> nil</a></code></pre></div>
<h2 id="例-トランプで-expression-problem">例 : トランプで Expression Problem</h2>
<p>Expression Problem が何なのかは各位ググってもらうとして，「多相バリアントを使いこなそう」の最後で紹介されていた，多相バリアントによる Expression Problem の解法を Haskell でもやってみる．</p>
<p>次のような型と関数があったとする．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">CardFields</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="kw">type</span> <span class="dt">CardFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="ch">&#39;[ &quot;number&quot; &gt;: Int</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">   , <span class="st">&quot;jack&quot;</span>   <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">   , <span class="st">&quot;queen&quot;</span>  <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">   , <span class="st">&quot;king&quot;</span>   <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">   ]</a>
<a class="sourceLine" id="cb19-8" data-line-number="8"></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">cardNum ::</span> <span class="dt">Card</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">cardNum <span class="fu">=</span> matchField cardNumPattern</a>
<a class="sourceLine" id="cb19-11" data-line-number="11"></a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="ot">cardNumPattern ::</span> <span class="dt">RecordOf</span> (<span class="dt">Match</span> <span class="dt">Identity</span> <span class="dt">Int</span>) <span class="dt">CardFields</span></a>
<a class="sourceLine" id="cb19-13" data-line-number="13">cardNumPattern</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    <span class="fu">=</span> <span class="fu">#</span>number <span class="fu">@=</span> id</a>
<a class="sourceLine" id="cb19-15" data-line-number="15">   <span class="fu">&lt;:</span> <span class="fu">#</span>jack   <span class="fu">@=</span> const <span class="dv">11</span></a>
<a class="sourceLine" id="cb19-16" data-line-number="16">   <span class="fu">&lt;:</span> <span class="fu">#</span>queen  <span class="fu">@=</span> const <span class="dv">12</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17">   <span class="fu">&lt;:</span> <span class="fu">#</span>king   <span class="fu">@=</span> const <span class="dv">13</span></a>
<a class="sourceLine" id="cb19-18" data-line-number="18">   <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p>(<code>cardNumPattern</code> を切り出しているのがあからさまに恣意的だが…)これに以下のことは可能だろうか？</p>
<ol type="1">
<li>静的で安全に(キャストせず)</li>
<li>元のコードを一切変更せず</li>
<li>新しい場合分けを加え</li>
<li>新しい操作も加えた</li>
<li>新しい場合分け構造を定義する</li>
</ol>
<p>最後の「構造」というのは今回は置いておいて(OCaml ではモジュールとして定義してたが，Haskell でモジュールに切り分けるにはファイルを切り分ける必要があるので…めんどい…)，1-4を考えてみよう． <code>Card</code> 型やその関数を拡張したものとして，次のような <code>CardExt</code> 型とその関数を定義した．</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">type</span> <span class="dt">CardExt</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">CardExtFields</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">type</span> <span class="dt">CardExtFields</span> <span class="fu">=</span> <span class="dt">CardFields</span> <span class="fu">++</span> <span class="ch">&#39;[&quot;joker&quot; &gt;: ()]</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">cardExtNum ::</span> <span class="dt">CardExt</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">cardExtNum <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  matchField <span class="fu">$</span> shrink (<span class="fu">#</span>joker <span class="fu">@=</span> (const <span class="dv">0</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="fu">&lt;:</span> cardNumPattern)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="ot">nextCardExt ::</span> <span class="dt">CardExt</span> <span class="ot">-&gt;</span> <span class="dt">CardExt</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">nextCardExt <span class="fu">=</span> matchField</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    <span class="fu">$</span> <span class="fu">#</span>number <span class="fu">@=</span> (\n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="fu">&lt;</span> <span class="dv">10</span> <span class="kw">then</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>number <span class="fu">@=</span> n <span class="fu">+</span> <span class="dv">1</span> <span class="kw">else</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>jack <span class="fu">@=</span> ())</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">   <span class="fu">&lt;:</span> <span class="fu">#</span>jack   <span class="fu">@=</span> const (embedAssoc <span class="fu">$</span> <span class="fu">#</span>queen  <span class="fu">@=</span> ())</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">   <span class="fu">&lt;:</span> <span class="fu">#</span>queen  <span class="fu">@=</span> const (embedAssoc <span class="fu">$</span> <span class="fu">#</span>king   <span class="fu">@=</span> ())</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">   <span class="fu">&lt;:</span> <span class="fu">#</span>king   <span class="fu">@=</span> const (embedAssoc <span class="fu">$</span> <span class="fu">#</span>joker  <span class="fu">@=</span> ())</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">   <span class="fu">&lt;:</span> <span class="fu">#</span>joker  <span class="fu">@=</span> const (embedAssoc <span class="fu">$</span> <span class="fu">#</span>number <span class="fu">@=</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">   <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p>これで一応</p>
<ol type="1">
<li>静的で安全に(もちろん!)</li>
<li>既存のコードを改造せず</li>
<li><code>&quot;joker&quot; &gt;: ()</code> という新しい場合分けを加え</li>
<li><code>nextCardExt</code> という新しい操作(関数)を加える</li>
</ol>
<p>ことができた．</p>
<h2 id="おしまい">おしまい</h2>
<p>組込みでこれらの機能がある OCaml はいいなぁとなった．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>tasty-discover が Windows+日本語環境で動かなかったので直す</title>
    <link href="https://matsubara0507.github.io/posts/2018-03-04-fix-tasty-discover-windows.html" />
    <id>https://matsubara0507.github.io/posts/2018-03-04-fix-tasty-discover-windows.html</id>
    <published>2018-03-04T00:00:00Z</published>
    <updated>2018-03-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">tasty-discover が Windows+日本語環境で動かなかったので直す</h1>
    <p class="post-meta">
      <time datetime="2018-03-04" itemprop="datePublished">
        Mar 4, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>おそらく少数派であろう Windows + 日本語環境の Haskeller のひげです．</p>
<p>最近は知人のすゝめで，Haskell のテストフレームワークに <a href="https://hackage.haskell.org/package/tasty"><code>tasty</code></a> を使ってます． <code>tasty</code> にも例に漏れず <a href="http://hackage.haskell.org/package/tasty-discover"><code>tasty-discover</code></a> というテスト用の関数を <code>.hs</code> ファイルから集めてきてくれるツールがある． しかし，悲しいことに <code>tasty-discover</code> がマルチバイト文字(日本語とか)を Windows で読み込むと <strong>いつもの</strong> エラーで死んでしまう．</p>
<p>なので，直して PR 出した． この記事はそのメモです．</p>
<h2 id="問題のエラー">問題のエラー</h2>
<pre><code>Building test suite &#39;test&#39; for tasty-discover-4.1.3..
tasty-discover: test\ConfigTest.hs: hGetContents: invalid argument (invalid byte sequence)
`tasty-discover&#39; failed in phase `Haskell pre-processor&#39;. (Exit code: 1)
Progress: 1/2
--  While building custom Setup.hs for package tasty-discover-4.1.3 using:
      C:\Users\Hoge\AppData\Roaming\stack\setup-exe-cache\i386-windows\Cabal-simple_Z6RU0evB_2.0.1.0_ghc-8.2.2.exe --builddir=.stack-work\dist\010ee936 build lib:tasty-discover exe:tasty-discover test:test --ghc-options &quot; -ddump-hi -ddump-to-file -fdiagnostics-color=always&quot;
    Process exited with code: ExitFailure 1</code></pre>
<p><code>hGetContents: invalid argument (invalid byte sequence)</code> は 日本語 Windows Haskeller なら親の顔より良く見るエラーメッセージですね(そんなことは無い)． このエラーは <code>hGetContents</code> で読み込もうとしているファイルの文字コードが，<code>hGetContents</code> で設定されている文字コードと違うために起きている(<code>hGetContents</code> 関数は，例えば <code>readFile</code> 関数などで呼び出されている)．</p>
<h2 id="対処法">対処法</h2>
<p>日本語 Windows Haskeller 筆頭の igrep 氏が Haskell-jp Blog に投稿してくれてる．</p>
<ul>
<li><a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html">WindowsでHaskellを扱う時によく遭遇するエラーと対処法 - Haskell-jp</a></li>
</ul>
<p>今回は(孫プロセスとして読んでるせいか)「それでもダメな場合」に当たる． つまり，場当たり的な解決方法(<code>chcp 65001</code> と打つとか)ではダメで，プログラムを修正するしかない．</p>
<h2 id="section"></h2>
<p>神な igrep 氏は，この場合の解決策も書いておいてくれた． この <a href="https://github.com/haskell/haddock/pull/566">PR</a> を参考にして書き換えてやればよい．</p>
<p><code>tasty-discover</code> も<a href="https://github.com/lwm/tasty-discover/pull/138/files">こんな感じに書き加えた</a>．</p>
<h2 id="pr-を出す">PR を出す</h2>
<p>修正自体は1時間ほどで終わり(移動中の新幹線の中で直した)，これでテストを実行できるようになったので PR を出さずに満足してしまった(あるある)． 半月ほどほっといてたら，同じケースで困った知り合いに <a href="https://github.com/lwm/tasty-discover/issues/135">Issue</a> を出されてしまった(笑)</p>
<p>しょうがないので PR を出そうとしたら，「Windows は良く分からないから，ぜひ Windows 環境用の自動テストも欲しい！」と<a href="https://github.com/lwm/tasty-discover/issues/127">作者に言われてしまった</a>(「時間があればやって」とね)．</p>
<h2 id="section-1"></h2>
<p><a href="https://www.appveyor.com/">AppVeyor</a> と言うのを使えばいいみたい． 調べたらサクッとできそうなので，やってみた．</p>
<ul>
<li><a href="https://www.snoyman.com/blog/2016/08/appveyor-haskell-windows-ci">Using AppVeyor for Haskell+Windows CI</a></li>
</ul>
<p>記事にある設定ファイルをそのままコピペしてやってみたが，問題がふたつあった． ひとつ目は，<code>tasty-discover</code> のテスト自体に <code>tasty-discover</code> を使っている点だ． 最初に <code>stack test</code> を実行するときにはまだ <code>tasty-discover</code> はインストールされてないのでテストが落ちてしまう．</p>
<pre><code>[2 of 2] Compiling Paths_tasty_discover ( .stack-work\dist\010ee936\build\tasty-discover\autogen\Paths_tasty_discover.hs, .stack-work\dist\010ee936\build\tasty-discover\tasty-discover-tmp\Paths_tasty_discover.o )
Linking .stack-work\dist\010ee936\build\tasty-discover\tasty-discover.exe ...
Preprocessing test suite &#39;test&#39; for tasty-discover-4.1.3..
Building test suite &#39;test&#39; for tasty-discover-4.1.3..
ghc.EXE: could not execute: tasty-discover</code></pre>
<p>なので，<code>stack test</code> する前に <code>stack install</code> することにした．</p>
<h2 id="section-2"></h2>
<p>ふたつ目は，そもそも WIndows のビルドが落ちる点． <code>System.FilePath</code> に関するバグだったので，<a href="https://github.com/lwm/tasty-discover/pull/136/files#diff-383b12983902facd1ce205458e1061b6">サクッと直した</a>． Windows のテストに関する <a href="https://github.com/lwm/tasty-discover/pull/136">PR</a> もマージされたので，本命の <a href="https://github.com/lwm/tasty-discover/pull/138">PR</a> も出した(これもマージされた)．</p>
<h2 id="今回の問題をテストする">今回の問題をテストする(？)</h2>
<p>今回の問題のテストも欲しいと言われた． <code>tasty-discover</code> のテスト自体が <code>tasty-discover</code> を使うため，ユニットテストとして表現できない． <code>stack test</code> そのものが落ちるか落ちないかのテストはできるが，それはなんか違うなぁと思い，結局コミットはしていない．</p>
<p>ただし，いちおう AppVeyor で<a href="https://ci.appveyor.com/project/matsubara0507/tasty-discover/build/1.0.9">再現できるようにはした</a>． AppVeyor はデフォルトだと日本語環境になっていない(即ち Shift-JIS じゃない)ため落ちない． なので，以下を参考にして日本語環境にして実行した．</p>
<ul>
<li><a href="https://github.com/appveyor/ci/issues/846">Support a different code page · Issue #846 · appveyor/ci</a></li>
</ul>
<pre><code>init:
- ps: Set-WinSystemLocale ja-JP
- ps: Start-Sleep -s 5
- ps: Restart-Computer</code></pre>
<p>というのを <code>appveyor.yml</code> に書き加えるだけで良い．</p>
<h2 id="おしまい">おしまい</h2>
<p>なんか <a href="https://github.com/lwm/tasty-discover/issues/139">Push 権限を貰った</a>． こういうこともあるんですね(OSS歴が浅いので驚いた)．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>拡張可能タングルでDo記法レスプログラミング♪ (Haskell)</title>
    <link href="https://matsubara0507.github.io/posts/2018-02-22-fun-of-extensible-3.html" />
    <id>https://matsubara0507.github.io/posts/2018-02-22-fun-of-extensible-3.html</id>
    <published>2018-02-22T00:00:00Z</published>
    <updated>2018-02-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">拡張可能タングルでDo記法レスプログラミング♪ (Haskell)</h1>
    <p class="post-meta">
      <time datetime="2018-02-22" itemprop="datePublished">
        Feb 22, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/extensible-package.html">extensible-package</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>「<a href="https://hackage.haskell.org/package/extensible"><code>extensible</code></a> パッケージの楽しみ その３」です．</p>
<p>拡張可能レコードやら Extensible Effect やら，Haskell の Extensible なものを全て統一された仕組みで提供する化け物パッケージ <a href="https://hackage.haskell.org/package/extensible-0.4.7.1"><code>extensible</code></a> について，割とドキュメントには無い(？)ネタを書いておくシリーズ第三弾です． ぼく自身は作者ではないし，間違っているかもなのでこの記事を完全には当てにしないでください．</p>
<p>また，現在の最新バージョンは 0.4.7.1 です(そのバージョンでハナシをしてる)．</p>
<h2 id="section"></h2>
<p><a href="/posts/2017-11-28-fun-of-extensible-1.html">前々回</a>は拡張可能レコードの拡縮の話を，<a href="/posts/2018-01-31-fun-of-extensible-2.html">前回</a>は拡張可能直和型(バリアント)を引数に取る関数の話を書きました．</p>
<p>今回は <strong>拡張可能タングル</strong> で遊んでみます． 今回の Haskell コードは基本的に<a href="https://gist.github.com/matsubara0507/be20aa514016c991f19f2e604409cd96">コレ</a>．</p>
<h2 id="拡張可能タングル">拡張可能タングル</h2>
<p>作者さんの拡張可能タングルについての記事があり，非常に分かりやすいです．</p>
<ul>
<li><a href="http://fumieval.hatenablog.com/entry/2016/12/18/181540">波打たせるものの正体(エクステンシブル・タングル) - モナドとわたしとコモナド</a></li>
</ul>
<p>拡張可能タングルを用いれば，文脈付き(<code>IO</code> などの <code>Monad</code> 型クラスのインスタンス)で拡張可能レコードを生成し，更にフィールド間で依存関係を持つ際に，型クラスを用いて各フィールドごとに振る舞いを記述できるようになる． まぁこのヒトコトでは伝わらないですよね．</p>
<p>百聞は一見に如かず．例えば</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Rec</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="dt">Fields</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">type</span> <span class="dt">Fields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="ch">&#39;[ &quot;hoge1&quot; &gt;: String</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">     , <span class="st">&quot;hoge2&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">     , <span class="st">&quot;hoge3&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">     ]</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">makeRec ::</span> <span class="dt">IO</span> <span class="dt">Rec</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">makeRec <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  hoge1 <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  hoge3 <span class="ot">&lt;-</span> randomRIO (<span class="dv">0</span>, <span class="dv">2</span> <span class="fu">*</span> length hoge1)</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  pure</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">     <span class="fu">$</span> <span class="fu">#</span>hoge1 <span class="fu">@=</span> hoge1</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="fu">&lt;:</span> <span class="fu">#</span>hoge2 <span class="fu">@=</span> (length hoge1 <span class="fu">&lt;=</span> hoge3)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="fu">&lt;:</span> <span class="fu">#</span>hoge3 <span class="fu">@=</span> hoge3</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    <span class="fu">&lt;:</span> emptyRecord</a></code></pre></div>
<p>というような関数があったとする． これを拡張可能タングルを使って書き直すと次のようになります．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">makeRec ::</span> <span class="dt">IO</span> <span class="dt">Rec</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">makeRec <span class="fu">=</span> runTangles tangles (wrench emptyRecord)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">type</span> <span class="dt">FieldI</span> <span class="fu">=</span> <span class="dt">Field</span> <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">tangles ::</span> <span class="dt">Comp</span> (<span class="dt">TangleT</span> <span class="dt">FieldI</span> <span class="dt">Fields</span> <span class="dt">IO</span>) <span class="dt">FieldI</span> <span class="fu">:*</span> <span class="dt">Fields</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">tangles <span class="fu">=</span> htabulateFor (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MakeRec</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  \m <span class="ot">-&gt;</span> <span class="dt">Comp</span> <span class="fu">$</span> <span class="dt">Field</span> <span class="fu">.</span> pure <span class="fu">&lt;$&gt;</span> make m</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="kw">class</span> <span class="dt">MakeRec</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="ot">  make ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">TangleT</span> <span class="dt">FieldI</span> <span class="dt">Fields</span> <span class="dt">IO</span> (<span class="dt">AssocValue</span> kv)</a>
<a class="sourceLine" id="cb2-12" data-line-number="12"></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">MakeRec</span> (<span class="st">&quot;hoge1&quot;</span> <span class="fu">&gt;:</span> <span class="dt">String</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  make _ <span class="fu">=</span> lift getLine</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">MakeRec</span> (<span class="st">&quot;hoge2&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  make _ <span class="fu">=</span> (<span class="fu">&lt;=</span>) <span class="fu">&lt;$&gt;</span> (length <span class="fu">&lt;$&gt;</span> lasso <span class="fu">#</span>hoge1) <span class="fu">&lt;*&gt;</span> lasso <span class="fu">#</span>hoge3</a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"><span class="kw">instance</span> <span class="dt">MakeRec</span> (<span class="st">&quot;hoge3&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  make _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21">    ml <span class="ot">&lt;-</span> length <span class="fu">&lt;$&gt;</span> lasso <span class="fu">#</span>hoge1</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">    lift <span class="fu">$</span> randomRIO (<span class="dv">0</span>, <span class="dv">2</span> <span class="fu">*</span> ml)</a></code></pre></div>
<p>コード量そのものは倍近くなっている． しかし，フィールドの構築方法ごとにインスタンスメソッドとして切り分けることが出来ている． しかも，<strong>摩訶不思議な <a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Tangle.html#v:lasso"><code>lasso</code></a> 関数により依存関係も勝手に解決してくれる</strong> ． もちろん，フィールドのインスタンスが足りないときは，足りないというコンパイルエラーになるよ．</p>
<h2 id="do記法レスプログラミング">Do記法レスプログラミング</h2>
<p>Haskell はなんらかの作用付きの振る舞いは次のように <code>Monad</code> と <code>do</code> 記法を用いて書くのが一般的だ． しかし，便利な Do 記法に甘えて無駄に長い，数十行もある Do 式を書いたことは無いだろうか？ たしかに(関数合成だけで記述するより)読みやすいが，なんかこう…ちがうじゃないですか！？</p>
<h2 id="section-1"></h2>
<p>そこで，先述した拡張可能タングルを用いて長いDo式をフィールドごとに切り分けてみよう． 例題として次のようなログ(っぽいなにか)を読み込む関数を考える．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Log</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="dt">LogFields</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">type</span> <span class="dt">LogFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="ch">&#39;[ &quot;path&quot;    &gt;: FilePath</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">     , <span class="st">&quot;time&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Time</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">     , <span class="st">&quot;code&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">     , <span class="st">&quot;message&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">     ]</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">type</span> <span class="dt">Time</span> <span class="fu">=</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">type</span> <span class="dt">LogCsv</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="dt">CsvFields</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="kw">type</span> <span class="dt">CsvFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    <span class="ch">&#39;[ &quot;time&quot;    &gt;: Time</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">     , <span class="st">&quot;info&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">LB.ByteString</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">     ]</a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="kw">type</span> <span class="dt">Info</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">    <span class="ch">&#39;[ &quot;code&quot;    &gt;: Int</span></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">     , <span class="st">&quot;message&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">     ]</a>
<a class="sourceLine" id="cb3-22" data-line-number="22"></a>
<a class="sourceLine" id="cb3-23" data-line-number="23"><span class="kw">type</span> <span class="dt">EIO</span> <span class="fu">=</span> <span class="dt">Eff</span></a>
<a class="sourceLine" id="cb3-24" data-line-number="24">    <span class="ch">&#39;[ EitherDef String</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25">     , <span class="st">&quot;IO&quot;</span> <span class="fu">&gt;:</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb3-26" data-line-number="26">     ]</a>
<a class="sourceLine" id="cb3-27" data-line-number="27"></a>
<a class="sourceLine" id="cb3-28" data-line-number="28"><span class="ot">runEIO ::</span> <span class="dt">EIO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> a)</a>
<a class="sourceLine" id="cb3-29" data-line-number="29">runEIO <span class="fu">=</span> retractEff <span class="fu">.</span> runEitherDef</a>
<a class="sourceLine" id="cb3-30" data-line-number="30"></a>
<a class="sourceLine" id="cb3-31" data-line-number="31"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-32" data-line-number="32">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-33" data-line-number="33">  result <span class="ot">&lt;-</span> runEIO <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-34" data-line-number="34">    (path<span class="fu">:</span>_) <span class="ot">&lt;-</span> liftIO getArgs</a>
<a class="sourceLine" id="cb3-35" data-line-number="35">    file <span class="ot">&lt;-</span>  liftIO (LB.readFile path)</a>
<a class="sourceLine" id="cb3-36" data-line-number="36">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb3-37" data-line-number="37">      csv <span class="fu">=</span> mconcat [header, <span class="st">&quot;\n&quot;</span>, file]</a>
<a class="sourceLine" id="cb3-38" data-line-number="38">    (_, logs) <span class="ot">&lt;-</span> either throwError pure (decodeByName csv)<span class="ot"> ::</span> <span class="dt">EIO</span> (<span class="dt">Header</span>, <span class="dt">LogCsv</span>)</a>
<a class="sourceLine" id="cb3-39" data-line-number="39">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb3-40" data-line-number="40">      log&#39; <span class="fu">=</span> V.head logs</a>
<a class="sourceLine" id="cb3-41" data-line-number="41">    info <span class="ot">&lt;-</span> either throwError pure (eitherDecode <span class="fu">$</span> log&#39; <span class="fu">^.</span> <span class="fu">#</span>info)<span class="ot"> ::</span> <span class="dt">EIO</span> <span class="dt">Info</span></a>
<a class="sourceLine" id="cb3-42" data-line-number="42">    pure <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-43" data-line-number="43">      <span class="fu">#</span>path <span class="fu">@=</span> path <span class="fu">&lt;:</span> <span class="fu">#</span>time <span class="fu">@=</span> (log&#39; <span class="fu">^.</span> <span class="fu">#</span>time) <span class="fu">&lt;:</span> info</a>
<a class="sourceLine" id="cb3-44" data-line-number="44">  either error print result</a>
<a class="sourceLine" id="cb3-45" data-line-number="45"></a>
<a class="sourceLine" id="cb3-46" data-line-number="46"><span class="ot">header ::</span> <span class="dt">LB.ByteString</span></a>
<a class="sourceLine" id="cb3-47" data-line-number="47">header <span class="fu">=</span> LB.intercalate <span class="st">&quot;,&quot;</span> <span class="fu">.</span> fmap fromString <span class="fu">$</span> henumerateFor</a>
<a class="sourceLine" id="cb3-48" data-line-number="48">  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">KeyValue</span> <span class="dt">KnownSymbol</span> <span class="dt">Show</span>))</a>
<a class="sourceLine" id="cb3-49" data-line-number="49">  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">CsvFields</span>)</a>
<a class="sourceLine" id="cb3-50" data-line-number="50">  ((<span class="fu">:</span>) <span class="fu">.</span> symbolVal <span class="fu">.</span> proxyAssocKey)</a>
<a class="sourceLine" id="cb3-51" data-line-number="51">  []</a></code></pre></div>
<p>このメイン関数は次のような CSV をログデータとして読み込んで，2行目の JSON もパースしたうえで，ひとつの拡張可能レコードとして吐き出す．</p>
<pre class="csv"><code>2018-02-23T03:10:00,&quot;{&quot;&quot;code&quot;&quot;:123,&quot;&quot;message&quot;&quot;:&quot;&quot;hello&quot;&quot;}&quot;</code></pre>
<p>正直，この例だと大した長さではないので切り分けるメリットはなーーんにもないんですけど．</p>
<h3 id="stack-script-とカスタムスナップショット"><code>stack script</code> とカスタムスナップショット</h3>
<p>その前に，このメイン関数をどうやって実行するか． この程度のモノをいちいち stack プロジェクトにしていてはスペースの無駄なので，<code>stack script</code> を使う．</p>
<p><code>stack script</code> コマンド知っていますか？ <code>stack runghc</code> と基本的には一緒なのだが，違いは2点(たぶん)．</p>
<ol type="1">
<li>resolver の指定が必須 (たしか <code>runghc</code> は指定しなければプロジェクトのを使うはず)</li>
<li><strong>パッケージを引数で指定する必要が無い</strong></li>
</ol>
<p>(2)がすごいよね． <code>runghc</code> の場合，使ってるパッケージを <code>--package hoge</code> と一つずつ指定しなければならない(今回は<a href="https://gist.github.com/matsubara0507/be20aa514016c991f19f2e604409cd96#file-fun-of-tangle-hs-L13">使ってるパッケージが多い</a>ので尚更大変)が，<code>script</code> なら指定した resolver から自動で解決してくれる．</p>
<h2 id="section-2"></h2>
<p>ただ問題がひとつ． 今回は <a href="https://hackage.haskell.org/package/aeson"><code>aeson</code></a> や <a href="https://hackage.haskell.org/package/cassava"><code>cassava</code></a> の型クラスのインスタンスを拡張可能レコードで使いたいので，Stackage に登録していない <a href="https://github.com/matsubara0507/extensible-instances"><code>matsubara0507/extensible-instances</code></a> にも依存したい． そこで，カスタムスナップショットだ． 日本語で詳しくは下記のサイトにまとまっていた．</p>
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html">カスタムスナップショットの紹介</a></li>
</ul>
<p>ここには書いてないが，カスタムスナップショットは <code>stack script</code> にも使える． 例えば今回は次のようなカスタムスナップショットを作った．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-10.6</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="fu">name:</span><span class="at"> matsubara0507</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">-</span> <span class="fu">git:</span><span class="at"> https://github.com/matsubara0507/extensible-instances.git</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="fu">commit:</span><span class="at"> 8dabe7a3dd9cf162e2d81e4ca16dbe73b98a3809</span></a></code></pre></div>
<p>これを <code>snapshot.yaml</code> とし，例題のコードを <code>fun-of-tangle.hs</code> とすると次のように実行できる</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="fu">cat</span> sampleLog.csv</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">2018-02-23T03</span>:10:00,<span class="st">&quot;{&quot;&quot;code&quot;&quot;:123,&quot;&quot;message&quot;&quot;:&quot;&quot;hello&quot;&quot;}&quot;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">$ <span class="ex">stack</span> script --resolver ./snapshot.yaml -- fun-of-tangle.hs sampleLog.csv</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="ex">Using</span> resolver: custom: ./snapshot.yaml specified on command line</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ex">path</span> @= <span class="st">&quot;sampleLog.csv&quot;</span> <span class="op">&lt;</span>: time @= <span class="st">&quot;2018-02-23T03:10:00&quot;</span> <span class="op">&lt;</span>: code @= 123 <span class="op">&lt;</span>: message @= <span class="st">&quot;hello&quot;</span> <span class="op">&lt;</span>: nil</a></code></pre></div>
<h3 id="ヘッダの生成">ヘッダの生成</h3>
<p>CSV の読み込みには <code>cassava</code> というパッケージを使っている． このパッケージには <code>FromRecord</code> と <code>FromNamedRecord</code> 型クラスがある． 前者は前から順に勝手に取っていくのに対し，後者はフィールド名と CSV の列名を対応させて取ってきてくれる．</p>
<p><code>cassava</code> 系の拡張可能レコードのインスタンスを書いてるときは <code>extensible</code> 力がまだ低く，フィールドからインデックスをとっていくる方法が分からなかった． そのため <code>FromRecord</code> 型クラスのインスタンスが <code>extensible-instances</code> にはない(何故かついこの前，<a href="https://github.com/fumieval/extensible/commit/074210e76ed5bd35f62d452f66c940a40d821534">本家へコミット</a>されたけど)．</p>
<p>なので，型から列名のヘッダーを生成してしまおう，というのが <code>header</code> 関数．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">header ::</span> <span class="dt">LB.ByteString</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">header <span class="fu">=</span> LB.intercalate <span class="st">&quot;,&quot;</span> <span class="fu">.</span> fmap fromString <span class="fu">$</span> henumerateFor</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">KeyValue</span> <span class="dt">KnownSymbol</span> <span class="dt">Show</span>))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">CsvFields</span>)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  ((<span class="fu">:</span>) <span class="fu">.</span> symbolVal <span class="fu">.</span> proxyAssocKey)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  []</a></code></pre></div>
<p><code>Proxy (KeyValue KnownSymbol Show)</code> ってのが悲しいですよね…(<code>Show</code> は全く無意味)． キー側だけ型クラスを指定する方法は無いような気がしたんだよなぁ．</p>
<h2 id="分割しましょう">分割しましょう</h2>
<p>では本題．</p>
<p>まずは型クラスを考えよう．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">class</span> <span class="dt">MakeLog</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  make ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">TangleT</span> <span class="dt">FieldI</span> <span class="dt">LogFields</span> <span class="dt">EIO</span> (<span class="dt">AssocValue</span> kv)</a></code></pre></div>
<p>試しに，<code>&quot;path&quot; &gt;: FilePath</code> のインスタンスを書いてみる．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">MakeLog</span> (<span class="st">&quot;path&quot;</span> <span class="fu">&gt;:</span> FilePath) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  make _ <span class="fu">=</span> lift <span class="fu">$</span> liftIO getArgs <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    (path <span class="fu">:</span> _) <span class="ot">-&gt;</span> pure path</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    _          <span class="ot">-&gt;</span> throwError <span class="st">&quot;please path.&quot;</span></a></code></pre></div>
<p>他のはできるだろうか？ 元のメイン関数を見ればわかると思うが，たぶん無理だと思う． 他のフィールドは <code>log'</code> 変数に保存した中間状態を共有するからだ．</p>
<h3 id="中間状態をどうするか">中間状態をどうするか</h3>
<p>他にもっといい手はあるかもしれないが，今回は <strong>レコードを中間状態も加えて拡張する</strong> ことにする．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">type</span> <span class="dt">MidFields</span> <span class="fu">=</span> <span class="ch">&#39;[&quot;log&quot; &gt;: LogCsv &#39;</span><span class="fu">:</span> <span class="st">&quot;info&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Info</span>] <span class="fu">++</span> <span class="dt">LogFields</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">class</span> <span class="dt">MakeLog</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">  make ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">TangleT</span> <span class="dt">FieldI</span> <span class="dt">MidFields</span> <span class="dt">EIO</span> (<span class="dt">AssocValue</span> kv)</a></code></pre></div>
<p><a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Product.html#t:-43--43-"><code>(++)</code></a> は型レベルリストの連結演算子だ． <code>'[&quot;log&quot; &gt;: LogCsv ': &quot;info&quot; &gt;: Info]</code> が追加する中間状態にあたる． これを最後にどうやって外すかと言うと，実は簡単で <a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-Inclusion.html#v:shrink"><code>shrink</code></a> 関数で縮小してやればよい．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">makeLog ::</span> <span class="dt">EIO</span> <span class="dt">Log</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">makeLog <span class="fu">=</span> shrink <span class="fu">&lt;$&gt;</span> runTangles tangles (wrench emptyRecord)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">tangles ::</span> <span class="dt">Comp</span> (<span class="dt">TangleT</span> <span class="dt">FieldI</span> <span class="dt">MidFields</span> <span class="dt">EIO</span>) <span class="dt">FieldI</span> <span class="fu">:*</span> <span class="dt">MidFields</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">tangles <span class="fu">=</span> htabulateFor (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MakeLog</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  \m <span class="ot">-&gt;</span> <span class="dt">Comp</span> <span class="fu">$</span> <span class="dt">Field</span> <span class="fu">.</span> pure <span class="fu">&lt;$&gt;</span> make m</a></code></pre></div>
<p>中間状態のインスタンス定義してしまう．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">MakeLog</span> (<span class="st">&quot;log&quot;</span> <span class="fu">&gt;:</span> <span class="dt">LogCsv</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  make _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    file <span class="ot">&lt;-</span> lift <span class="fu">.</span> liftIO <span class="fu">.</span> LB.readFile <span class="fu">=&lt;&lt;</span> lasso <span class="fu">#</span>path</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    (_, log&#39;) <span class="ot">&lt;-</span> lift <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      either throwError pure (decodeByName <span class="fu">$</span> mconcat [header, <span class="st">&quot;\n&quot;</span>, file])</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    pure <span class="fu">$</span> V.head log&#39;</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">MakeLog</span> (<span class="st">&quot;info&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Info</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  make _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    log&#39; <span class="ot">&lt;-</span> lasso <span class="fu">#</span>log</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    lift <span class="fu">$</span> either throwError pure (eitherDecode <span class="fu">$</span> log&#39; <span class="fu">^.</span> <span class="fu">#</span>info)</a></code></pre></div>
<p>うん…まぁ…読みやすさのためにね，多少は <code>do</code> を残しましたよ(タイトル詐欺)．</p>
<h3 id="残りは簡単">残りは簡単</h3>
<p>あとは，フィールドを取り出すだけなので簡単．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">MakeLog</span> (<span class="st">&quot;time&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Time</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  make _ <span class="fu">=</span> view <span class="fu">#</span>time <span class="fu">&lt;$&gt;</span> lasso <span class="fu">#</span>log</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">MakeLog</span> (<span class="st">&quot;code&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  make _ <span class="fu">=</span> view <span class="fu">#</span>code <span class="fu">&lt;$&gt;</span> lasso <span class="fu">#</span>info</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">MakeLog</span> (<span class="st">&quot;message&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  make _ <span class="fu">=</span> view <span class="fu">#</span>message <span class="fu">&lt;$&gt;</span> lasso <span class="fu">#</span>info</a></code></pre></div>
<p>メイン関数はこんな感じ．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">main <span class="fu">=</span> either error print <span class="fu">=&lt;&lt;</span> runEIO makeLog</a></code></pre></div>
<p>わぁすっきり(メイン関数は)．</p>
<h2 id="おしまい">おしまい</h2>
<p>これぐらいの規模だとメリットが皆無なんですが，もっと CSV の列数が多くなったらどうでしょう？ うーーーん，あんまり変わらないかも(笑) まぁ，少なくとも面白い(不思議な)プログラミングが出来るのは確かです．</p>
<p>僕は試しにこの方法で，<a href="https://github.com/matsubara0507/source-gh-pages/blob/tangle/app/Rules.hs">このサイトの Hakyll コード</a>を切り刻んでみました．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>このサイトに機能を追加 2018</title>
    <link href="https://matsubara0507.github.io/posts/2018-02-21-add-feats-mysite-2018.html" />
    <id>https://matsubara0507.github.io/posts/2018-02-21-add-feats-mysite-2018.html</id>
    <published>2018-02-21T00:00:00Z</published>
    <updated>2018-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">このサイトに機能を追加 2018</h1>
    <p class="post-meta">
      <time datetime="2018-02-21" itemprop="datePublished">
        Feb 21, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/site.html">site</a> <a href="/tags/Haskell.html">Haskell</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>このサイトは Haskell の静的サイトジェネレーター <a href="https://jaspervdj.be/hakyll/">Hakyll</a> を使っています．</p>
<ul>
<li><a href="/posts/2016-07-07-started-github-pages.html">GitHub Pages はじめました - ひげメモ</a></li>
</ul>
<p>定期的に自分のサイトをいじってるんだけど，久々に本腰入れて改良した． このサイトを作り始めたころと違い「Haskell力」が段違いなのでサクサクできたぜ．</p>
<h2 id="section"></h2>
<p>追加したのは以下の7つ．</p>
<ul>
<li>リンクチェッカー</li>
<li>LTS 10 に対応</li>
<li>可変なキーバリューストアを aeson で</li>
<li><code>post/</code> 以下のマークダウン置き場を変更</li>
<li>フィードの生成</li>
<li>ページネーションの追加</li>
<li>タグの追加</li>
</ul>
<p>最初のリンクチェッカーは <code>stack test</code> で行うのだが，追加したのは実は結構前． 記事にしてなかったので書き足しておく．</p>
<h2 id="リンクチェッカー">リンクチェッカー</h2>
<p>記事内にあるリンクを実際に ping して，リンクが有効かを検査するテストを作った． もちろん Haskell で書いて <code>stack test</code> で実行できるようにした． コードはこんな感じ</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Prelude</span>                   <span class="kw">hiding</span> (<span class="dt">FilePath</span>, null)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.List</span>                 (nub, sort)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Maybe</span>                (fromMaybe)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Data.Text</span>                 (<span class="dt">Text</span>, isPrefixOf, null, unpack)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Data.Traversable</span>          (traverse)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span>           <span class="dt">Network.HTTP.Client</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span>           <span class="dt">Network.HTTP.Client.TLS</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span>           <span class="dt">Network.HTTP.Types.Status</span> (<span class="dt">Status</span>, ok200)</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Shelly</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span>           <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span>           <span class="dt">Text.HTML.Scalpel.Core</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  urls <span class="ot">&lt;-</span> fmap mconcat <span class="fu">.</span> shelly <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    run_ <span class="st">&quot;stack&quot;</span> [<span class="st">&quot;exec&quot;</span>, <span class="st">&quot;--&quot;</span>, <span class="st">&quot;site&quot;</span>, <span class="st">&quot;build&quot;</span>]</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    files <span class="ot">&lt;-</span> ls <span class="st">&quot;_site/posts&quot;</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    traverse (fmap scrapeLinks <span class="fu">.</span> readfile) files</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  hspec <span class="fu">.</span> mapM_ spec <span class="fu">.</span> nub <span class="fu">.</span> sort <span class="fu">$</span> filter check urls</a>
<a class="sourceLine" id="cb1-23" data-line-number="23"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  check url <span class="fu">=</span> not <span class="fu">.</span> or <span class="fu">.</span> (<span class="fu">:</span>) (null url) <span class="fu">$</span> fmap</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">    (<span class="ot">`isPrefixOf`</span> url)</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">    [<span class="st">&quot;https://matsubara0507.github.io&quot;</span>, <span class="st">&quot;../&quot;</span>, <span class="st">&quot;#&quot;</span>]</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">  spec url <span class="fu">=</span> it (unpack url) <span class="fu">$</span> linkStatus url <span class="ot">`shouldReturn`</span> ok200</a>
<a class="sourceLine" id="cb1-28" data-line-number="28"></a>
<a class="sourceLine" id="cb1-29" data-line-number="29"><span class="ot">scrapeLinks ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb1-30" data-line-number="30">scrapeLinks txt <span class="fu">=</span> fromMaybe [] <span class="fu">$</span> scrapeStringLike txt scraper</a>
<a class="sourceLine" id="cb1-31" data-line-number="31">  <span class="kw">where</span> scraper <span class="fu">=</span> attrs <span class="st">&quot;href&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb1-32" data-line-number="32"></a>
<a class="sourceLine" id="cb1-33" data-line-number="33"><span class="ot">linkStatus ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Status</span></a>
<a class="sourceLine" id="cb1-34" data-line-number="34">linkStatus url <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-35" data-line-number="35">  manager <span class="ot">&lt;-</span> newManager tlsManagerSettings</a>
<a class="sourceLine" id="cb1-36" data-line-number="36">  request <span class="ot">&lt;-</span> parseRequest <span class="fu">$</span> unpack url</a>
<a class="sourceLine" id="cb1-37" data-line-number="37">  responseStatus</a>
<a class="sourceLine" id="cb1-38" data-line-number="38">    <span class="fu">&lt;$&gt;</span> httpNoBody (request { requestHeaders <span class="fu">=</span> [(<span class="st">&quot;User-Agent&quot;</span>, <span class="st">&quot;&quot;</span>)] }) manager</a></code></pre></div>
<p>HTTPクライアントには <a href="https://hackage.haskell.org/package/http-client"><code>http-client</code></a> を，スクレイピングには <a href="https://hackage.haskell.org/package/scalpel"><code>scalpel</code></a> を使っている． <a href="https://hackage.haskell.org/package/shelly"><code>shelly</code></a> の <code>ls</code> 関数を使って記事の一覧を取得してきている(これが Windows でも動くからうれしい)． 表示をそれっぽくするために <a href="https://hackage.haskell.org/package/hspec"><code>hspec</code></a> を使っている． <code>check</code> 補助関数で自分のページや空文字を排除している．</p>
<h2 id="section-1"></h2>
<p>これでリンク切れや単純にタイポなんかを検出できるようになったんだが，直すのがめんどくさくて結局放置していること(オイ)．</p>
<h2 id="lts-10-に対応">LTS 10 に対応</h2>
<p>リンクチェッカを回すために TravisCI を使い始めたが，なぜか GHC8 系の LTS だと OUT OF MEMORY してしまう…</p>
<pre><code>--  While building custom Setup.hs for package Cabal-2.0.1.1 using:
      /home/travis/.stack/setup-exe-cache/x86_64-linux/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-linux/Cabal-2.0.1.0 build --ghc-options &quot; -ddump-hi -ddump-to-file -fdiagnostics-color=always&quot;
    Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)
    Logs have been written to: /home/travis/build/matsubara0507/source-gh-pages/.stack-work/logs/Cabal-2.0.1.1.log
    Configuring Cabal-2.0.1.1...
    Preprocessing library for Cabal-2.0.1.1..
    Building library for Cabal-2.0.1.1..</code></pre>
<p>かなーーり古い LTS だとうまくいくので，仕方なくそれを使っていたのだが直すことにした． というか知り合いが直し方を記事にしてくれてたのでやってみた．</p>
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2017-12-31-travis-out-of-memory.html">travis-ci の初回ビルドで OUT OF MEMORY が出た時の対処法</a></li>
</ul>
<p>戦犯は <code>Cabal</code> パッケージなので，こいつだけ先に <code>-j 1</code> オプション(メモリを節約するが速度が遅い)でビルドしてしまうという戦略． この記事のサイトの <a href="https://github.com/e-bigmoon/haskell-blog/blob/a229f118f121e0ad843faae1412e938e3e4f3a6b/.travis.yml"><code>.travis.yml</code></a> を <del>コピペ</del> 参考にして次のようにした</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">install:</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="kw">-</span> mkdir -p ~/.local/bin</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">-</span> <span class="fu">export PATH=$HOME/.local/bin:</span><span class="at">$PATH</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">-</span> <span class="fu">travis_retry curl -L https:</span><span class="at">//www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin &#39;*/stack&#39;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> install cabal</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      <span class="fu">script:</span><span class="at"> stack --no-terminal build -j 1 Cabal</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> install pandoc</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">      <span class="fu">script:</span><span class="at"> travis_wait 30 stack --no-terminal build pandoc</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> install deprndences</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">      <span class="fu">script:</span><span class="at"> stack --no-terminal test --only-dependencies</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> stack test</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">      <span class="fu">script:</span><span class="at"> stack --no-terminal test --no-run-benchmarks --no-haddock-deps</span></a></code></pre></div>
<h3 id="hakyll-4.10-が落ちる">hakyll-4.10 が落ちる</h3>
<p>OUT OF MEMORY は突破したが…</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">    <span class="fu">/</span>tmp<span class="fu">/</span>stack3402<span class="fu">/</span>hakyll<span class="fu">-</span><span class="fl">4.10</span><span class="fu">.</span><span class="fl">0.0</span><span class="fu">/</span>rts<span class="fu">/</span>posix<span class="fu">/</span>OSThreads.c<span class="fu">:</span><span class="dv">137</span><span class="fu">:</span><span class="dv">0</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">         error<span class="fu">:</span> undefined reference to <span class="ch">&#39;pthread_create&#39;</span></a></code></pre></div>
<p>なぜだ… 最新の <a href="https://github.com/jaspervdj/hakyll/commit/480da307d22aff8ab3817d1586710c5f4ff6d779"><code>hakyll-4.11</code> では直ってるみたい</a>なので，<code>stack.yaml</code> に追加したら上手くいった．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">-</span> hakyll-4.11.0.0</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">-</span> pandoc-citeproc-0.13.0.1</a></code></pre></div>
<h3 id="シンタックスハイライトが">シンタックスハイライトが…</h3>
<p>おかしくなった． 理由は簡単で，Hakyll というか Pandoc がシンタックスハイライトにもともと使っていた <a href="https://hackage.haskell.org/package/highlighting-kate"><code>highlighting-kate</code></a> をやめて <a href="https://hackage.haskell.org/package/skylighting"><code>skylighting</code></a> に対応したからみたいだ．</p>
<ul>
<li><a href="http://fixpt.de/blog/2017-12-03-hakyll-highlighting-themes.html">fixpt - Hakyll Code Highlighting Themes</a></li>
</ul>
<p>なので，パッケージを変えたら元に戻った．</p>
<h2 id="可変なキーバリューストアを-aeson-で">可変なキーバリューストアを aeson で</h2>
<p>テンプレートの方だけで出てくる変数(e.g. <code>$github$</code> とか)は <code>site.hs</code> の実装に依存したくなくて，Hakyll をビルドせずとも <code>config.yaml</code> に好きに追加できるようにしたかった． <a href="https://hackage.haskell.org/package/yaml">yaml</a> パッケージ(というか <a href="https://hackage.haskell.org/package/aeson"><code>aeson</code></a>)ではそういうのを出来ないと <strong>思い込んでいたが <code>Map k v</code> 型を使えばできる</strong> と最近分かった(インスタンスのリストを眺めてたら気づいた)． なので，今まで使ってた <a href="https://hackage.haskell.org/package/yaml-light"><code>yaml-light</code></a> パッケージを捨てて <code>yaml</code> パッケージで次のように実装した．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.Yaml</span>   (decodeFileEither)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Data.Map</span>    (<span class="dt">Map</span>, foldMapWithKey)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Hakyll</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  configYaml <span class="ot">&lt;-</span> either (error <span class="fu">.</span> show) id <span class="fu">&lt;$&gt;</span> decodeFileEither <span class="st">&quot;config.yaml&quot;</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    siteCtx <span class="fu">=</span> mkSiteCtx configYaml</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  hakyllWith config <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13"><span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="ot">mkSiteCtx ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">mkSiteCtx <span class="fu">=</span> foldMapWithKey constField</a></code></pre></div>
<p>こういう <code>config.yaml</code> を書いておくと，全てテンプレートの中で参照できる．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">site_title:</span><span class="at"> ひげメモ</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">description:</span><span class="at"> </span><span class="st">&quot;自分用のメモ書きだったり，イロイロといじって遊ぶようだったり&quot;</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="fu">baseurl:</span><span class="at"> </span><span class="st">&quot;https://matsubara0507.github.io&quot;</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="fu">github:</span><span class="at">  matsubara0507</span></a></code></pre></div>
<h2 id="post-以下のマークダウン置き場を変更"><code>post/</code> 以下のマークダウン置き場を変更</h2>
<p>記事のマークダウンは全て <code>posts/</code> 以下に置いていたのだが，各年ごとにディレクトリを切りたいなぁと思った． 例えば <code>posts/2018/02-21-add-feats-mysite-2018.md</code> といった具合に． しかし，出力は今まで通り <code>posts/2018-02-21-add-feats-mysite-2018.html</code> としたい(リンクが変わっちゃうからね)． まんま<a href="http://daimatz.net/text/2014/0126-hakyll.html">同じことをしてくれている記事</a>があったので，参考にして次のように書き換えた．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="fu">...</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  match <span class="st">&quot;posts/*/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    route <span class="fu">$</span> composeRoutes (gsubRoute <span class="st">&quot;/[0-9]{4}/&quot;</span> <span class="fu">$</span> (<span class="fu">++</span> <span class="st">&quot;-&quot;</span>) <span class="fu">.</span> init)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                          (setExtension <span class="st">&quot;html&quot;</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    compile</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      <span class="fu">$</span>   pandocCompiler</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span> postCtx</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> (postCtx <span class="fu">&lt;&gt;</span> siteCtx)</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">      <span class="fu">&gt;&gt;=</span> relativizeUrls</a></code></pre></div>
<p><code>gsubRoute</code> 関数を使うことで，ファイル名を特有のパターン記法(？)でマッチさせ置換できる． <code>gsubRoute &quot;/[0-9]{4}/&quot; $ (++ &quot;-&quot;) . init</code> の場合，<code>/2018/</code> をマッチさせ <code>init</code> して <code>/2018</code> となり，末尾に <code>&quot;-&quot;</code> を追加している．</p>
<h2 id="section-2"></h2>
<p>さて実はもう一つ問題があって，Hakyll は日時を表すテンプレート変数(<code>$date$</code> とか)を次のように取得する．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">postCtx ::</span> <span class="dt">Context</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">postCtx <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  [ dateField <span class="st">&quot;time&quot;</span> <span class="st">&quot;%Y-%m-%d&quot;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  , dateField <span class="st">&quot;date&quot;</span> <span class="st">&quot;%b %-d, %Y&quot;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  , defaultContext</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  ]</a></code></pre></div>
<p><code>dateField</code> 関数が記事のファイル名(<code>yyyy-mm-dd-*.md</code> の部分)かマークダウンのメタ変数から取得している． つまり，<code>posts/2018/02-21-add-feats-mysite-2018.md</code> というファイル名じゃ日時の変数を取得できない． しょうがないので Hakyll のソースコードを読んで無理やり書き換えた．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.Time</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">System.FilePath</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">dateField&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> a</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">dateField&#39; key format <span class="fu">=</span> field key <span class="fu">$</span> \item <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  time <span class="ot">&lt;-</span> getItemUTC&#39; defaultTimeLocale <span class="fu">$</span> itemIdentifier item</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  return <span class="fu">$</span> formatTime defaultTimeLocale format time</a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">getItemUTC&#39; ::</span> <span class="dt">MonadMetadata</span> m <span class="ot">=&gt;</span> <span class="dt">TimeLocale</span> <span class="ot">-&gt;</span> <span class="dt">Identifier</span> <span class="ot">-&gt;</span> m <span class="dt">UTCTime</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">getItemUTC&#39; locale ident <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  pure <span class="fu">$</span> parseTimeOrError <span class="dt">True</span> locale <span class="st">&quot;%Y%m-%d&quot;</span> (yyyy <span class="fu">++</span> mmdd)</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    path <span class="fu">=</span> toFilePath ident</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">    yyyy <span class="fu">=</span> takeFileName <span class="fu">$</span> takeDirectory path</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    mmdd <span class="fu">=</span> take <span class="dv">5</span> <span class="fu">$</span> takeBaseName path</a></code></pre></div>
<p>さっきの <code>dateField</code> の部分を <code>dateField'</code> にすれば記事のビルドが出来る！</p>
<h3 id="vs-recentfirst-関数">vs <code>recentFirst</code> 関数</h3>
<p>記事を日時順に並び変えてくれる <code>recentFirst</code> 関数もファイル名に依存してる． しょうがないので力技で書き換える．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.List</span>       (sortBy)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Data.Ord</span>        (comparing)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">recentFirst&#39; ::</span> <span class="dt">MonadMetadata</span> m <span class="ot">=&gt;</span> [<span class="dt">Item</span> a] <span class="ot">-&gt;</span> m [<span class="dt">Item</span> a]</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">recentFirst&#39; <span class="fu">=</span> fmap reverse <span class="fu">.</span> chronological&#39;</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="ot">chronological&#39; ::</span> <span class="dt">MonadMetadata</span> m <span class="ot">=&gt;</span> [<span class="dt">Item</span> a] <span class="ot">-&gt;</span> m [<span class="dt">Item</span> a]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">chronological&#39; <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  sortByM <span class="fu">$</span> getItemUTC&#39; defaultTimeLocale <span class="fu">.</span> itemIdentifier</a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="ot">sortByM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Ord</span> k) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m k) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">sortByM f <span class="fu">=</span> fmap (map fst <span class="fu">.</span> sortBy (comparing snd)) <span class="fu">.</span> mapM (fmap <span class="fu">&lt;$&gt;</span> (,) <span class="fu">&lt;*&gt;</span> f)</a></code></pre></div>
<p><code>sortByM</code> 関数は <code>sortBy</code> の <code>Monad</code> 版． <code>[a]</code> を <code>[(a, m k)]</code> とし <code>[m (a, k)]</code> にして <code>m [(a, k)]</code> にしてから <code>k</code> でソートし最後に <code>a</code> だけ取り出している． ちなみに，<code>fmap &lt;$&gt; (,) &lt;*&gt; f</code> の部分は分かりますか？ <code>\x -&gt; (,) x &lt;$&gt; f x</code> をしてるだけですよ．</p>
<h2 id="フィードページネーションタグ">フィード・ページネーション・タグ</h2>
<p>実はフィード生成・ページネーション・タグは，もとから Hakyll で提供されている機能だ． どれもこの記事に日本語で書いてある．</p>
<ul>
<li><a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part2.html">Hakyllでブログを作る(実践編2) - Wake up! Good night*</a></li>
<li><a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part3.html">Hakyllでブログを作る(実践編3) - Wake up! Good night*</a></li>
</ul>
<p>だが躓きポイントはいくつかあった(だいたい日時のやつだけど…)．</p>
<h3 id="フィードを生成">フィードを生成</h3>
<p>記事の通りに作っても <code>$published$</code> 変数が無いと怒られる． <code>renderAtom</code> 関数の中で <code>dateField</code> 関数を使っているからだ． さすがに書き換えるのはめんどいので，自分で取ってくることにした．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">postCtx ::</span> <span class="dt">Context</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">postCtx <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  [ dateField <span class="st">&quot;time&quot;</span> <span class="st">&quot;%Y-%m-%d&quot;</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  , dateField <span class="st">&quot;date&quot;</span> <span class="st">&quot;%b %-d, %Y&quot;</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  , dateField&#39; <span class="st">&quot;published&quot;</span> <span class="st">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">  , dateField&#39; <span class="st">&quot;updated&quot;</span> <span class="st">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  , defaultContext</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  ]</a></code></pre></div>
<p>あと，<a href="https://hackage.haskell.org/package/hakyll-4.11.0.0/docs/Hakyll-Web-Feed.html#t:FeedConfiguration">フィードに渡す変数</a>は <code>config.yaml</code> に書くことにした．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">site_title:</span><span class="at"> ひげメモ</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="fu">author:</span><span class="at"> MATSUBARA Nobutada</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="fu">email:</span><span class="at"> </span><span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="fu">description:</span><span class="at"> </span><span class="st">&quot;自分用のメモ書きだったり，イロイロといじって遊ぶようだったり&quot;</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="fu">baseurl:</span><span class="at"> </span><span class="st">&quot;https://matsubara0507.github.io&quot;</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="fu">val:</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  <span class="fu">github:</span><span class="at"> matsubara0507</span></a></code></pre></div>
<p>これを <code>Config</code> 型という拡張可能レコードにマッピングし，そのあとに <code>FeedConfiguration</code> 型に変換する．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Control.Lens</span> ((^.))</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="ch">&#39;[ &quot;site_title&quot; &gt;: String</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">   , <span class="st">&quot;author&quot;</span> <span class="fu">&gt;:</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">   , <span class="st">&quot;email&quot;</span> <span class="fu">&gt;:</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">   , <span class="st">&quot;description&quot;</span> <span class="fu">&gt;:</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">   , <span class="st">&quot;baseurl&quot;</span> <span class="fu">&gt;:</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">   , <span class="st">&quot;val&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">   ]</a>
<a class="sourceLine" id="cb14-12" data-line-number="12"></a>
<a class="sourceLine" id="cb14-13" data-line-number="13"><span class="ot">mkFeedConfig ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">FeedConfiguration</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">mkFeedConfig conf <span class="fu">=</span> <span class="dt">FeedConfiguration</span></a>
<a class="sourceLine" id="cb14-15" data-line-number="15">  { feedTitle       <span class="fu">=</span> conf <span class="fu">^.</span> <span class="fu">#</span>site_title</a>
<a class="sourceLine" id="cb14-16" data-line-number="16">  , feedDescription <span class="fu">=</span> conf <span class="fu">^.</span> <span class="fu">#</span>description</a>
<a class="sourceLine" id="cb14-17" data-line-number="17">  , feedAuthorName  <span class="fu">=</span> conf <span class="fu">^.</span> <span class="fu">#</span>author</a>
<a class="sourceLine" id="cb14-18" data-line-number="18">  , feedAuthorEmail <span class="fu">=</span> conf <span class="fu">^.</span> <span class="fu">#</span>email</a>
<a class="sourceLine" id="cb14-19" data-line-number="19">  , feedRoot        <span class="fu">=</span> conf <span class="fu">^.</span> <span class="fu">#</span>baseurl</a>
<a class="sourceLine" id="cb14-20" data-line-number="20">  }</a></code></pre></div>
<p>もちろん，<code>siteCtx</code> も書き換える必要がある．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">mkSiteCtx ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">mkSiteCtx <span class="fu">=</span> hfoldMapFor</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">KeyValue</span> <span class="dt">KnownSymbol</span> <span class="dt">ToContext</span>))</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  (toContext <span class="fu">&lt;$&gt;</span> symbolVal <span class="fu">.</span> proxyAssocKey <span class="fu">&lt;*&gt;</span> getField)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="kw">class</span> <span class="dt">ToContext</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">  toContext ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">ToContext</span> <span class="dt">String</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">  toContext _ <span class="st">&quot;&quot;</span> <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  toContext k v  <span class="fu">=</span> constField k v</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"></a>
<a class="sourceLine" id="cb15-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">ToContext</span> a <span class="ot">=&gt;</span> <span class="dt">ToContext</span> (<span class="dt">Map</span> <span class="dt">String</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">  toContext _ <span class="fu">=</span> foldMapWithKey toContext</a>
<a class="sourceLine" id="cb15-15" data-line-number="15"></a>
<a class="sourceLine" id="cb15-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">ToContext</span> a <span class="ot">=&gt;</span> <span class="dt">ToContext</span> (<span class="dt">Identity</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-17" data-line-number="17">  toContext k <span class="fu">=</span> toContext k <span class="fu">.</span> runIdentity</a></code></pre></div>
<p>拡張可能レコード最高です．</p>
<h3 id="ページネーションを追加">ページネーションを追加</h3>
<p><a href="https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">参考記事</a>の中で使われている <code>sortRecentFirst</code> も日時を取得しているので書き換える．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">sortRecentFirst&#39; ::</span> <span class="dt">MonadMetadata</span> m <span class="ot">=&gt;</span> [<span class="dt">Identifier</span>] <span class="ot">-&gt;</span> m [<span class="dt">Identifier</span>]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">sortRecentFirst&#39; <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  fmap (fmap itemIdentifier) <span class="fu">.</span> recentFirst&#39; <span class="fu">.</span> fmap (flip <span class="dt">Item</span> ())</a></code></pre></div>
<h3 id="タグを追加">タグを追加</h3>
<p>躓きと言うかデザインの問題なのだが，タグのテンプレート変数を生成する <a href="https://hackage.haskell.org/package/hakyll-4.11.0.0/docs/Hakyll-Web-Tags.html#v:tagsField"><code>tagsField</code></a> 関数が，タグをカンマ区切りの文字列にしちゃうのがあった． 個人的には空白区切りにして欲しいので書き換えた．</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.List</span>                   (intersperse)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Text.Blaze.Html</span>             (toHtml, toValue, (!))</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Blaze.Html5</span>            <span class="kw">as</span> <span class="dt">H</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Blaze.Html5.Attributes</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="ot">tagsFieldWithSep ::</span> <span class="dt">H.Html</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Tags</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> a</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">tagsFieldWithSep sep <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">  tagsFieldWith getTags simpleRenderLink (mconcat <span class="fu">.</span> intersperse sep)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9"></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"><span class="ot">simpleRenderLink ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">H.Html</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">simpleRenderLink tag <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-12" data-line-number="12">  fmap (\path <span class="ot">-&gt;</span> H.a <span class="fu">!</span> A.href (toValue <span class="fu">$</span> toUrl path) <span class="fu">$</span> toHtml tag)</a></code></pre></div>
<p><code>tagsFieldWithSep &quot; &quot;</code> とすれば空白区切りになる．</p>
<h2 id="おしまい">おしまい</h2>
<p>ずーーとやろうやろうと思ってたことをいっきに片したぜ．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>自己紹介ページを生成する whoami CLI を作った (Haskell)</title>
    <link href="https://matsubara0507.github.io/posts/2018-02-19-create-whoami-cli.html" />
    <id>https://matsubara0507.github.io/posts/2018-02-19-create-whoami-cli.html</id>
    <published>2018-02-19T00:00:00Z</published>
    <updated>2018-02-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">自己紹介ページを生成する whoami CLI を作った (Haskell)</h1>
    <p class="post-meta">
      <time datetime="2018-02-19" itemprop="datePublished">
        Feb 19, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a> <a href="/tags/application.html">application</a> <a href="/tags/extensible-package.html">extensible-package</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://github.com/matsubara0507/whoami">whoami</a> という CLI を作りました． こんな感じの Yaml ファイルから</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">name:</span><span class="at"> MATSUBARA Nobutada</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="fu">account:</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">github:</span><span class="at"> matsubara0507</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="fu">qiita:</span><span class="at"> matsubara0507</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="fu">site:</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">-</span> <span class="fu">name:</span><span class="at"> ひげメモ</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="fu">url:</span><span class="at"> http://matsubara0507.github.io</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="fu">description:</span><span class="at"> メモ書きブログ</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="fu">post:</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="fu">latest:</span><span class="at"> 10</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="fu">posts:</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="kw">-</span> <span class="fu">url:</span><span class="at"> http://haskell.jp/blog/posts/2017/advent-calendar-2017.html</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">      <span class="fu">date:</span><span class="at"> 2017-12-31</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="kw">-</span> <span class="fu">url:</span><span class="at"> http://iggg.github.io/2017/06/01/make-tweet-slack-bot</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="fu">library:</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  <span class="kw">-</span> <span class="fu">name:</span><span class="at"> chatwork</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    <span class="fu">url:</span><span class="at"> http://hackage.haskell.org/package/chatwork</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    <span class="fu">description:</span><span class="at"> The ChatWork API in Haskell</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    <span class="fu">language:</span><span class="at"> haskell</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  <span class="kw">-</span> <span class="fu">name:</span><span class="at"> thank_you_stars</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    <span class="fu">url:</span><span class="at"> http://hex.pm/packages/thank_you_stars</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">    <span class="fu">language:</span><span class="at"> elixir</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="fu">qiita:</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  <span class="fu">posts:</span><span class="at"> true</span></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="fu">app:</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">  <span class="kw">-</span> <span class="fu">name:</span><span class="at"> AnaQRam</span></a>
<a class="sourceLine" id="cb1-27" data-line-number="27">    <span class="fu">url:</span><span class="at"> http://github.com/matsubara0507/AnaQRam</span></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">    <span class="fu">description:</span><span class="at"> QRコードを利用したアナグラム(並び替えパズル)</span></a></code></pre></div>
<p>こんな感じの Markdown を生成する．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu"># MATSUBARA Nobutada</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">- <span class="ot">[GitHub](https://github.com/matsubara0507)</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="fl">- </span><span class="ot">[Qiita](https://qiita.com/matsubara0507)</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="fu">## My Sites</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">- <span class="ot">[ひげメモ](http://matsubara0507.github.io)</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="fl">    - メモ書きブログ</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="fu">## My Posts</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">- <span class="ot">[Haskell Advent Calendar 2017 まとめ - Haskell-jp](http://haskell.jp/blog/posts/2017/advent-calendar-2017.html)</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="fl">    - posted on 2017-12-31</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="fl">- </span><span class="ot">[LINE の Echo Bot を Google Cloud Functions に作る](https://qiita.com/matsubara0507/items/04ab3c2197aa5f68e499)</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="fl">    - posted on 2017-11-21</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="fl">- </span><span class="ot">[GitHub にチャット機能のようなものが追加された (team discussions)](https://qiita.com/matsubara0507/items/47d2e2545553e415f969)</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="fl">    - posted on 2017-11-21</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="fl">- </span><span class="ot">[GitHub Project に自動でカードのカラム遷移をする機能が追加された](https://qiita.com/matsubara0507/items/f384991b4854aa28745a)</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17"><span class="fl">    - posted on 2017-10-31</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"><span class="fl">- </span><span class="ot">[Slack から特定のアカウントでツイートする Bot を作った｜群馬大学電子計算機研究会 IGGG](http://iggg.github.io/2017/06/01/make-tweet-slack-bot)</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"><span class="fl">    - posted on 2017-06-01</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20"></a>
<a class="sourceLine" id="cb2-21" data-line-number="21"><span class="fu">## Applications</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">- <span class="ot">[AnaQRam](http://github.com/matsubara0507/AnaQRam)</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23"><span class="fl">    - QRコードを利用したアナグラム(並び替えパズル)</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24"></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"><span class="fu">## Libraries</span></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">- <span class="ot">[chatwork](http://hackage.haskell.org/package/chatwork)</span></a>
<a class="sourceLine" id="cb2-27" data-line-number="27"><span class="fl">    - The ChatWork API in Haskell</span></a>
<a class="sourceLine" id="cb2-28" data-line-number="28"><span class="fl">- </span><span class="ot">[thank_you_stars](http://hex.pm/packages/thank_you_stars)</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29"><span class="fl">    - A tool for starring GitHub repositories.</span></a></code></pre></div>
<p>Yaml ファイルでは足りない情報をスクレイピングや各種 Web サービスの API で拾ってくる． なんか自分のアクティビティを紹介するページを SNS にリンクしてる人が多いと思うんだけど，そのページをできるだけ楽して生成したいなぁというのがモチベーション．</p>
<h2 id="section"></h2>
<p>ホントはバイト先で作ってる Haskell 製の社内用 CLI ツールを公開したくて，内容を公開できるようにしたツールです． こんな感じのデータ処理をするツールを，バイト先では Haskell で作ってた．</p>
<h2 id="extensible">extensible</h2>
<p>このツールの(まぁまぁ)面白いところは，<a href="https://hackage.haskell.org/package/extensible">extensible</a> というパッケージの機能をふんだんに使っている． 拡張可能レコード，バリアント，作用を使い，ついでに <a href="https://hackage.haskell.org/package/extensible/docs/Data-Extensible-GetOpt.html">GetOpt</a> も使ってみた． 軽く補足しておく(<strong>但し，作者ではないので間違っている部分はあるかも</strong>)．</p>
<h3 id="拡張可能レコード">拡張可能レコード</h3>
<p>Haskell のレコード構文</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Hoge</span> <span class="fu">=</span> {<span class="ot"> hoge1 ::</span> <span class="dt">Int</span>,<span class="ot"> hoge2 ::</span> <span class="dt">Text</span> }</a></code></pre></div>
<p>を，型レベル辞書を用いて次のように書ける．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Hoge</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="ch">&#39;[ &quot;hoge1&quot; &gt;: Int, &quot;hoge2&quot; &gt;: Text ]</span></a></code></pre></div>
<p><code>OverloadedLabels</code> 言語拡張と組み合わせて，名前衝突の無いフィールド名を扱えたり，<code>lens</code> を用いた OOP のような参照(e.g. <code>hoge ^. #hoge1</code>)が出来る． また，<a href="/posts/2017-11-28-fun-of-extensible-1.html">レコードの拡縮もできる</a>．</p>
<h3 id="拡張可能バリアント">拡張可能バリアント</h3>
<p>次のような直和型</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Hoge</span> <span class="fu">=</span> <span class="dt">Hoge1</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Hoge2</span> <span class="dt">Text</span></a></code></pre></div>
<p>を，型レベル辞書を用いて，バリアント型のように書ける．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Hoge</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="ch">&#39;[ &quot;hoge1&quot; &gt;: Int, &quot;hoge2&quot; &gt;: Text ]</span></a></code></pre></div>
<p>(正直あんまり利点が分かってないけど)拡縮はもちろん，<a href="/posts/2018-01-31-fun-of-extensible-2.html">バリアントの操作関数をファイル分割して実装</a>もできる．</p>
<h3 id="拡張可能作用">拡張可能作用</h3>
<p>型レベル辞書によってモナドスタックを表現する． 今回は次のようなモナドを定義した．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ServiceM</span> <span class="fu">=</span> <span class="dt">Eff</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ch">&#39;[ ReaderDef Config</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">   , <span class="dt">EitherDef</span> <span class="dt">ServiceException</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">   , <span class="dt">LoggerDef</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">   , <span class="st">&quot;IO&quot;</span> <span class="fu">&gt;:</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">   ]</a></code></pre></div>
<p>基本的に<a href="/posts/2017-12-09-extensible-effects-step-by-step.html">普通のモナドトランスフォーマーのように扱える</a>． じゃぁ素直にモナドトランスフォーマー使えよって感じかもしれないけど気にしないで．</p>
<h3 id="getopt-ラッパー"><code>GetOpt</code> ラッパー</h3>
<p>GHCには標準で <code>--output hoge</code> みたいな CLI のオプション引数をパースしてくれるモジュール <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/System-Console-GetOpt.html"><code>GetOpt</code></a> がある(ぼくは初めて使った)． extensible では，パース結果を拡張可能レコードにマッピングするための補助関数が<a href="https://hackage.haskell.org/package/extensible-0.4.7.1/docs/Data-Extensible-GetOpt.html">提供されている</a>．</p>
<p>キモになるのは <code>withGetOpt</code> 関数である．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">withGetOpt</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">MonadIO</span> m</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">RecordOf</span> (<span class="dt">OptionDescr</span> h) xs</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="ot">-&gt;</span> (<span class="dt">RecordOf</span> h xs <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> m a)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>一引数目の文字列はパース失敗したとき(要するにオプションが間違ってるとき)に表示する「使い方」に使われる． 例えば，whoami だと</p>
<pre><code>whoami [options] [input-file]
  -o FILE               --output=FILE                Write output to FILE instead of stdout.
  -t FORMAT, -w FORMAT  --to=FORMAT, --write=FORMAT  Specify output format. default is `markdown`.</code></pre>
<p>の <code>[options] [input-file]</code> が一引数目だ． 二引数目はオプションのパーサー(？)の定義を拡張可能レコードで与えており，三引数目がパース結果の拡張可能レコードと残りの(空白区切りの)文字列を受け取ってどうするかの振る舞いを与える．</p>
<p>まぁ詳しくは<a href="https://www.schoolofhaskell.com/user/fumieval/extensible/getopt-and-extensible-records">作者さんの記事</a>で紹介されている(英語だけど，あと一引数目の文字列はこの記事以降に追加された機能らしく，サンプルコードにはない)．</p>
<h3 id="extensible-instances">extensible-instances</h3>
<p>拡張可能レコードは全て <code>Record '[...]</code> の型エイリアスで定義する． つまり，拡張可能レコードの何らかの型クラスのインスタンスは <code>Record '[...]</code> に適用しておけば全部で使える(逆に影響力がでかいともいえる)．</p>
<p>いくつかの自作アプリーケーションでインスタンスを作っていて，ダブってたのでひとつのリポジトリにまとめた．</p>
<ul>
<li><a href="https://github.com/matsubara0507/extensible-instances">matsubara0507/extensible-instances - GitHub</a></li>
</ul>
<p>(なんか作者本人じゃないから気が引けて) Hackage にはあげてないがパッケージの体はしてるので，<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos"><code>stack.yaml</code> の <code>extra-deps</code> に記述</a>することで使えるはず．</p>
<h2 id="section-1"></h2>
<p>注意点として <a href="https://github.com/fumieval/extensible">fumieval/extensible</a> の<a href="https://github.com/fumieval/extensible/blob/master/examples/aeson.hs">例にある <code>FromJSON</code> のインスタンス</a>とは微妙に実装が違う． 作者さんのは <code>Maybe a</code> にしてもキーが存在しないといけないのだが，<code>aeson</code> の <code>Generics</code> は <code>Maybe a</code> ならキーが無くても良いので，そっちに合わせた．</p>
<h2 id="仕組み">仕組み</h2>
<p>コード自体は<a href="https://github.com/matsubara0507/whoami">このリポジトリ</a>にある．</p>
<h3 id="基本的な部分">基本的な部分</h3>
<p>基本的に Yaml ファイルにはサイト・記事・ライブラリ・アプリケーションを列挙してもらう． それらは次のような型になっている(型の値として取り出せる)．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="ch">&#39;[ &quot;name&quot;    &gt;: Text</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">   , <span class="st">&quot;account&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Accounts</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">   , <span class="st">&quot;site&quot;</span>    <span class="fu">&gt;:</span> [<span class="dt">SiteConfig</span>]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">   , <span class="st">&quot;post&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Record</span> <span class="ch">&#39;[ &quot;latest&quot; &gt;: Maybe Int, &quot;posts&quot; &gt;: [PostConfig]]</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">   , <span class="st">&quot;library&quot;</span> <span class="fu">&gt;:</span> [<span class="dt">LibConfig</span>]</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">   , <span class="st">&quot;app&quot;</span>     <span class="fu">&gt;:</span> [<span class="dt">AppConfig</span>]</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">   , <span class="st">&quot;qiita&quot;</span>   <span class="fu">&gt;:</span> <span class="dt">QiitaConfig</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">   ]</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="kw">type</span> <span class="dt">Accounts</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Text</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="kw">type</span> <span class="dt">Url</span> <span class="fu">=</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="kw">type</span> <span class="dt">Date</span> <span class="fu">=</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="kw">type</span> <span class="dt">SiteConfig</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">  <span class="ch">&#39;[ &quot;name&quot; &gt;: Text</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">   , <span class="st">&quot;url&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Url</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">   , <span class="st">&quot;description&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">   ]</a>
<a class="sourceLine" id="cb10-20" data-line-number="20"></a>
<a class="sourceLine" id="cb10-21" data-line-number="21"><span class="kw">type</span> <span class="dt">PostConfig</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">  <span class="ch">&#39;[ &quot;title&quot; &gt;: Maybe Text</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">   , <span class="st">&quot;url&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Url</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24">   , <span class="st">&quot;date&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb10-25" data-line-number="25">   ]</a>
<a class="sourceLine" id="cb10-26" data-line-number="26"></a>
<a class="sourceLine" id="cb10-27" data-line-number="27"><span class="kw">type</span> <span class="dt">LibConfig</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb10-28" data-line-number="28">  <span class="ch">&#39;[ &quot;name&quot; &gt;: Text</span></a>
<a class="sourceLine" id="cb10-29" data-line-number="29">   , <span class="st">&quot;url&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Url</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30">   , <span class="st">&quot;description&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">   , <span class="st">&quot;language&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32">   ]</a>
<a class="sourceLine" id="cb10-33" data-line-number="33"></a>
<a class="sourceLine" id="cb10-34" data-line-number="34"><span class="kw">type</span> <span class="dt">AppConfig</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb10-35" data-line-number="35">  <span class="ch">&#39;[ &quot;name&quot; &gt;: Text</span></a>
<a class="sourceLine" id="cb10-36" data-line-number="36">   , <span class="st">&quot;url&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Url</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37">   , <span class="st">&quot;description&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38">   ]</a></code></pre></div>
<p><a href="https://hackage.haskell.org/package/yaml">yaml</a>パッケージを使って，Yaml ファイルから <code>Config</code> 型にデコードしてもらう． <code>Maybe a</code> になっているところは書いてあっても無くても良い項目だ．</p>
<p>そしてサイト・記事・ライブラリ・アプリケーション固有の <code>Config</code> 型を共通のフォーマットである <code>Info</code> 型に変換する手続きを型クラスを用いて定義した．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Info</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="ch">&#39;[ &quot;name&quot; &gt;: Text</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">   , <span class="st">&quot;url&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Url</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">   , <span class="st">&quot;description&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">   , <span class="st">&quot;type&quot;</span> <span class="fu">&gt;:</span> <span class="dt">ServiceType</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">   ]</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">type</span> <span class="dt">ServiceType</span> <span class="fu">=</span> <span class="dt">Variant</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="ch">&#39;[ &quot;post&quot; &gt;: Post</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">   , <span class="st">&quot;app&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">   , <span class="st">&quot;lib&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Library</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">   , <span class="st">&quot;site&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Site</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">   ]</a>
<a class="sourceLine" id="cb11-14" data-line-number="14"></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="kw">class</span> <span class="dt">Uniform</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16"><span class="ot">  fetch ::</span> a <span class="ot">-&gt;</span> <span class="dt">ServiceM</span> <span class="dt">Data</span></a>
<a class="sourceLine" id="cb11-17" data-line-number="17"><span class="ot">  fill ::</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="ot">-&gt;</span> <span class="dt">ServiceM</span> a</a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="ot">  uniform ::</span> a <span class="ot">-&gt;</span> <span class="dt">ServiceM</span> <span class="dt">Info</span></a>
<a class="sourceLine" id="cb11-19" data-line-number="19"></a>
<a class="sourceLine" id="cb11-20" data-line-number="20"><span class="kw">type</span> <span class="dt">Data</span> <span class="fu">=</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="ot">toInfo ::</span> <span class="dt">Uniform</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ServiceM</span> <span class="dt">Info</span></a>
<a class="sourceLine" id="cb11-23" data-line-number="23">toInfo conf <span class="fu">=</span> uniform <span class="fu">=&lt;&lt;</span> fill conf <span class="fu">=&lt;&lt;</span> fetch conf</a></code></pre></div>
<p><code>Uniform</code> 型クラスに3つの関数は</p>
<ul>
<li><code>fill</code> 関数は共通のフォーマットにするための足りない情報(<code>Maybe a</code> で <code>Nothing</code> だったところ)をスクレイピングなどで補完</li>
<li><code>fetch</code> 関数はスクレイピングするための HTML などを取ってくる</li>
<li><code>uniform</code> 関数は実際に共通フォーマットに変換する</li>
</ul>
<p>といった具合だ(正直分けなくてもいい)．</p>
<h2 id="section-2"></h2>
<p>他にも GitHub・BitBacket・GitLab なんかを全部一緒に取り扱う <code>Repo</code> とかも作ってもいいかもしれない． 問題は，自分が GitHub 以外に使ってないのでテストできない点だ．</p>
<h3 id="qiita-とか">Qiita とか</h3>
<p>Qiita とかは RESTful API を叩いて記事を集めてる． そもそも記事自体を集めるところと，<code>Uniform</code> 型クラスのインスタンスを共通化するのに <code>Service</code> 型クラスを作った(名前が微妙)．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Service</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">  genInfo ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">ServiceM</span> [<span class="dt">Info</span>]</a></code></pre></div>
<p><code>Proxy a</code> なのはしょうがない． お好きなサービス(自分のサイトとかでも)を <code>Service</code> 型クラスのインスタンスにして，<code>Whoami</code> 型のインスタンスを書き換えれば，いろんなサイトを共通の形式で扱える．</p>
<h2 id="on-github-pages">on GitHub Pages</h2>
<p>GitHub Pages で簡単に使えるようにした． サンプルのリポジトリを作ったので，これをフォークして Travis CI と GitHub Pages を設定するだけで使えるはずだ(もちろん <code>whoami.yaml</code> を書き換えて)．</p>
<ul>
<li><a href="https://github.com/matsubara0507/whoami-example">matsubara0507/whoami-example - GitHub</a></li>
</ul>
<p>Stackage (というか Hackage)に置いていないツールを <code>stack install</code> するために，<code>package.yaml</code> と <code>stack.yaml</code> と <code>.gitignore</code> を置いてるけど気にしないで． Travis CI の定期実行を設定しておけば定期的に Qita の記事とかを更新してくれる．</p>
<h2 id="おしまい">おしまい</h2>
<p>そーいえば，UNIX 系には <code>whoami</code> というコマンドがあるんでしたね(Windowsユーザー)． 紛らわしい名前にしてしまった．</p>
  </div>
</div>
</article>
]]></summary>
</entry>
<entry>
    <title>「積み木の水槽」問題の Haskell での回答を読み解く</title>
    <link href="https://matsubara0507.github.io/posts/2018-02-04-water-towers-hs.html" />
    <id>https://matsubara0507.github.io/posts/2018-02-04-water-towers-hs.html</id>
    <published>2018-02-04T00:00:00Z</published>
    <updated>2018-02-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">「積み木の水槽」問題の Haskell での回答を読み解く</h1>
    <p class="post-meta">
      <time datetime="2018-02-04" itemprop="datePublished">
        Feb 4, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="/tags/Haskell.html">Haskell</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>今朝，バイト先で<a href="http://nabetani.sakura.ne.jp/hena/ord13blocktup/">「積み木の水槽」問題</a>の <a href="https://rosettacode.org/wiki/Water_collected_between_towers#Haskell">Haskell での回答</a>について話題になりました． リンク先の解答を見ると，恐ろしいことに，一行で書けてしまいます(正しくは，この解答では <code>nabetani</code> さんの問題は解けませんが…)．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">-- 2 == solve [1,5,3,7,2]</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">solve <span class="fu">=</span> sum <span class="fu">.</span> filter (<span class="fu">&gt;</span> <span class="dv">0</span>) <span class="fu">.</span> (zipWith (<span class="fu">-</span>) <span class="fu">=&lt;&lt;</span> (zipWith min <span class="fu">.</span> scanl1 max <span class="fu">&lt;*&gt;</span> scanr1 max))</a></code></pre></div>
<p>普通の Haskeller であれば，これぐらい目コンパイルして振る舞いを読み解くのは朝飯前でしょうが，Haskell 初学者のために簡単な解説を残しておこうかなと思います．</p>
<h2 id="手直し">手直し</h2>
<p>前述したとおり，そもそもこれでは <code>nabetani</code> さんの問題は解けないので，解けるように手直しします． もちろん <strong>1行で</strong> ．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">solve <span class="fu">=</span> sum <span class="fu">.</span> fmap (sum <span class="fu">.</span> (zipWith (<span class="fu">-</span>) <span class="fu">=&lt;&lt;</span> (zipWith min <span class="fu">.</span> scanl1 max <span class="fu">&lt;*&gt;</span> scanr1 max)) <span class="fu">.</span> fmap (read <span class="fu">.</span> (<span class="fu">:</span> []))) <span class="fu">.</span> words <span class="fu">.</span> fmap (bool <span class="ch">&#39; &#39;</span> <span class="fu">&lt;*&gt;</span> (<span class="fu">/=</span>) <span class="ch">&#39;0&#39;</span>)</a></code></pre></div>
<p><code>Data.List</code> と <code>Data.Bool</code> を <code>import</code> してる前提だが，一応一行で書けた． 雑に直したのでもう少し短くできるような気もしますが，まぁそもそも本質的なところでないので勘弁してください．</p>
<p>ちなみに，そもそもなんで元のコードでは解けないのかというと，<code>nabetani</code> さんの問題には <code>0</code> が含むからだ． しかし，<code>0</code> で水槽を切り分けてあげて，元の解答を <code>map</code> してあげれば良いだけなのでコアのところはそのまんま(<code>filter (&gt; 0)</code> は要らない気がしたので消したけど)．</p>
<h2 id="読み解く">読み解く</h2>
<p>手直しした最終的なコードはテストコードと共に<a href="https://gist.github.com/matsubara0507/10a44fb2a9676bde9658c3eeec456676">ココ</a>にあげた．</p>
<h3 id="トップダウンに">トップダウンに</h3>
<p>順に読み解く． Haskell でプログラミングするとき(というか関数型プログラミング)はトップダウンに書いていくのが基本なので，読み解くときも上から順に切り分けてく．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">solve ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">solve <span class="fu">=</span> sum <span class="fu">.</span> fmap countWater <span class="fu">.</span> splitTank</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">splitTank ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">splitTank <span class="fu">=</span>  words <span class="fu">.</span> fmap (bool <span class="ch">&#39; &#39;</span> <span class="fu">&lt;*&gt;</span> (<span class="fu">/=</span>) <span class="ch">&#39;0&#39;</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">countWater ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">countWater <span class="fu">=</span> sum <span class="fu">.</span> (zipWith (<span class="fu">-</span>) <span class="fu">=&lt;&lt;</span> (zipWith min <span class="fu">.</span> scanl1 max <span class="fu">&lt;*&gt;</span> scanr1 max)) <span class="fu">.</span> fmap (read <span class="fu">.</span> (<span class="fu">:</span> []))</a></code></pre></div>
<p><code>splitTank</code> 関数は <code>0</code> を区切り文字として文字列を切り分けてるだけだ． 悲しいことに，Haskell (というか GHC)の標準モジュールには「任意の文字で文字列を切り分ける」関数がない． なので，<code>0</code> だけを空白 <code>' '</code> に置換してから，<code>words</code> で切り分けている(空白で切り分ける関数 <code>words</code> は何故か標準にある)．</p>
<p><code>countWater</code> 関数が各水槽の水の数を数え上げており，それを最後に総和 <code>sum</code> しているだけだ．</p>
<h3 id="fmap-はわかるよね"><code>fmap</code> はわかるよね？</h3>
<p>ちなみに，さっきから出てきている <code>fmap</code> という関数はわかりますよね？ 多くの言語でも導入されている，リストや配列の各要素に関数を適用する関数(あるいはメソッド) <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> をより一般化したものだ． 今回はリストにしか使わないので <code>map</code> と同義だと考えてくれていい(hlint で注意されるので，<code>fmap</code> と書く癖がついた)．</p>
<h3 id="コアの部分">コアの部分</h3>
<p>さて，本題でもある <code>countWater</code> 関数を読み解く． まずは切り分けよう．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">countWater ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">countWater <span class="fu">=</span> sum <span class="fu">.</span> toWaterLine <span class="fu">.</span> toInts</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">toInts ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">toInts <span class="fu">=</span> fmap (read <span class="fu">.</span> (<span class="fu">:</span> []))</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">toWaterLine ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">toWaterLine <span class="fu">=</span> zipWith (<span class="fu">-</span>) <span class="fu">=&lt;&lt;</span> (zipWith min <span class="fu">.</span> scanl1 max <span class="fu">&lt;*&gt;</span> scanr1 max)</a></code></pre></div>
<p><code>toInts</code> 関数は数列の文字列から数値のリストに変換している． Haskell で文字列を任意の型に変換するには <code>read :: String -&gt; a</code> 関数を使う． Haskell において <code>String = [Char]</code> なので，<code>fmap (: [])</code> をして <code>String</code> のリストに変換し，各文字列を <code>read</code> をしているというわけだ(<code>singleton</code> みたいな関数が標準にあればいいのに)．</p>
<p><code>toWaterLine</code> 関数が水槽の各列の水の量を計算し，<code>sum</code> で総和している． なので，重要なのは <code>toWaterLine</code> 関数だ． <code>(&lt;*&gt;)</code> 演算子や <code>(=&lt;&lt;)</code> 演算子などがあって意味不明かもしれないが，この辺りはポイントフリーにするためのツールみたいなもので，アルゴリズムの本質的な部分ではないよ．</p>
<h3 id="関数も-monad-型クラスのインスタンス">関数も <code>Monad</code> 型クラスのインスタンス</h3>
<p><code>(&lt;*&gt;)</code> 演算子や <code>(=&lt;&lt;)</code> 演算子が何をしているかと言うのは <strong>関数型 <code>(-&gt;) a</code> も <code>Monad</code> 型クラスのインスタンス</strong> だという事実を知っていれば簡単に読めますね． Haskell 界隈では常識(要出典)なので，説明しなくても良いかもしれないが，初学者のために念のためしておく．</p>
<p>それぞれの演算子の型は以下の通り(めんどいので <code>Monad</code> で統一)．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">(&lt;*&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">(=&lt;&lt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</a></code></pre></div>
<p>で，前述したとおり，関数型 <code>(c -&gt;)</code> も <code>Monad</code> 型クラスのインスタンスなので，<code>m = (c -&gt;)</code> と置き換えれる．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">(&lt;*&gt;) ::</span> (c <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">(=&lt;&lt;) ::</span> (a <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b)</a></code></pre></div>
<p>便利そうなコンビネーターになった． なので，<code>toWaterLine</code> 関数のこれらの演算子を同様のラムダ式で置き換えてあげよう．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">toWaterLine ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">toWaterLine</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="fu">=</span> \xs <span class="ot">-&gt;</span> zipWith (<span class="fu">-</span>) ((\ys <span class="ot">-&gt;</span> (zipWith min <span class="fu">.</span> scanl1 max <span class="fu">$</span> ys) (scanr1 max ys)) xs) xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="fu">=</span> \xs <span class="ot">-&gt;</span> zipWith (<span class="fu">-</span>) ((\ys <span class="ot">-&gt;</span> zipWith min (scanl1 max ys) (scanr1 max ys)) xs) xs</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">=</span> \xs <span class="ot">-&gt;</span> zipWith (<span class="fu">-</span>) (zipWith min (scanl1 max xs) (scanr1 max xs)) xs</a></code></pre></div>
<p>ついでに，他の言語の人では分かりにくい演算子も置き換えたので，これでどの言語の人でも読めるはずだ．</p>
<h3 id="アルゴリズム">アルゴリズム</h3>
<p>ここからは Haskell 関係ない． ひとつひとつ見ていこう．</p>
<p><code>scanl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</code> 関数は左畳み込み関数 <code>foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code> の途中経過もリストで残したような関数だ． つまり <code>foldl f x xs = last $ scanl f x xs</code> が成り立つ． <code>scanl1 :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a]</code> 関数は初期値を無くしたバージョンだ． <code>scanr1</code> は <code>scanl1</code> の右畳み込みバージョン．</p>
<h2 id="section"></h2>
<p><code>scanl max xs</code> は左から順に，水槽の高さを比較して高い方を残しているので，各列の最も高い左側が残る． <code>scanr1 max xs</code> は各列の最も高い右側が残る．</p>
<p><img src="/assets/water-towers-hs/water1.gif" /></p>
<p>そして，それらの低い方を残して，もとの高さを引く．</p>
<p><img src="/assets/water-towers-hs/water2.gif" /></p>
<p>すごいできた！</p>
<h2 id="試しに">試しに</h2>
<p>次のテストコードを走らせてみた．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- WalterTowers.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">main <span class="fu">=</span> print <span class="fu">$</span> all ((<span class="fu">==</span>) <span class="fu">&lt;$&gt;</span> snd <span class="fu">&lt;*&gt;</span> (show <span class="fu">.</span> solve <span class="fu">.</span> fst)) testSet</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">solve <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">testSet ::</span> [(<span class="dt">String</span>, <span class="dt">String</span>)]</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">testSet <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  [ (<span class="st">&quot;83141310145169154671122&quot;</span>, <span class="st">&quot;24&quot;</span>)</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  , (<span class="st">&quot;923111128&quot;</span>, <span class="st">&quot;45&quot;</span>)</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  , (<span class="st">&quot;923101128&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  , (<span class="st">&quot;903111128&quot;</span>, <span class="st">&quot;9&quot;</span>)</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  , (<span class="st">&quot;3&quot;</span>, <span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">  , (<span class="st">&quot;31&quot;</span>, <span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">  , (<span class="st">&quot;412&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">  , (<span class="st">&quot;3124&quot;</span>, <span class="st">&quot;3&quot;</span>)</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  , (<span class="st">&quot;11111&quot;</span>, <span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  , (<span class="st">&quot;222111&quot;</span>, <span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  , (<span class="st">&quot;335544&quot;</span>, <span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  , (<span class="st">&quot;1223455321&quot;</span>, <span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">  , (<span class="st">&quot;000&quot;</span>, <span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">  , (<span class="st">&quot;000100020003121&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  , (<span class="st">&quot;1213141516171819181716151413121&quot;</span>, <span class="st">&quot;56&quot;</span>)</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  , (<span class="st">&quot;712131415161718191817161514131216&quot;</span>, <span class="st">&quot;117&quot;</span>)</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">  , (<span class="st">&quot;712131405161718191817161514031216&quot;</span>, <span class="st">&quot;64&quot;</span>)</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">  , (<span class="st">&quot;03205301204342100&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">  , (<span class="st">&quot;0912830485711120342&quot;</span>, <span class="st">&quot;18&quot;</span>)</a>
<a class="sourceLine" id="cb8-28" data-line-number="28">  , (<span class="st">&quot;1113241120998943327631001&quot;</span>, <span class="st">&quot;20&quot;</span>)</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">  , (<span class="st">&quot;7688167781598943035023813337019904732&quot;</span>, <span class="st">&quot;41&quot;</span>)</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">  , (<span class="st">&quot;2032075902729233234129146823006063388&quot;</span>, <span class="st">&quot;79&quot;</span>)</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">  , (<span class="st">&quot;8323636570846582397534533&quot;</span>, <span class="st">&quot;44&quot;</span>)</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">  , (<span class="st">&quot;2142555257761672319599209190604843&quot;</span>, <span class="st">&quot;41&quot;</span>)</a>
<a class="sourceLine" id="cb8-33" data-line-number="33">  , (<span class="st">&quot;06424633785085474133925235&quot;</span>, <span class="st">&quot;51&quot;</span>)</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">  , (<span class="st">&quot;503144400846933212134&quot;</span>, <span class="st">&quot;21&quot;</span>)</a>
<a class="sourceLine" id="cb8-35" data-line-number="35">  , (<span class="st">&quot;1204706243676306476295999864&quot;</span>, <span class="st">&quot;21&quot;</span>)</a>
<a class="sourceLine" id="cb8-36" data-line-number="36">  , (<span class="st">&quot;050527640248767717738306306596466224&quot;</span>, <span class="st">&quot;29&quot;</span>)</a>
<a class="sourceLine" id="cb8-37" data-line-number="37">  , (<span class="st">&quot;5926294098216193922825&quot;</span>, <span class="st">&quot;65&quot;</span>)</a>
<a class="sourceLine" id="cb8-38" data-line-number="38">  , (<span class="st">&quot;655589141599534035&quot;</span>, <span class="st">&quot;29&quot;</span>)</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">  , (<span class="st">&quot;7411279689677738&quot;</span>, <span class="st">&quot;34&quot;</span>)</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">  , (<span class="st">&quot;268131111165754619136819109839402&quot;</span>, <span class="st">&quot;102&quot;</span>)</a>
<a class="sourceLine" id="cb8-41" data-line-number="41">  ]</a></code></pre></div>
<p><code>stack runghc</code> で走らせると．</p>
<pre><code>$ stack runghc WalterTowers.hs
True</code></pre>
<h2 id="おしまい">おしまい</h2>
<p>こういうのを自分で思いつけるようになりたいね…</p>
  </div>
</div>
</article>
]]></summary>
</entry>

</feed>
