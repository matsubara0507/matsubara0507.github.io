<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="AdC の Haskell 記事を Haskell で集めた" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        AdC の Haskell 記事を Haskell で集めた
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">AdC の Haskell 記事を Haskell で集めた</h1>
    <p class="post-meta">
      <time datetime="2018-01-30" itemprop="datePublished">
        Jan 30, 2018
      </time>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>昨年最後に，Haskell-jp へ以下の記事を寄稿しました．</p>
<ul>
<li><a href="https://haskell.jp/blog/posts/2017/advent-calendar-2017.html">Haskell Advent Calendar 2017 まとめ - Haskell-jp</a></li>
</ul>
<p>2017年のアドベントカレンダーに投稿された Haskell 記事を分類して紹介してるだけです． <a href="https://scrapbox.io/miyamoen/Elm_Advent_Calendar_2017_まとめ">Elm のやつ</a>を見かけて <del>パクリ</del> オマージュしました．</p>
<h2 id="section"></h2>
<p>分類は温もりのある手作業ですが，Haskell 記事は機械的にあ集めました． 本記事はそのために作った Haskell プログラムに関するメモ書きです．</p>
<p>全てのコードは以下のリポジトリにあります．</p>
<ul>
<li><a href="https://github.com/matsubara0507/haskell-advent-calendar">matsubara0507/haskell-advent-calendar - GitHub</a></li>
</ul>
<p>特に本質的な意味は無いんですが CLI として作っています．</p>
<h2 id="作る">作る</h2>
<p>ゴールとしては，<strong>年を指定すると Qiita と ADVENTAR の全てのカレンダーをスクレイピングして，結果(Haskell 記事のリスト)を JSON ファイルに書き出す</strong> プログラムを作る． Haskell に関する記事かどうかは，単純にカレンダーか記事のタイトルに “Haskell” という単語か含まれているかどうかで判断する．</p>
<h3 id="パッケージ">パッケージ</h3>
<p>お世話になった主要なパッケージ達を先に示しておく(<a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/master/package.yaml">package.yaml</a> を見れば十分なんだけどね)．</p>
<ul>
<li><a href="https://hackage.haskell.org/package/extensible">extensible</a> : フィールド数の多いレコード型は拡張可能レコードにしちゃえ
<ul>
<li>フィールドへのアクセスには <a href="https://hackage.haskell.org/package/lens">lens</a> を用いる</li>
</ul></li>
<li><a href="https://hackage.haskell.org/package/aeson">aeson</a> : JSON の読み書きパッケージの金字塔
<ul>
<li><a href="https://hackage.haskell.org/package/aeson-pretty">aeson-pretty</a> : JSON を綺麗にインデントしてくれる</li>
</ul></li>
<li><a href="https://hackage.haskell.org/package/scalpel-core">scalpel-core</a> : スクレイパーパッケージ(core じゃなくて <a href="https://hackage.haskell.org/package/scalpel">scalpel</a> は Windows だとビルドめんどい)
<ul>
<li>Qiita の HTML の取得には <a href="https://hackage.haskell.org/package/wreq">wreq</a> を使った(操作が簡単なので)</li>
<li>ADVENTAR は React 製なので <a href="https://hackage.haskell.org/package/webdriver">webdriver</a> で Selenium を使う</li>
<li><a href="https://hackage.haskell.org/package/shelly">shelly</a> : スクレイピングが攻撃にならんよう1秒スリープ(OSに依存せずに書ける)</li>
</ul></li>
<li><a href="https://hackage.haskell.org/package/conduit-combinators">conduit-combinators</a> : ストリーミングパッケージの金字塔
<ul>
<li>コッチの方が <a href="https://hackage.haskell.org/package/conduit">conduit</a> より名前の衝突なく関数が使えるので(大本は同じ)</li>
</ul></li>
<li><a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> : CLI の引数をいい感じに処理してくれる</li>
</ul>
<p>今回の主目的ではないが，このプログラムは extensible の拡張可能レコードを用いた optparse-applicative のサンプルコードにもなっていると思う．</p>
<h3 id="記事の型を考える">記事の型を考える</h3>
<p>最低限必要なのは，記事のタイトルと URL である． 他に，記事の著者と記事が投稿されたカレンダー・日付があった方が，あとで列挙するときに映えるだろう． ということで，以下の型を考えた．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds         #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators     #-}</span>

<span class="kw">import </span><span class="dt">Data.Extensible</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)

<span class="kw">type</span> <span class="dt">Post</span> <span class="fu">=</span> <span class="dt">Record</span>
   <span class="ch">'[ &quot;title&quot; &gt;: Text</span>
    , <span class="st">&quot;auther&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span>
    , <span class="st">&quot;url&quot;</span> <span class="fu">&gt;:</span> <span class="dt">URL</span>
    , <span class="st">&quot;date&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Date</span>
    , <span class="st">&quot;calendar&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Calendar</span>
    , <span class="st">&quot;category&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span>
    ]

<span class="kw">type</span> <span class="dt">URL</span> <span class="fu">=</span> <span class="dt">Text</span>
<span class="kw">type</span> <span class="dt">Date</span> <span class="fu">=</span> <span class="dt">Text</span>

<span class="kw">type</span> <span class="dt">Calendar</span> <span class="fu">=</span> <span class="dt">Record</span>
   <span class="ch">'[ &quot;title&quot; &gt;: Text</span>
    , <span class="st">&quot;url&quot;</span> <span class="fu">&gt;:</span> <span class="dt">URL</span>
    ]</code></pre></div>
<p><code>&quot;category&quot;</code> は後の(手作業による)分類で用いる． extensible による拡張可能レコードな型だが，何となく読めるだろう(分からなかったググって)．</p>
<h2 id="section-1"></h2>
<p>インターフェースを揃えるために，<code>Qiita</code> や <code>ADVENTAR</code> って感じの型から 記事のリスト <code>[Post]</code> を返す型クラスを定義しておく(正直あんまり意味はない)．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ToPosts</span> a <span class="kw">where</span>
<span class="ot">  getPosts ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Post</span>]</code></pre></div>
<p>順にインスタンスを定義していく．</p>
<h3 id="adventar">ADVENTAR</h3>
<p><a href="../posts/2017-12-02-re-adventar-slack-bot-part1.html">ADVENTAR は昔集めた</a>ので簡単だ．</p>
<h4 id="カレンダーの記事を集める">カレンダーの記事を集める</h4>
<p>まずは，カレンダーの URL を与えたら記事のリストを返す関数を書く．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">TIO</span>
<span class="kw">import </span><span class="dt">Shelly</span> (shelly, sleep)
<span class="kw">import </span><span class="dt">Test.WebDriver</span> (<span class="dt">WDConfig</span>)
<span class="kw">import </span><span class="dt">Text.HTML.Scalpel.Core</span>

<span class="kw">data</span> <span class="dt">Adventar</span> <span class="fu">=</span> <span class="dt">Adventar</span> <span class="dt">URL</span> <span class="dt">WDConfig</span>

<span class="kw">instance</span> <span class="dt">ToPosts</span> <span class="dt">Adventar</span> <span class="kw">where</span>
  getPosts (<span class="dt">Adventar</span> url conf) <span class="fu">=</span> <span class="kw">do</span>
    html <span class="ot">&lt;-</span> fetchHtmlWith conf url
  <span class="kw">let</span>
    posts <span class="fu">=</span> fromMaybe [] <span class="fu">$</span> scrapeHtml postsScraper html
  TIO.putStrLn <span class="fu">$</span> <span class="st">&quot;get posts on &quot;</span> <span class="ot">`mappend`</span> url
  shelly <span class="fu">$</span> sleep <span class="dv">1</span>
  return posts

<span class="ot">scrapeHtml ::</span> <span class="dt">Scraper</span> <span class="dt">Html</span> a <span class="ot">-&gt;</span> <span class="dt">Html</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
scrapeHtml <span class="fu">=</span> flip scrapeStringLike

<span class="kw">type</span> <span class="dt">Html</span> <span class="fu">=</span> <span class="dt">Text</span>

<span class="ot">fetchHtmlWith ::</span> <span class="dt">WDConfig</span> <span class="ot">-&gt;</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Html</span>
fetchHtmlWith <span class="fu">=</span> undefined

<span class="ot">postsScraper ::</span> <span class="dt">Scraper</span> <span class="dt">Html</span> [<span class="dt">Post</span>]
postsScraper <span class="fu">=</span> undefined</code></pre></div>
<p>ADVENTAR のカレンダーのページは React 製(?)かなんからしく，静的な HTML からでは記事を参照することが出来ない そのために，Selenium などのヘッドレスブラウザを使ってアクセスする． <code>WDConfig</code> は Haskell から Selenium などを操作するための Web Driver の設定値の型である．</p>
<p><code>shelly $ sleep 1</code> はDOS攻撃にならないように，ここで処理を1秒止めるために書いている．</p>
<h2 id="section-2"></h2>
<p><code>fetchHtmlWith</code> と <code>postsScraper</code> はこんな感じ．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fetchHtmlWith ::</span> <span class="dt">WDConfig</span> <span class="ot">-&gt;</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Html</span>
fetchHtmlWith config url <span class="fu">=</span> runSession config <span class="fu">$</span> <span class="kw">do</span>
  openPage (unpack url)
  html <span class="ot">&lt;-</span> getSource
  closeSession
  return html</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Default</span> (def)

<span class="ot">postsScraper ::</span> <span class="dt">Scraper</span> <span class="dt">Html</span> [<span class="dt">Post</span>]
postsScraper <span class="fu">=</span>
  chroots (<span class="st">&quot;table&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-entryList&quot;</span>] <span class="fu">//</span> <span class="st">&quot;tr&quot;</span>) entryScraper

<span class="ot">entryScraper ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Post</span>
entryScraper <span class="fu">=</span> hsequence
    <span class="fu">$</span> <span class="fu">#</span>title    <span class="fu">&lt;@=&gt;</span> titleScraper
   <span class="fu">&lt;:</span> <span class="fu">#</span>auther   <span class="fu">&lt;@=&gt;</span> autherScraper
   <span class="fu">&lt;:</span> <span class="fu">#</span>url      <span class="fu">&lt;@=&gt;</span> urlScraper
   <span class="fu">&lt;:</span> <span class="fu">#</span>date     <span class="fu">&lt;@=&gt;</span> dateScraper
   <span class="fu">&lt;:</span> <span class="fu">#</span>calendar <span class="fu">&lt;@=&gt;</span> pure def
   <span class="fu">&lt;:</span> <span class="fu">#</span>category <span class="fu">&lt;@=&gt;</span> pure <span class="st">&quot;&quot;</span>
   <span class="fu">&lt;:</span> nil

<span class="ot">autherScraper ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Text</span>
autherScraper <span class="fu">=</span> text <span class="fu">$</span> <span class="st">&quot;td&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-entryList-user&quot;</span>] <span class="fu">//</span> <span class="st">&quot;span&quot;</span>

<span class="fu">...</span></code></pre></div>
<p><code>xxxScraper</code> を全部書いてると長くなるので割愛(<a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/src/AdventCalendar/Adventar/Scraper.hs">ココ</a>に全部ある)．</p>
<h4 id="脱線-拡張可能レコードの-etc..">脱線 : 拡張可能レコードの etc..</h4>
<p><a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Field.html#v:-60--64--61--62-"><code>(&lt;@=&gt;)</code></a> 演算子は拡張可能レコードの値を設定する演算子 <a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Field.html#v:-64--61-"><code>(@=)</code></a> のモナディック版(正確には <code>Functor</code>)というイメージだ． <strong>かなり</strong> 直感的に型を書くと次のようになる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(@=) ::</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> (k <span class="fu">:&gt;</span> v)
<span class="ot">(&lt;@=&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> f v <span class="ot">-&gt;</span> f (k <span class="fu">:&gt;</span> v)</code></pre></div>
<p>拡張可能レコードはフィールド名とフィールドの値の型レベル辞書みたいなモノであり，<code>k :&gt; v</code> が辞書のイチ要素というイメージだ． <a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Product.html#v:-60-:"><code>(&lt;:)</code></a> で <code>[kv1, kv2, ... kvn]</code> のような辞書を構築する(<a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Product.html#v:nil"><code>nil</code></a> が空リスト)．</p>
<p><a href="https://hackage.haskell.org/package/extensible-0.4.7/docs/Data-Extensible-Product.html#v:hsequence"><code>hsequence</code></a> 関数で <code>[f (k1 :&gt; v1), ..., f (kn :&gt; vn)] -&gt; f [(k1 :&gt; v1), ... (kn :&gt; vn)]</code> という型の変換をしているイメージだ(あくまでイメージね)．</p>
<h2 id="section-3"></h2>
<p><code>def</code> は <a href="https://hackage.haskell.org/package/data-default">data-default</a> パッケージの値で，<a href="https://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html#t:Default"><code>Default</code></a> 型クラスのインスタンスにしないと使えない． 拡張可能レコードのインスタンス化の説明はめんどくさいので割愛する． <a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/src/Data/Extensible/Instance/Default.hs">ココ</a>に書いてあるので参照してください．</p>
<h4 id="カレンダーを加える">カレンダーを加える</h4>
<p>このままだとカレンダーが <code>def</code> のまま(URL もカレンダー名も <code>&quot;&quot;</code>)なので，スクレイピングしたカレンダーの情報を加えよう．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Lens</span> (set)
<span class="kw">import </span><span class="dt">Data.Text</span> (strip)

getPosts (<span class="dt">Adventar</span> url conf) <span class="fu">=</span> <span class="kw">do</span>
  html <span class="ot">&lt;-</span> fetchHtmlWith conf url
  <span class="kw">let</span>
    posts <span class="fu">=</span> fromMaybe [] <span class="fu">$</span> scrapeHtml postsScraper html
    calendar
        <span class="fu">=</span> <span class="fu">#</span>title <span class="fu">@=</span> fromMaybe <span class="st">&quot;&quot;</span> (scrapeHtml headerTitleScraper html)
       <span class="fu">&lt;:</span> <span class="fu">#</span>url   <span class="fu">@=</span> url
       <span class="fu">&lt;:</span> emptyRecord
  TIO.putStrLn <span class="fu">$</span> <span class="st">&quot;get posts on &quot;</span> <span class="ot">`mappend`</span> url
  shelly <span class="fu">$</span> sleep <span class="dv">1</span>
  return <span class="fu">$</span> fmap (set <span class="fu">#</span>calendar calendar) posts

<span class="ot">headerTitleScraper ::</span> <span class="dt">Scraper</span> <span class="dt">Html</span> <span class="dt">Text</span>
headerTitleScraper <span class="fu">=</span> strip <span class="fu">&lt;$&gt;</span> text (<span class="st">&quot;head&quot;</span> <span class="fu">//</span> <span class="st">&quot;title&quot;</span>)</code></pre></div>
<p><code>strip</code> は文字列の前後の空白などを排除してくれる．</p>
<h4 id="カレンダーを集める">カレンダーを集める</h4>
<p>カレンダーから記事を集めるだとまだ半分． カレンダー自体を集めないと全ての記事を確認できない．</p>
<p>ADVENTAR の場合は，<code>&quot;https://adventar.org/calendars?year=2017</code> という URL で任意の年のカレンダーの一覧を取得できる． この URL からカレンダーの URL のリストを返す関数を定義する．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getUrls ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">URL</span>]
getUrls url <span class="fu">=</span> <span class="kw">do</span>
  html <span class="ot">&lt;-</span> fetchHtml url
  return <span class="fu">$</span> fromMaybe [] (scrapeHtml calendarUrlsScraper html)

<span class="ot">fetchHtml ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Html</span>
fetchHtml url <span class="fu">=</span> <span class="kw">do</span>
  response <span class="ot">&lt;-</span> get <span class="fu">$</span> unpack url
  return <span class="fu">$</span> fromMaybe <span class="st">&quot;&quot;</span> (decodeConvertText <span class="fu">.</span> <span class="dt">UTF8</span> <span class="fu">$</span> response <span class="fu">^.</span> responseBody)

<span class="ot">calendarUrlsScraper ::</span> <span class="dt">Scraper</span> <span class="dt">Html</span> [<span class="dt">URL</span>]
calendarUrlsScraper <span class="fu">=</span>
  chroots (<span class="st">&quot;div&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-calendarList&quot;</span>] <span class="fu">//</span> <span class="st">&quot;ul&quot;</span> <span class="fu">//</span> <span class="st">&quot;li&quot;</span>) <span class="fu">$</span> <span class="kw">do</span>
    url <span class="ot">&lt;-</span> attr <span class="st">&quot;href&quot;</span> <span class="fu">$</span>
      (<span class="st">&quot;div&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-calendarList-title&quot;</span>]) <span class="fu">//</span> <span class="st">&quot;a&quot;</span>
    return <span class="fu">$</span> append <span class="st">&quot;http://adventar.org&quot;</span> url</code></pre></div>
<p>こっちは静的な HTML で動作するのでヘッドレスブラウザは使わない． ただ単に HTML の文字列さへ手に入ればいいので，扱うのが簡単な wreq を今回は使った． <code>get</code> という関数に URL を適用するだけで，HTML (型は <code>ByteString</code>) を返してくれる．</p>
<h5 id="vs.文字コード">vs. 文字コード</h5>
<p><code>ByteString</code> から <code>Text</code> への変換はかなりめんどくさい． というのも，文字コード回りで簡単に例外を投げるからだ．</p>
<p>例えば，記事のリンク先が PDF のようなバイナリファイルだと UTF-8 の <code>Text</code> に変換できなくて例外を投げてくる． もちろん，カレンダーの URL を集める場合は，そんな心配は無いんだけど，Qiita のところで困る…</p>
<h2 id="section-4"></h2>
<p>ちゃんとやるなら例外に合わせて処理を分けるべきだが，めんどくさいので例外を返す場合は <code>Nothing</code> が返ってくる <a href="https://hackage.haskell.org/package/text-conversions">text-conversions</a> パッケージを文字列変換に用いた．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;</span> decodeConvertText (<span class="dt">UTF8</span> (<span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">ByteString</span>))<span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
<span class="dt">Just</span> <span class="st">&quot;hello&quot;</span>
<span class="fu">&gt;&gt;</span> decodeConvertText (<span class="dt">UTF8</span> (<span class="st">&quot;\xc3\x28&quot;</span><span class="ot"> ::</span> <span class="dt">ByteString</span>))<span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
<span class="dt">Nothing</span></code></pre></div>
<h4 id="インスタンスの更新">インスタンスの更新</h4>
<p><code>getUrls</code> を使ってインスタンスを書き換える．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToPosts</span> <span class="dt">Adventar</span> <span class="kw">where</span>
  getPosts (<span class="dt">Adventar</span> url conf) <span class="fu">=</span> <span class="kw">do</span>
    urls <span class="ot">&lt;-</span> getUrls url
    mconcat <span class="fu">&lt;$&gt;</span> mapM (getPosts' conf) urls

<span class="ot">getPosts' ::</span> <span class="dt">WDConfig</span> <span class="ot">-&gt;</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Post</span>]
getPosts' conf url <span class="fu">=</span> <span class="kw">do</span>
  <span class="fu">...</span></code></pre></div>
<p><code>getPosts'</code> は，もともとの <code>getPosts</code> 関数と同じ実装である． 扱うのが楽になるように，スマートコンストラクタを定義しておく．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">adventar ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">WDConfig</span> <span class="ot">-&gt;</span> <span class="dt">Adventar</span>
adventar year <span class="fu">=</span>
  <span class="dt">Adventar</span> <span class="fu">$</span> <span class="st">&quot;https://adventar.org/calendars?year=&quot;</span> <span class="ot">`mappend`</span> year

<span class="ot">mkDriver ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">WDConfig</span>
mkDriver host port <span class="fu">=</span> useBrowser chrome <span class="fu">$</span>
  defaultConfig { wdHost <span class="fu">=</span> T.unpack host, wdPort <span class="fu">=</span> port }</code></pre></div>
<h4 id="haskell-の記事か否か">Haskell の記事か否か</h4>
<p>分類はカレンダーか記事のタイトルに「Haskell」という単語か含まれるか否かで判断する． 雑だけど，自然言語処理とか良く分からないので勘弁して．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isHaskellPost ::</span> <span class="dt">Post</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isHaskellPost post <span class="fu">=</span> any (<span class="st">&quot;Haskell&quot;</span> <span class="ot">`isInfixOf`</span>)
  [ post <span class="fu">^.</span> <span class="fu">#</span>title
  , post <span class="fu">^.</span> <span class="fu">#</span>calendar <span class="fu">^.</span> <span class="fu">#</span>title
  ]</code></pre></div>
<p>この関数を使って <code>filter</code> すれば良い．</p>
<h4 id="実行">実行</h4>
<p>Selenium を <code>localhost:4444</code> として何らかの方法で起動しておく．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> stack ghci
<span class="fu">&gt;&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span>
<span class="fu">&gt;&gt;</span> fmap (filter isHaskellPost) <span class="fu">.</span> getPosts <span class="fu">$</span> adventar <span class="st">&quot;2017&quot;</span> (mkDriver <span class="st">&quot;localhost&quot;</span> <span class="dv">4444</span>)
get posts on http<span class="fu">://</span>adventar<span class="fu">.</span>org<span class="fu">/</span><span class="dv">1111</span>
<span class="fu">...</span></code></pre></div>
<p>すっごい時間かかるよ(笑)</p>
<h3 id="qiita">Qiita</h3>
<p>やることは基本同じなのでサクッと．</p>
<h4 id="カレンダーの-url-を集める">カレンダーの URL を集める</h4>
<p>Qiita の場合，カレンダーの一覧は複数ページに分かれている(URL は <code>https://qiita.com/advent-calendar/2017/calendars?page=1</code> って感じ)． 無限リストで試しにカレンダーの一覧を取得し，ひとつも取得できなければ止めるようにする．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getUrls ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">URL</span>]
getUrls _ [] <span class="fu">=</span> pure []
getUrls url (n<span class="fu">:</span>ns) <span class="fu">=</span> <span class="kw">do</span>
  result <span class="ot">&lt;-</span> func n
  <span class="kw">case</span> result <span class="kw">of</span>
    [] <span class="ot">-&gt;</span> pure result
    _  <span class="ot">-&gt;</span> mappend result <span class="fu">&lt;$&gt;</span> getUrls url ns
  <span class="kw">where</span>
    func index <span class="fu">=</span> <span class="kw">do</span>
      html <span class="ot">&lt;-</span> fetchHtml <span class="fu">$</span> calendarsUrl url index
      shelly <span class="fu">$</span> sleep <span class="dv">1</span>
      return <span class="fu">$</span> fromMaybe [] (scrapeHtml calendarUrlsScraper html)

<span class="ot">calendarsUrl ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">URL</span>
calendarsUrl url index <span class="fu">=</span> mconcat [url, <span class="st">&quot;?page=&quot;</span>, pack <span class="fu">$</span> show index]

<span class="ot">calendarUrlsScraper ::</span> <span class="dt">Scraper</span> <span class="dt">Html</span> [<span class="dt">URL</span>]
calendarUrlsScraper <span class="fu">=</span>
  chroots (<span class="st">&quot;table&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;adventCalendarList&quot;</span>] <span class="fu">//</span> <span class="st">&quot;tbody&quot;</span> <span class="fu">//</span> <span class="st">&quot;tr&quot;</span>) <span class="fu">$</span> <span class="kw">do</span>
    url <span class="ot">&lt;-</span> attr <span class="st">&quot;href&quot;</span> <span class="fu">$</span>
      (<span class="st">&quot;td&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;adventCalendarList_calendarTitle&quot;</span>]) <span class="fu">//</span> <span class="st">&quot;a&quot;</span>
    return <span class="fu">$</span> append <span class="st">&quot;http://qiita.com&quot;</span> url</code></pre></div>
<p>なんかもっといい方法ありそう．</p>
<h4 id="カレンダーを集める-1">カレンダーを集める</h4>
<p>インスタンスを定義しよう．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Qiita</span> <span class="fu">=</span> <span class="dt">Qiita</span> <span class="dt">URL</span>

<span class="kw">instance</span> <span class="dt">ToPosts</span> <span class="dt">Qiita</span> <span class="kw">where</span>
  getPosts (<span class="dt">Qiita</span> url) <span class="fu">=</span> <span class="kw">do</span>
    urls <span class="ot">&lt;-</span> getUrls url [<span class="dv">1</span><span class="fu">..</span><span class="dv">1</span>]
    mconcat <span class="fu">&lt;$&gt;</span> mapM getPosts' urls

<span class="ot">getPosts' ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Post</span>]
getPosts' url <span class="fu">=</span> <span class="kw">do</span>
  html <span class="ot">&lt;-</span> fetchHtml url
  <span class="kw">let</span>
    posts <span class="fu">=</span> fromMaybe [] <span class="fu">$</span> scrapeHtml postsScraper html
    calendar
        <span class="fu">=</span> <span class="fu">#</span>title <span class="fu">@=</span> fromMaybe <span class="st">&quot;&quot;</span> (scrapeHtml headerTitleScraper html)
       <span class="fu">&lt;:</span> <span class="fu">#</span>url   <span class="fu">@=</span> url
       <span class="fu">&lt;:</span> emptyRecord
  TIO.putStrLn <span class="fu">$</span> <span class="st">&quot;get posts on &quot;</span> <span class="ot">`mappend`</span> url
  shelly <span class="fu">$</span> sleep <span class="dv">1</span>
  return <span class="fu">$</span> fmap (set <span class="fu">#</span>calendar calendar) posts

<span class="ot">postsScraper ::</span> <span class="dt">Scraper</span> <span class="dt">Html</span> [<span class="dt">Post</span>]
postsScraper <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p>長いのでスクレイパーは割愛(<a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/src/AdventCalendar/Qiita/Scraper.hs">ココ</a>にある)． <code>fetchHtml</code> 関数は ADVENTAR のと同じ．</p>
<h4 id="記事のタイトルを取得">記事のタイトルを取得</h4>
<p>ADVENTAR と違い，Qiita のカレンダーには各記事のタイトルが書いてない． さすがに「なんか書く」で Haskell 記事か否かを判断するのもなぁと思い，どーーーー考えても時間がかかるけど，記事をひとつひとつスクレイピングしてタイトルを取ってくることにした．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getPosts' ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Post</span>]
getPosts' url <span class="fu">=</span> <span class="kw">do</span>
  <span class="fu">...</span>
  TIO.putStrLn <span class="fu">$</span> <span class="st">&quot;get posts on &quot;</span> <span class="ot">`mappend`</span> url
  shelly <span class="fu">$</span> sleep <span class="dv">1</span>
  mapM updatePostTitle' <span class="fu">$</span> set <span class="fu">#</span>calendar calendar <span class="fu">&lt;$&gt;</span> posts

<span class="ot">updatePostTitle ::</span> <span class="dt">Post</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Post</span>
updatePostTitle post <span class="fu">=</span> <span class="kw">do</span>
html <span class="ot">&lt;-</span> fetchHtml' <span class="fu">$</span> post <span class="fu">^.</span> <span class="fu">#</span>url
<span class="kw">let</span>
  title <span class="fu">=</span> fromMaybe (post <span class="fu">^.</span> <span class="fu">#</span>title) <span class="fu">$</span> scrapeHtml headerTitleScraper html
return <span class="fu">$</span> post <span class="fu">&amp;</span> <span class="fu">#</span>title <span class="fu">.~</span> title

<span class="ot">updatePostTitle' ::</span> <span class="dt">Post</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Post</span>
updatePostTitle' post <span class="fu">=</span> shelly (sleep <span class="dv">1</span>) <span class="fu">&gt;&gt;</span> updatePostTitle post</code></pre></div>
<p><code>updatePostTitle'</code> 関数で(1秒だけスリープしつつ)タイトルをスクレイピングして更新している．</p>
<h4 id="実行してみる">実行してみる</h4>
<p>スマートコンストラクタを作って．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">qiita ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Qiita</span>
qiita year <span class="fu">=</span>
  <span class="dt">Qiita</span> <span class="fu">$</span> mconcat [<span class="st">&quot;https://qiita.com/advent-calendar/&quot;</span>, year, <span class="st">&quot;/calendars&quot;</span>]</code></pre></div>
<p>実行してみる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> stack ghci
<span class="fu">&gt;&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span>
<span class="fu">&gt;&gt;</span> fmap (filter isHaskellPost) <span class="fu">.</span> getPosts <span class="fu">$</span> qiita <span class="st">&quot;2017&quot;</span>
<span class="fu">...</span></code></pre></div>
<p>悲しいことに，鬼のように時間がかかるのに…メモリダンプします… まぁわかってたけどね！</p>
<h3 id="ストリーミング">ストリーミング</h3>
<p>こういうパフォーマンス的なことは自分は詳しくない． しかしこういうのはたぶん，要らないデータ(<code>filter</code> して捨てるデータ)をいつ迄も保持してるのが悪いので(たぶん)，ストリーミングパッケージを使って効率よくリソース管理してもらおう．</p>
<p>今回は Conduit を使う． 最初は Pipes を使ってみたけど，よくわからなくてやめた．</p>
<h2 id="section-5"></h2>
<p>まずはインターフェースの型クラスを書き換える．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Conduit</span> (<span class="dt">Source</span>)

<span class="kw">class</span> <span class="dt">ToPosts</span> a <span class="kw">where</span>
<span class="ot">  getPosts ::</span> a <span class="ot">-&gt;</span> <span class="dt">Source</span> <span class="dt">IO</span> <span class="dt">Post</span></code></pre></div>
<p>あとはそれぞれのインスタンスを書き換えるだけ．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToPosts</span> <span class="dt">Adventar</span> <span class="kw">where</span>
  getPosts (<span class="dt">Adventar</span> url conf) <span class="fu">=</span> <span class="kw">do</span>
    urls <span class="ot">&lt;-</span> lift <span class="fu">$</span> getUrls url
    yieldMany urls <span class="fu">=$=</span> concatMapMC (getPosts' conf)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToPosts</span> <span class="dt">Qiita</span> <span class="kw">where</span>
  getPosts (<span class="dt">Qiita</span> url) <span class="fu">=</span> <span class="kw">do</span>
    urls <span class="ot">&lt;-</span> lift <span class="fu">$</span> getUrls url [<span class="dv">1</span><span class="fu">..</span>]
    yieldMany urls <span class="fu">=$=</span> concatMapMC getPosts'</code></pre></div>
<p>使うときは以下のようにすればよい．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> stack ghci
<span class="fu">&gt;&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span>
<span class="fu">&gt;&gt;</span> <span class="kw">import </span><span class="dt">Conduit</span> (($$), (=$=), sinkList)
<span class="fu">&gt;&gt;</span> getPosts (qiita <span class="st">&quot;2017&quot;</span>) <span class="fu">$=</span> filterC isHaskellPost <span class="fu">$$</span> sinkList</code></pre></div>
<h3 id="json-に書き出す">JSON に書き出す</h3>
<p>前にやったものをそのままコピペした．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Aeson.Encode.Pretty</span> (encodePrettyToTextBuilder)
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>, unpack)
<span class="kw">import </span><span class="dt">Data.Text.Lazy.Builder</span> (toLazyText)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">LT</span>

<span class="ot">writeJson ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
writeJson jsonPath <span class="fu">=</span>
  <span class="dt">LT</span><span class="fu">.</span>writeFile (unpack jsonPath) <span class="fu">.</span> toLazyText <span class="fu">.</span> encodePrettyToTextBuilder</code></pre></div>
<p>拡張可能レコードの <code>ToJSON</code> のインスタンス化の部分は割愛(<a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/src/Data/Extensible/Instance/Aeson.hs">ココ</a>にある)．</p>
<h3 id="コマンド化">コマンド化</h3>
<p>CLI のオプション(引数)のパースには optparse-applicative パッケージを使う． スクレイピングには，次のようなオプションの型を考える．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Cmd</span>
  <span class="fu">=</span> <span class="dt">Fetch</span> <span class="dt">FetchOptions</span>

<span class="kw">type</span> <span class="dt">FetchOptions</span> <span class="fu">=</span> <span class="dt">Record</span>
   <span class="ch">'[ &quot;year&quot; &gt;: Text</span>
    , <span class="st">&quot;qiita&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span>
    , <span class="st">&quot;adventar&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span>
    , <span class="st">&quot;wdHost&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span>
    , <span class="st">&quot;wdPort&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span>
    , <span class="st">&quot;output&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span>
    ]</code></pre></div>
<p><code>year</code> はスクレイピングして欲しい年． <code>qiita</code> や <code>adventar</code> は <code>--qiita</code> って感じのフラグで，フラグが真のものだけ集めてくる(両方偽の場合は，両方真と同じく両方集める)． <code>wdHost</code> と <code>wdPort</code> はヘッドレスブラウザへのオプションで，指定が無ければ <code>localhost:4444</code> をデフォルト値にする． <code>output</code> は <code>-o hoge.json</code> みたいに出力先のファイルを指定する．</p>
<h2 id="section-6"></h2>
<p>例の如く，拡張可能レコードなので，<code>(&lt;@=&gt;)</code> 演算子を使ってパーサーを組み立てていく．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cmdParser ::</span> <span class="dt">Parser</span> <span class="dt">Cmd</span>
cmdParser <span class="fu">=</span> subparser <span class="fu">$</span>
     command <span class="st">&quot;fetch&quot;</span>
       (<span class="dt">Fetch</span> <span class="fu">&lt;$&gt;</span> fetchOptsParser <span class="ot">`withInfo`</span> <span class="st">&quot;fetch posts on advent calendar to json file.&quot;</span>)
  <span class="fu">&lt;&gt;</span> metavar <span class="st">&quot;( fetch )&quot;</span>
  <span class="fu">&lt;&gt;</span> help <span class="st">&quot;choice subcommand&quot;</span>

<span class="ot">fetchOptsParser ::</span> <span class="dt">Parser</span> <span class="dt">FetchOptions</span>
fetchOptsParser <span class="fu">=</span> hsequence
    <span class="fu">$</span> <span class="fu">#</span>year     <span class="fu">&lt;@=&gt;</span> yearParser
   <span class="fu">&lt;:</span> <span class="fu">#</span>qiita    <span class="fu">&lt;@=&gt;</span> qiitaFlagParser
   <span class="fu">&lt;:</span> <span class="fu">#</span>adventar <span class="fu">&lt;@=&gt;</span> adventarFlagParser
   <span class="fu">&lt;:</span> <span class="fu">#</span>wdHost   <span class="fu">&lt;@=&gt;</span> wdHostParser
   <span class="fu">&lt;:</span> <span class="fu">#</span>wdPort   <span class="fu">&lt;@=&gt;</span> wdPortParser
   <span class="fu">&lt;:</span> <span class="fu">#</span>output   <span class="fu">&lt;@=&gt;</span> outputParser
   <span class="fu">&lt;:</span> nil</code></pre></div>
<p>細かいやつは割愛(<a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/app/Options.hs">ココ</a>を見て)．</p>
<h2 id="section-7"></h2>
<p><code>main</code> 関数も長いので割愛(<a href="https://github.com/matsubara0507/haskell-advent-calendar/blob/f6d6a097c08e741239f576693e3d6b2b7ae21a29/app/Main.hs">ココ</a>を見て)．</p>
<p>こんな感じに実行する．</p>
<pre><code>$ stack exec -- advent-calendar fetch 2017 --qiita -o &quot;&quot;./out/qiita.json&quot;</code></pre>
<p>スクレイピングの結果は GitHub の<a href="https://github.com/matsubara0507/haskell-advent-calendar/tree/f6d6a097c08e741239f576693e3d6b2b7ae21a29/out/2017">ココ</a>に置いてある．</p>
<h3 id="マークダウンに変換">マークダウンに変換</h3>
<p>最後にマークダウンへ変換する部分を書く． 次のようなサブコマンドを追加する想定だ．</p>
<pre><code>$ stack exec -- advent-calendar markdown &quot;./out/qiita.json&quot; &quot;./out/adventar.json&quot; -o &quot;./out/posts.md&quot;</code></pre>
<p>そのために次のような型とパーサーを定義した．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Cmd</span>
  <span class="fu">=</span> <span class="dt">Fetch</span> <span class="dt">FetchOptions</span>
  <span class="fu">|</span> <span class="dt">Markdown</span> <span class="dt">MarkdownOptions</span>

<span class="kw">type</span> <span class="dt">MarkdownOptions</span> <span class="fu">=</span> <span class="dt">Record</span>
   <span class="ch">'[ &quot;inputs&quot; &gt;: [Text]</span>
    , <span class="st">&quot;output&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
    , <span class="st">&quot;noCategory&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span>
    ]

<span class="ot">cmdParser ::</span> <span class="dt">Parser</span> <span class="dt">Cmd</span>
cmdParser <span class="fu">=</span> subparser <span class="fu">$</span>
     command <span class="st">&quot;fetch&quot;</span>
       (<span class="dt">Fetch</span> <span class="fu">&lt;$&gt;</span> fetchOptsParser <span class="ot">`withInfo`</span> <span class="st">&quot;fetch posts on advent calendar to json file.&quot;</span>)
  <span class="fu">&lt;&gt;</span> command <span class="st">&quot;markdown&quot;</span>
       (<span class="dt">Markdown</span> <span class="fu">&lt;$&gt;</span> mdOptsParser <span class="ot">`withInfo`</span> <span class="st">&quot;convert markdown from posts json file.&quot;</span>)
  <span class="fu">&lt;&gt;</span> metavar <span class="st">&quot;( fetch | markdown )&quot;</span>
  <span class="fu">&lt;&gt;</span> help <span class="st">&quot;choice subcommand&quot;</span>

<span class="ot">mdOptsParser ::</span> <span class="dt">Parser</span> <span class="dt">MarkdownOptions</span>
mdOptsParser <span class="fu">=</span> hsequence
    <span class="fu">$</span> <span class="fu">#</span>inputs     <span class="fu">&lt;@=&gt;</span> inputsParser
   <span class="fu">&lt;:</span> <span class="fu">#</span>output     <span class="fu">&lt;@=&gt;</span> outputParser'
   <span class="fu">&lt;:</span> <span class="fu">#</span>noCategory <span class="fu">&lt;@=&gt;</span> noCategoryParser
   <span class="fu">&lt;:</span> nil

<span class="ot">inputsParser ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]
inputsParser <span class="fu">=</span> some <span class="fu">$</span>
  textArgument (metavar <span class="st">&quot;inputs&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Input json file paths&quot;</span>)</code></pre></div>
<p><code>some</code> を使うことで，ひとつ以上の入力ファイルのパスを与える部分(<code>markdown &quot;./out/qiita.json&quot; &quot;./out/adventar.json&quot;</code>)のパーサーを簡単に書ける．</p>
<h2 id="section-8"></h2>
<p>マークダウンへの変換部分はこんな感じ．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toMarkdown ::</span> <span class="dt">Post</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
toMarkdown post <span class="fu">=</span> mconcat <span class="fu">&lt;$&gt;</span>
  [ [ <span class="st">&quot;**[&quot;</span>, post <span class="fu">^.</span> <span class="fu">#</span>title, <span class="st">&quot;](&quot;</span>, post <span class="fu">^.</span> <span class="fu">#</span>url, <span class="st">&quot;)**  &quot;</span> ]
  , [ <span class="st">&quot; by &quot;</span>, post <span class="fu">^.</span> <span class="fu">#</span>auther
    , <span class="st">&quot; on [&quot;</span>, post <span class="fu">^.</span> <span class="fu">#</span>calendar <span class="fu">^.</span> <span class="fu">#</span>title, <span class="st">&quot;](&quot;</span>, post <span class="fu">^.</span> <span class="fu">#</span>calendar <span class="fu">^.</span> <span class="fu">#</span>url, <span class="st">&quot;) &quot;</span>
    , post <span class="fu">^.</span> <span class="fu">#</span>date
    ]
  ]</code></pre></div>
<p>この関数の結果 <code>[Text]</code> を <code>unlines</code> してファイルに書き出せばよい． ちなみに，Haskell-jp のブログは，末尾に空白2つで改行となり，空行で HTML にも空行が入るようになっている．</p>
<h4 id="出力結果">出力結果</h4>
<p>は <a href="https://github.com/haskell-jp/blog/blob/02a2b1c68cd75a15d72eedd3148fc803c103a0b7/preprocessed-site/posts/2017/advent-calendar-2017.md#%E3%83%9D%E3%82%A8%E3%83%A0">Haskell-jp ブログのソースコード</a>(もちろん前半部分は手書き)を見ればいいと思うよ．</p>
<h2 id="おしまい">おしまい</h2>
<p>結局，<strong>全ての記事を集めてくるのに半日近くかかった(笑)</strong> 来年は投票機能とか，少しずつ集めたりとかできるといいよね．</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
