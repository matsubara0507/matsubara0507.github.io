<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="Re: ゼロから作る ADVENTAR の Slack Bot (Haskell 編)" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  
    <meta property="og:image" content="/assets/re-adventar-slack-bot/adventar-bot-0.jpg" />
  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        Re: ゼロから作る ADVENTAR の Slack Bot (Haskell 編)
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Re: ゼロから作る ADVENTAR の Slack Bot (Haskell 編)</h1>
    <p class="post-meta">
      <time datetime="2017-12-02" itemprop="datePublished">
        Dec 2, 2017
      </time>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>弊サークルはここ3年ほど <a href="https://adventar.org">ADVENTAR</a> というサービスを利用してアドベントカレンダーをやっている．</p>
<ul>
<li><a href="https://adventar.org/calendars/1572">群馬大学電子計算機研究会 IGGG Advent Calendar 2016 - ADVENTAR</a></li>
<li><a href="https://adventar.org/calendars/1137">群馬大学電子計算機研究会 IGGG Advent Calendar 2015 - ADVENTAR</a></li>
</ul>
<p><del>〇iita のアドベントカレンダーと違い，ADVENTAR は RSS 機能などが無いため，自前でそういったプログラムを書く必要があった．</del> ずーーーっと RSS 機能は無いと思ったけど，実はそんなことなかった(笑) URL の末尾に <code>.rss</code> と付ければ良いらしい． まぁ，細かい通知はできないみたい(？？)なので作った意味はない事もない？？</p>
<p>できないと思って作ってしまった記事はこちら．</p>
<ul>
<li><a href="https://iggg.github.io/2016/12/01/adventar-slack-bot">ADVENTAR の更新を通知する Slack BOT を作ってみた | 群馬大学電子計算機研究会 IGGG</a></li>
</ul>
<p>しかし…悲しいことに <strong>ADVENTAR のページの構成が変わり，以前の Bot では動かなくなってしまった</strong>… そこで，致し方ないので作り直すことにした(しょうがないなーもー♪)．</p>
<p>今回はその前編です(書いてたら長くなったので分けた)．</p>
<p><del>後編はコチラ．</del></p>
<h2 id="原因">原因</h2>
<p>で，原因はというと，コードをよく見ると <strong>React.js を使った</strong> ようになっていた点である．</p>
<div class="figure">
<img src="../assets/re-adventar-slack-bot/adventar-source.jpg" />

</div>
<p>つまり，静的な DOM が生成されない！ もともとは，その静的な DOM から Web Scraping して更新を確認していたのだ．</p>
<p>そうなってくると，解決方法はひとつしかない(ひとつかどうかは知らん)…そう最近流行り(要出典)の <strong>Headless Browser</strong> である． Headless Browser とは，ざっくり言うと，画面の無いブラウザである． これを使うと API を叩いてブラウザの動作を再現し，それによって動的に取得できる DOM をプログラム内で用いることが出来る． 動的に DOM を生成する場合にも Web Scraping をできるようになるし，もともとはブラウザアプリのテストに使われてたのかな？</p>
<p>ここまでくると，Google Apps Script では手に負えないので，<strong>Haskell で記述し，そのプログラム Dockerize し，CircleCI から実行するという荒業</strong> をすることにした． CircleCI なら cron できるようになったし(TravisCI もできるけど，個人的には CircleCI の config の方が書きやすい)．</p>
<p>(※ Haskell を使う理由は，完全に個人の趣味です)</p>
<h2 id="設計">設計</h2>
<ol style="list-style-type: decimal">
<li>Headless Browser を介して DOM を取得</li>
<li>DOM を Web Scraping</li>
<li>前の情報を書いておいた JSON ファイルを読み込む</li>
<li>ふたつを比較する</li>
<li>比較結果を Slack に通知</li>
<li>無事通知できてかつ差分があれば JSON を更新</li>
</ol>
<div class="figure">
<img src="../assets/re-adventar-slack-bot/bot-net.jpg" />

</div>
<p>ちなみに，特に意味は無いのだが，各手続きの関数を別々のファイルに書いた．</p>
<ul>
<li><a href="https://github.com/IGGG/adventar-bot/blob/dd6e5aa214a4a845a5ffc271be411bd7706f0748/src/Html.hs">Html.hs</a> : (1) の Headless Browser の関数</li>
<li><a href="https://github.com/IGGG/adventar-bot/blob/dd6e5aa214a4a845a5ffc271be411bd7706f0748/src/Scraper.hs">Scraper.hs</a> : (2) の Web Scraping する関数</li>
<li><a href="https://github.com/IGGG/adventar-bot/blob/dd6e5aa214a4a845a5ffc271be411bd7706f0748/src/Json.hs">Json.hs</a> : (3) の JSON ファイルの読み込みと (6) の更新をする関数</li>
<li><a href="https://github.com/IGGG/adventar-bot/blob/dd6e5aa214a4a845a5ffc271be411bd7706f0748/src/Entry.hs">Entry.hs</a> : (4) の比較をする関数(と全体の型定義)</li>
<li><a href="https://github.com/IGGG/adventar-bot/blob/dd6e5aa214a4a845a5ffc271be411bd7706f0748/src/Slack.hs">Slack.hs</a> : (5) の Slack に通知する関数</li>
</ul>
<p><a href="https://github.com/IGGG/adventar-bot/blob/dd6e5aa214a4a845a5ffc271be411bd7706f0748/src/Main.hs">Main.hs</a> は全体をくっつける部分と，差分をいい感じなメッセージに変える役割を担っている．</p>
<h2 id="作る">作る</h2>
<p>さぁ皆さんお待ちかねの Haskell のターンです！！</p>
<h3 id="scraper">Scraper</h3>
<ol style="list-style-type: decimal">
<li>の Headless Browser は後回しにして，まずは Scraper を定義する． 実際に Headless Browser は Haskell でうまく動くかよくわからなかったので，<code>chrome --headless</code> を使って取ってきた DOM をファイルにコピペして，それで試しながら先に Headless Browser 以外を実装していった．</li>
</ol>
<h4 id="ライブラリ">ライブラリ</h4>
<p>Haskell の Scraper ライブラリは意外とたくさんある． バイト先では <a href="https://hackage.haskell.org/package/hxt">HXT</a> というのを使っていたが，少し直感的でないし更新が最近無いので，人気そうな <a href="https://hackage.haskell.org/package/scalpel">scalpel</a> を使うことにした．</p>
<p>こいつの特徴は関数型パーサーのように Scraper を記述できる点である． 例えば，以下のような HTML から</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">'comments'</span><span class="kw">&gt;</span>
      <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">'comment container'</span><span class="kw">&gt;</span>
        <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">'comment author'</span><span class="kw">&gt;</span>Sally<span class="kw">&lt;/span&gt;</span>
        <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">'comment text'</span><span class="kw">&gt;</span>Woo hoo!<span class="kw">&lt;/div&gt;</span>
      <span class="kw">&lt;/div&gt;</span>
      <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">'comment container'</span><span class="kw">&gt;</span>
        <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">'comment author'</span><span class="kw">&gt;</span>Bill<span class="kw">&lt;/span&gt;</span>
        <span class="kw">&lt;img</span><span class="ot"> class=</span><span class="st">'comment image'</span><span class="ot"> src=</span><span class="st">'http://example.com/cat.gif'</span> <span class="kw">/&gt;</span>
      <span class="kw">&lt;/div&gt;</span>
      <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">'comment container'</span><span class="kw">&gt;</span>
        <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">'comment author'</span><span class="kw">&gt;</span>Susan<span class="kw">&lt;/span&gt;</span>
        <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">'comment text'</span><span class="kw">&gt;</span>WTF!?!<span class="kw">&lt;/div&gt;</span>
      <span class="kw">&lt;/div&gt;</span>
    <span class="kw">&lt;/div&gt;</span>
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre></div>
<p><code>class='comment'</code> の <code>div</code> 要素を次のような型の値として保持したいとする．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Author</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Comment</span>
    <span class="fu">=</span> <span class="dt">TextComment</span> <span class="dt">Author</span> <span class="dt">String</span>
    <span class="fu">|</span> <span class="dt">ImageComment</span> <span class="dt">Author</span> <span class="dt">URL</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre></div>
<p>(<code>type</code> 宣言はただの型エイリアスで，<code>data</code> 宣言は新しい型を定義してる)</p>
<p>そうすると，次のような Scraper を書くのだ．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allComments ::</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> [<span class="dt">Comment</span>])
allComments <span class="fu">=</span> scrapeURL <span class="st">&quot;http://example.com/article.html&quot;</span> comments
  <span class="kw">where</span>
<span class="ot">    comments ::</span> <span class="dt">Scraper</span> <span class="dt">String</span> [<span class="dt">Comment</span>]
    comments <span class="fu">=</span> chroots (<span class="st">&quot;div&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;container&quot;</span>]) comment

<span class="ot">    comment ::</span> <span class="dt">Scraper</span> <span class="dt">String</span> <span class="dt">Comment</span>
    comment <span class="fu">=</span> textComment <span class="fu">&lt;|&gt;</span> imageComment

<span class="ot">    textComment ::</span> <span class="dt">Scraper</span> <span class="dt">String</span> <span class="dt">Comment</span>
    textComment <span class="fu">=</span> <span class="kw">do</span>
      author      <span class="ot">&lt;-</span> text <span class="fu">$</span> <span class="st">&quot;span&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;author&quot;</span>]
      commentText <span class="ot">&lt;-</span> text <span class="fu">$</span> <span class="st">&quot;div&quot;</span>  <span class="fu">@:</span> [hasClass <span class="st">&quot;text&quot;</span>]
      return <span class="fu">$</span> <span class="dt">TextComment</span> author commentText

<span class="ot">    imageComment ::</span> <span class="dt">Scraper</span> <span class="dt">String</span> <span class="dt">Comment</span>
    imageComment <span class="fu">=</span> <span class="kw">do</span>
      author   <span class="ot">&lt;-</span> text       <span class="fu">$</span> <span class="st">&quot;span&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;author&quot;</span>]
      imageURL <span class="ot">&lt;-</span> attr <span class="st">&quot;src&quot;</span> <span class="fu">$</span> <span class="st">&quot;img&quot;</span>  <span class="fu">@:</span> [hasClass <span class="st">&quot;image&quot;</span>]
      return <span class="fu">$</span> <span class="dt">ImageComment</span> author imageURL</code></pre></div>
<p>Scraper 自身は <code>comments</code> という関数だ． <code>Scraper str a</code> という型は，なんかの文字列型(e.g. <code>String</code>, <code>Text</code>)を受け取り，<code>a</code> 型を返す Scraper というのを表している． <code>Scrape str</code> はモナドになっているため，関数型パーサーっぽく書けるのだ． ただし，関数型パーサーと違って，<code>bind</code> をつなげても入力を消費しない点に注意(例えば <code>textComment</code> 関数の1行目と2行目は同じ入力文字列に対して実行している)． Scraper を入れ子に適用するには <code>croot</code> 関数や <code>croots</code> 関数を用いるのだ(これ以上は割愛)．</p>
<h4 id="今回の型">今回の型</h4>
<p>で，今回は次のような DOM から</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;body&gt;</span>
    <span class="kw">&lt;table</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;tbody&gt;</span>
            <span class="kw">&lt;tr</span><span class="ot"> class=</span><span class="st">&quot;&quot;</span><span class="ot"> id=</span><span class="st">&quot;list-2017-12-01&quot;</span><span class="kw">&gt;</span>
                <span class="kw">&lt;th</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-date&quot;</span><span class="kw">&gt;</span>12/01<span class="kw">&lt;/th&gt;</span>
                <span class="kw">&lt;td</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-user&quot;</span><span class="kw">&gt;</span>
                    <span class="kw">&lt;a</span><span class="ot"> class=</span><span class="st">&quot;mod-userLink&quot;</span><span class="ot"> href=</span><span class="st">&quot;/users/11644&quot;</span><span class="kw">&gt;</span>
                        <span class="kw">&lt;img</span><span class="ot"> class=</span><span class="st">&quot;mod-userIcon&quot;</span><span class="ot"> src=</span><span class="st">&quot;http://pbs.twimg.com/profile_images/3164994798/6d931b645bef5a659f7f58562d094aaf_normal.png&quot;</span><span class="ot"> width=</span><span class="st">&quot;23&quot;</span><span class="ot"> height=</span><span class="st">&quot;23&quot;</span><span class="kw">&gt;</span>
                        <span class="kw">&lt;span&gt;</span>atpons<span class="kw">&lt;/span&gt;</span>
                    <span class="kw">&lt;/a&gt;</span>
                <span class="kw">&lt;/td&gt;</span>
                <span class="kw">&lt;td</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-body&quot;</span><span class="kw">&gt;</span>
                    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-comment&quot;</span><span class="kw">&gt;</span>まだコンピューティングルームにいるの？&lt;/div&gt;
                    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-title&quot;</span><span class="ot"> hidden=</span><span class="st">&quot;&quot;</span><span class="kw">&gt;&lt;/div&gt;</span>
                    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-url&quot;</span><span class="ot"> hidden=</span><span class="st">&quot;&quot;</span><span class="kw">&gt;</span>
                        <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;&quot;</span><span class="ot"> target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;&lt;/a&gt;</span>
                    <span class="kw">&lt;/div&gt;</span>
                <span class="kw">&lt;/td&gt;</span>
            <span class="kw">&lt;/tr&gt;</span>
            <span class="kw">&lt;tr</span><span class="ot"> class=</span><span class="st">&quot;&quot;</span><span class="ot"> id=</span><span class="st">&quot;list-2017-12-06&quot;</span><span class="kw">&gt;</span>
                <span class="kw">&lt;th</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-date&quot;</span><span class="kw">&gt;</span>12/06<span class="kw">&lt;/th&gt;</span>
                <span class="kw">&lt;td</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-user&quot;</span><span class="kw">&gt;</span>
                    <span class="kw">&lt;a</span><span class="ot"> class=</span><span class="st">&quot;mod-userLink&quot;</span><span class="ot"> href=</span><span class="st">&quot;/users/8528&quot;</span><span class="kw">&gt;</span>
                        <span class="kw">&lt;img</span><span class="ot"> class=</span><span class="st">&quot;mod-userIcon&quot;</span><span class="ot"> src=</span><span class="st">&quot;https://www.gravatar.com/avatar/6491e85d52916cfb063372cec9edb6cc?size=50</span><span class="dv">&amp;amp;</span><span class="st">d=mm&quot;</span><span class="ot"> width=</span><span class="st">&quot;23&quot;</span><span class="ot"> height=</span><span class="st">&quot;23&quot;</span><span class="kw">&gt;</span>
                        <span class="kw">&lt;span&gt;</span>ひげ<span class="kw">&lt;/span&gt;</span>
                    <span class="kw">&lt;/a&gt;</span>
                <span class="kw">&lt;/td&gt;</span>
                <span class="kw">&lt;td</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-body&quot;</span><span class="kw">&gt;</span>
                    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-comment&quot;</span><span class="kw">&gt;</span>ADVENTAR Slack Bot をパワーアップしたい<span class="kw">&lt;/div&gt;</span>
                    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-title&quot;</span><span class="kw">&gt;</span>ADVENTAR Slack Bot 2 using Haskell on Circle CI<span class="kw">&lt;/div&gt;</span>
                    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;mod-entryList-url&quot;</span><span class="kw">&gt;</span>
                        <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://matsubara0507.github.io&quot;</span><span class="ot"> target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>https://matsubara0507.github.io<span class="kw">&lt;/a&gt;</span>
                    <span class="kw">&lt;/div&gt;</span>
                <span class="kw">&lt;/td&gt;</span>
            <span class="kw">&lt;/tr&gt;</span>
        <span class="kw">&lt;/tbody&gt;</span>
    <span class="kw">&lt;/table&gt;</span>
<span class="kw">&lt;/body&gt;</span></code></pre></div>
<p>以下のようなデータ構造を Scraping する関数型パーサーを考える．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Calendar</span> <span class="fu">=</span> <span class="dt">HashMap</span> <span class="dt">Date</span> <span class="dt">Entry</span>
<span class="kw">type</span> <span class="dt">Date</span> <span class="fu">=</span> <span class="dt">Text</span>

<span class="kw">data</span> <span class="dt">Entry</span> <span class="fu">=</span> <span class="dt">Entry</span>
  {<span class="ot"> user    ::</span> <span class="dt">Text</span>
  ,<span class="ot"> comment ::</span> <span class="dt">Text</span>
  ,<span class="ot"> title   ::</span> <span class="dt">Text</span>
  ,<span class="ot"> url      ::</span> <span class="dt">Text</span>
  }</code></pre></div>
<p><code>HashMap k v</code> コンテナ型は，いわゆる連想配列型・辞書型のことである． 単一のエントリーの型 <code>Entry</code> には投稿者 <code>user</code> とコメント <code>comment</code> ，投稿した記事のタイトル <code>title</code> と URL <code>url</code> のフィールドがあるって感じである．</p>
<p>Haskell には標準で日付型が無いので，めんどくさいからタダの文字列型 <code>Text</code> として扱うことにした． なので日付 (e.g. “12/03”) では無く “ABC” をキーとしたエントリーを書いてもコンパイルエラーにはならないが，まぁいいや(そういうの出来なくもないけどね…)．</p>
<h4 id="scraper-関数の実装">Scraper 関数の実装</h4>
<p>まずはトップレベルの関数を定義</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">adventarScraper ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Calendar</span>
adventarScraper txt <span class="fu">=</span> HM.fromList <span class="fu">.</span> fromMaybe [] <span class="fu">.</span> scrapeStringLike txt <span class="fu">$</span>
  chroot (<span class="st">&quot;table&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-entryList&quot;</span>]) (chroots <span class="st">&quot;tr&quot;</span> scrapeEntryWithDate)

<span class="ot">scrapeEntryWithDate ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> (<span class="dt">Date</span>, <span class="dt">Entry</span>)
scrapeEntryWithDate <span class="fu">=</span> <span class="kw">do</span>
  date <span class="ot">&lt;-</span> scrapeDate
  entry <span class="ot">&lt;-</span> scrapeEntry
  return (date, entry)

<span class="ot">scrapeEntry ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Entry</span>
scrapeEntry <span class="fu">=</span> undefined

<span class="ot">scrapeDate ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Date</span>
scrapeDate <span class="fu">=</span> undefined</code></pre></div>
<p><code>&lt;table class=&quot;mod-entryList&quot;&gt;</code> の子要素の <code>tr</code> タグの中身を全て取ってきてほしいので <code>chroot</code> と <code>chroots</code> を使って連結してる． 日付とエントリのタプルのリストが取れれば，<code>HashMap.fromList</code> で日付をキーにしたエントリーの <code>HashMap</code> が作れる．</p>
<p>次にエントリーと日付を取ってきてみる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">scrapeEntry ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Entry</span>
scrapeEntry <span class="fu">=</span>
  user'    <span class="ot">&lt;-</span> scrapeUser
  comment' <span class="ot">&lt;-</span> scrapeComment
  title'   <span class="ot">&lt;-</span> scrapeTitle
  url'     <span class="ot">&lt;-</span> scrapeUrl
  return <span class="fu">$</span> <span class="dt">Entry</span> user' comment' title' url'

<span class="ot">scrapeDate ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Date</span>
scrapeDate <span class="fu">=</span> text (<span class="st">&quot;th&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-entryList-date&quot;</span>])

<span class="ot">scrapeUser ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Text</span>
scrapeUser <span class="fu">=</span> <span class="st">&quot;td&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-entryList-user&quot;</span>] <span class="ot">`chroot`</span> text <span class="st">&quot;span&quot;</span>

<span class="ot">scrapeComment ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Text</span>
scrapeComment <span class="fu">=</span> text (<span class="st">&quot;div&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-entryList-comment&quot;</span>])

<span class="ot">scrapeTitle ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Text</span>
scrapeTitle <span class="fu">=</span>
  text (<span class="st">&quot;div&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-entryList-title&quot;</span>, notHidden]) <span class="fu">&lt;|&gt;</span> pure <span class="st">&quot;&quot;</span>

<span class="ot">scrapeUrl ::</span> <span class="dt">Scraper</span> <span class="dt">Text</span> <span class="dt">Url</span>
scrapeUrl <span class="fu">=</span>
  text (<span class="st">&quot;div&quot;</span> <span class="fu">@:</span> [hasClass <span class="st">&quot;mod-entryList-url&quot;</span>, notHidden]) <span class="fu">&lt;|&gt;</span> pure <span class="st">&quot;&quot;</span>

<span class="ot">notHidden ::</span> <span class="dt">AttributePredicate</span>
notHidden <span class="fu">=</span> notP <span class="fu">$</span> <span class="st">&quot;hidden&quot;</span> <span class="fu">@=</span> <span class="st">&quot;&quot;</span></code></pre></div>
<p>基本的には何となく読めるだろう(正直，関数として小分けにする必要は無いが，分けておくと <code>ghci</code> とかでデバッグしやすいのだ)． ちなみに，<code>notHidden</code> は <code>hidden</code> 属性が付いていない場合に取得してくるという意味だ． 何故かというと，記事を先に登録しておくと，その日になるまで <code>hidden</code> でブラウザでは見れないだけで，DOM には書いてあるためだ． 記事を先に登録して置いたら，通知で見えてしまっては嫌でしょ？(笑)</p>
<h3 id="json">JSON</h3>
<p>Haskell で JSON を扱うのは簡単． aeson というライブラリが，ほぼほぼデファクトスタンダードとなっている． aeson は任意の型を <code>FromJSON</code> 型クラスや <code>ToJSON</code> 型クラスのインスタンスにしてあげるだけで，デコーダーとエンコーダーを実装してくれる． しかも，Generics という機能を使えば，一行で終わる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Entry</span> <span class="fu">=</span> <span class="dt">Entry</span>
  {<span class="ot"> user    ::</span> <span class="dt">Text</span>
  ,<span class="ot"> comment ::</span> <span class="dt">Text</span>
  ,<span class="ot"> title   ::</span> <span class="dt">Text</span>
  ,<span class="ot"> url     ::</span> <span class="dt">Url</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Entry</span>
<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Entry</span></code></pre></div>
<p>わぁすごい(<code>HashMap</code> 型は既にインスタンスの定義がされてる)．</p>
<p>問題は文字コードで，今回は日本語(マルチバイト文字)を含むので，次のように JSON ファイルの読み込みと書き込みを定義してあげる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Data.Aeson</span>               (decode)
<span class="kw">import           </span><span class="dt">Data.Aeson.Encode.Pretty</span> (encodePrettyToTextBuilder)
<span class="kw">import           </span><span class="dt">Data.Text</span>                (<span class="dt">Text</span>, unpack)
<span class="kw">import           </span><span class="dt">Data.Text.Lazy.Builder</span>   (toLazyText)
<span class="kw">import           </span><span class="dt">Data.Text.Lazy.Encoding</span>  (encodeUtf8)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span>        <span class="kw">as</span> <span class="dt">LT</span>

<span class="ot">readEntryJson ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Calendar</span>
readEntryJson jsonPath <span class="fu">=</span>
  fromMaybe emptyCalender <span class="fu">.</span> decode <span class="fu">.</span> encodeUtf8 <span class="fu">&lt;$&gt;</span> <span class="dt">LT</span><span class="fu">.</span>readFile (unpack jsonPath)

<span class="ot">updateEntryJson ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Calendar</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
updateEntryJson jsonPath newCal <span class="fu">=</span>
  <span class="dt">LT</span><span class="fu">.</span>writeFile (unpack jsonPath) <span class="fu">.</span> toLazyText <span class="fu">$</span> encodePrettyToTextBuilder newCal</code></pre></div>
<p>Haskell の文字コードは難しくて，<code>String</code>, <code>ByteString</code>, <code>Lazy.ByteString</code>, <code>Text</code>, <code>Lazy.Text</code> の5種類ある(たしか)． 遅延文字列(<code>Lazy</code>)は大きなファイルの取り扱いに使われ，効率良くマルチバイト文字を扱うには <code>Text</code> 型を使う． そのため，今回は <code>Lazy.Text</code> 型を主軸に使っているのだ(e.g. <code>decodeUtf8</code>, <code>encodePrettyToTextBuilder</code>)．</p>
<p>このあたり結構苦労した….</p>
<h3 id="slack-bot">Slack Bot</h3>
<p>Haskell で Slack Bot の API を使うには，今のところ <a href="https://hackage.haskell.org/package/slack-api">slack-api</a> ライブラリが最適だろう． <a href="https://hackage.haskell.org/package/slack-web">slack-web</a> というライブラリもあり，こっちの方が他の API 系ライブラリに近い印象だが，うまく動かなかった….</p>
<p>slack-api ライブラリは何故か <a href="https://www.stackage.org">Stackage</a> の LTS に無いため，stack.yaml に書き加える必要がある．</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">resolver:</span><span class="at"> lts-9.12</span>
<span class="fu">packages:</span>
  <span class="kw">-</span> .
<span class="fu">extra-deps:</span>
  <span class="kw">-</span> slack-api-0.12   <span class="co"># here</span></code></pre></div>
<p>slack-api ライブラリは基本的に RTM API について書かれているのだが，Web API の方も申し訳程度に<a href="https://hackage.haskell.org/package/slack-api-0.12/docs/Web-Slack-WebAPI.html">実装されている</a>(e.g. <code>chat_postMessage</code>)</p>
<p><a href="https://github.com/mpickering/slack-api/blob/master/src/Web/Slack/WebAPI.hs">GitHub の方</a>を見ると，もっとイロンナ API が実装されているので，v0.12 の API では足りない場合は GitHub から直接取ってくるように stack.yaml を書き換えると良いだろう．</p>
<p>さて，では Slack にポストする関数を実装する． 以下のような感じ． 凄い簡単．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Token</span> <span class="fu">=</span> <span class="dt">Text</span>
<span class="kw">type</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Text</span>
<span class="kw">type</span> <span class="dt">ChannelName</span> <span class="fu">=</span> <span class="dt">Text</span>

<span class="ot">postMessage ::</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">ChannelName</span> <span class="ot">-&gt;</span> <span class="dt">Message</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Text</span> ())
postMessage token cname message <span class="fu">=</span> runExceptT <span class="fu">$</span>
  chat_postMessage (<span class="dt">SlackConfig</span> <span class="fu">$</span> unpack token) (<span class="dt">Id</span> cname) message []</code></pre></div>
<p>読みやすいように型エイリアスを多用している． 返り値型の <code>Either Text ()</code> 型は「ポストに失敗したときに <code>Left Text</code> 型のエラーメッセージが返ってくるよ」って意味である．</p>
<h3 id="headless-browser">Headless Browser</h3>
<p>さぁお待ちかね Headless Browser を Haskell で扱うよー(ﾄﾞﾝﾄﾞﾝﾊﾟﾌﾊﾟﾌ)．</p>
<p>イロイロ調べた結果，<a href="https://hackage.haskell.org/package/webdriver">webdriver</a> というライブラリが使いやすそうだった． そこにあった<a href="https://github.com/kallisti-dev/hs-webdriver/blob/e442b05569a6e0fb244b0fab95c08eb87f11126e/examples/readme-example-beginner.md#hello-world">サンプル</a>はこんな感じ．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runSession firefoxConfig <span class="fu">$</span> <span class="kw">do</span>
  openPage <span class="st">&quot;http://google.com&quot;</span>
  searchInput <span class="ot">&lt;-</span> findElem ( <span class="dt">ByCSS</span> <span class="st">&quot;input[type='text']&quot;</span> )
  sendKeys <span class="st">&quot;Hello, World!&quot;</span> searchInput
  submit searchInput
  closeSession

firefoxConfig <span class="fu">=</span> useBrowser firefox defaultConfig</code></pre></div>
<p>直感的に読める通りだ． 全体では，“Hello, World!” をグーグル検索してるだけ(検索結果は取得してない気がするけど(笑))．</p>
<p>今回は，ただ単にページを開いて，ソースコードを取得したいだけだから，以下のような関数を書いた．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fetchHtml ::</span> <span class="dt">Url</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
fetchHtml url <span class="fu">=</span> runSession config <span class="fu">$</span> <span class="kw">do</span>
  openPage (unpack url)
  getSource
  <span class="kw">where</span>
    config <span class="fu">=</span> useBrowser chrome defaultConfig</code></pre></div>
<p><code>getSource</code> で現在表示中のページのソースコードを返してれる． 簡単だ．</p>
<h3 id="組み合わせる">組み合わせる</h3>
<p>さぁいよいよ最終段階． 今まで定義した関数を組み合わせる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  setLocaleEncoding utf8
  [htmlUrl, jsonPath, channel, token] <span class="ot">&lt;-</span> fmap pack <span class="fu">&lt;$&gt;</span> getArgs
  oldCal <span class="ot">&lt;-</span> readEntryJson jsonPath
  newCal <span class="ot">&lt;-</span> adventarScraper <span class="fu">&lt;$&gt;</span> fetchHtml htmlUrl
  <span class="kw">let</span> message <span class="fu">=</span> mkMessage oldCal newCal
  result <span class="ot">&lt;-</span> postMessage token channel (pack <span class="fu">$</span> either id id message)
  <span class="kw">case</span> result <span class="kw">of</span>
    <span class="dt">Right</span> _ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Success!&quot;</span>
    <span class="dt">Left</span>  e <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Error: &quot;</span> <span class="ot">`mappend`</span> unpack e

  when (isRight message <span class="fu">&amp;&amp;</span> isRight result) <span class="fu">$</span>
    updateEntryJson jsonPath newCal


<span class="ot">mkMessage ::</span> <span class="dt">Calendar</span> <span class="ot">-&gt;</span> <span class="dt">Calendar</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">String</span>
mkMessage <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p><code>mkMessage</code> は取得したエントリーの情報と前のを比較して，いい感じのメッセージを返してくれる関数(めんどいので割愛)． 差分が無かった時には <code>Left &quot;No Update...&quot;</code> を返す． なので，<code>when (isRight message &amp;&amp; isRight result) $ ...</code> で差分があったときだけ，JSON ファイルを書き換えている．</p>
<h4 id="vs-文字コード">vs 文字コード</h4>
<p>実は手元(Windows)でビルドしてるときは問題なかったのだが，Ubuntu 上で Dockerize し，selenium の Docker イメージと docker-compose した時に，文字コードで怒られた…</p>
<pre><code>commitBuffer: invalid argument (invalid character)</code></pre>
<p><a href="https://www.reddit.com/r/haskell/comments/43tmt8/commitbuffer_invalid_argument_invalid_character">イロイロ調べた結果</a>，<code>setLocaleEncoding utf8</code> を <code>main</code> の最初に書き加えたら動作した． 日本語を扱うのは大変だぁ．</p>
<h2 id="実行する">実行する</h2>
<p>selenium は <a href="https://github.com/kallisti-dev/hs-webdriver/blob/master/README.md#using-the-selenium-server">webdriver の READMEに書いてある通り</a> Java のモノをインストールして実行した(別のターミナルで)． なんのドライバーも持ってなかったので，<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">chrome の webdriver</a> をダウンロードして，パスの通ってるとこに置いた．</p>
<p>で，あとは <code>stack exec -- adventar-bot &quot;https://adventar.org/calendars/2300&quot; &quot;./hoge/entry.json&quot; &quot;bot-test&quot; &quot;XXXXX&quot;</code> とするだけ．</p>
<div class="figure">
<img src="../assets/re-adventar-slack-bot/adventar-bot-0.jpg" />

</div>
<p>いい感じ</p>
<h2 id="おしまい">おしまい</h2>
<p>次回は，これを定期実行(cron)するために CircleCI で実行する！</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
