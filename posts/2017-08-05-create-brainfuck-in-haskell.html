<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="Haskell で書く Brainf*ck 処理系" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        Haskell で書く Brainf*ck 処理系
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell で書く Brainf*ck 処理系</h1>
    <p class="post-meta">
      <time datetime="2017-08-05" itemprop="datePublished">
        Aug 5, 2017
      </time>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>何番煎じだよって感じのネタですが，久々に Brainf*ck のコードを見かけたので，久々に書いてみたくなりました．</p>
<h2 id="いきさつ">いきさつ</h2>
<p>先日，<a href="https://builderscon.io/tokyo/2017">builderscon in tokyo 2017</a> というイベントに行ってきた． そこのフリードリンクコーナーにこんな紙コップが…</p>
<p><img src="../assets/create-brainfuck-in-haskell/braincup.jpg" /></p>
<p>一流のプログラマであれば，Brainf*ck 程度の単純な処理系ぐらい目実行しろってことだろうが，ボクは3流程度のプログラマなので，<a href="http://e-words.jp/p/r-ascii.html">ASCIIコード表</a>が片手にないと実行できなかった…orz</p>
<p>まぁ内容はわかったのだが，せっかくだから久々にサクッと書いてみようと思ったわけです．</p>
<h2 id="brainfck">Brainf*ck</h2>
<p>Brainf*ck の処理系は，コードの見た目こそ気持ち悪いが非常に単純．</p>
<ul>
<li>コードは8文字 <code>&gt;&lt;+-.,[]</code> だけで構成される(それ以外は無視)</li>
<li>コードを頭から一文字ずつ読んで実行していく</li>
<li>一本の無限に長いテープ(メモリ)を考える</li>
<li>テープは全て <code>0</code> で初期化されてる</li>
<li>プログラムはテープの数値の変更や読み取りができる</li>
</ul>
<p>といった感じ． 具体的には以下の通り(<a href="https://ja.wikipedia.org/wiki/Brainfuck">Wikipedia</a>より)．</p>
<ol type="1">
<li><code>&gt;</code> ポインタをインクリメント，ポインタを <code>ptr</code> とすると，C言語の <code>ptr++</code> に相当</li>
<li><code>&lt;</code> ポインタをデクリメント，C言語の <code>ptr--</code> に相当</li>
<li><code>+</code> ポインタが指す値をインクリメント，C言語の <code>(*ptr)++</code> に相当</li>
<li><code>-</code> ポインタが指す値をデクリメント，C言語の <code>(*ptr)--</code> に相当</li>
<li><code>.</code> ポインタが指す値を出力に書き出す，C言語の <code>putchar(*ptr)</code> に相当</li>
<li><code>,</code> 入力から1バイト読み込んでポインタが指す先に代入，C言語の <code>*ptr=getchar()</code> に相当</li>
<li><code>[</code> ポインタが指す値が0なら対応する <code>]</code> の直後にジャンプ，C言語の <code>while(*ptr){</code> に相当</li>
<li><code>]</code> ポインタが指す値が0でないなら対応する <code>[</code> にジャンプ，C言語の <code>}</code> に相当</li>
</ol>
<h2 id="作る">作る</h2>
<p>最終的なコードは<a href="https://gist.github.com/matsubara0507/d855acd68a7fd54005b7f04b104cd8e6#file-brainfuck-hs">ココ</a>にある．</p>
<h3 id="実行機の型を考える">実行機の型を考える</h3>
<p>関数型プログラミングは，まず型から考える(自論)．</p>
<p>前述したとおり，Brainf*ck の実行機は，プログラム列と無限に長いテープ(メモリ)があればよい． 組込みのリスト(単方向リスト)でも良いが，テープの上を前後(か左右)に移動するので双方向リストの方が良いだろう．</p>
<p>Haskell で双方向リストを実装するやり方はいろいろあるが，今回は便宜上以下のようにする．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tape</span> a <span class="fu">=</span> <span class="dt">Tape</span> {<span class="ot"> front ::</span> [a]
                   ,<span class="ot"> current ::</span> a
                   ,<span class="ot"> back ::</span> [a]
                   } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">mapCrr ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Tape</span> a <span class="ot">-&gt;</span> <span class="dt">Tape</span> a
mapCrr f tape <span class="fu">=</span> tape { current <span class="fu">=</span> f (current tape) }

<span class="ot">moveFront ::</span> <span class="dt">Tape</span> a <span class="ot">-&gt;</span> <span class="dt">Tape</span> a
moveFront (<span class="dt">Tape</span> [] _ _) <span class="fu">=</span> error <span class="st">&quot;front is empty.&quot;</span>
moveFront (<span class="dt">Tape</span> f c b) <span class="fu">=</span> <span class="dt">Tape</span> (tail f) (head f) (c <span class="fu">:</span> b)

<span class="ot">moveBack ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tape</span> a <span class="ot">-&gt;</span> <span class="dt">Tape</span> a
moveBack a (<span class="dt">Tape</span> f c []) <span class="fu">=</span> <span class="dt">Tape</span> (c <span class="fu">:</span> f) a []
moveBack _ (<span class="dt">Tape</span> f c b) <span class="fu">=</span> <span class="dt">Tape</span> (c <span class="fu">:</span> f) (head b) (tail b)</code></pre></div>
<p>用意した関数は以下の3つだけ(これだけで十分だから)．</p>
<ul>
<li><code>mapCrr</code> は現在の値にのみ，第一引数の関数 <code>f</code> を適用する</li>
<li><code>moveFront</code> はテープのヘッダを前進させる</li>
<li><code>moveBack</code> はテープのヘッダを後進させる
<ul>
<li>ただし，後ろへ無限に長いとするので，初期化値 <code>a</code> を引数で与えている</li>
</ul></li>
</ul>
<p>テープには数値を印字しているので，テープ(メモリ)の型は <code>Tape Int</code> でいいでしょう．</p>
<h2 id="section"></h2>
<p>あと必要なのはプログラムの型． プログラムも前から順に読んでいき，<code>[]</code> で前後にジャンプする． つまり，<code>Tape a</code> 型をそのまま使えそうだ． <code>Tape Char</code> でも良いが，終端文字が欲しいので(冗長だが) <code>Tape (Maybe Char)</code> とする．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Program</span> <span class="fu">=</span> <span class="dt">Tape</span> (<span class="dt">Maybe</span> <span class="dt">Char</span>)</code></pre></div>
<p>結果として実行機の型は以下のようになる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Machine</span> <span class="fu">=</span> <span class="dt">Machine</span> {<span class="ot"> programOf ::</span> <span class="dt">Program</span>
                       ,<span class="ot"> memOf ::</span> <span class="dt">Tape</span> <span class="dt">Int</span>
                       } <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<h3 id="初期化関数">初期化関数</h3>
<p>テストするために，<code>String -&gt; Machine</code> の初期化関数を先に作っておく．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">initMachine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span>
initMachine <span class="fu">=</span> initMachine' <span class="fu">.</span> flip mappend [fin] <span class="fu">.</span> fmap <span class="dt">Just</span>
  <span class="kw">where</span>
    initMachine' s <span class="fu">=</span> <span class="dt">Machine</span> (<span class="dt">Tape</span> [] (head s) (tail s)) (<span class="dt">Tape</span> [] <span class="dv">0</span> [])

<span class="ot">fin ::</span> <span class="dt">Maybe</span> <span class="dt">Char</span>
fin <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p><code>flip mappend [fin] . fmap Just</code> は，<code>Char</code> 型の値を <code>Just</code> にラップし，空文字 <code>&quot;&quot;</code> 対策として終端文字を末尾に足している．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> prog <span class="fu">=</span> <span class="st">&quot;+[-]&quot;</span>
<span class="fu">&gt;</span> initMachine prog
<span class="dt">Machine</span> {programOf <span class="fu">=</span> <span class="dt">Tape</span> {front <span class="fu">=</span> [], current <span class="fu">=</span> <span class="dt">Just</span> <span class="ch">'+'</span>, back <span class="fu">=</span> [<span class="dt">Just</span> <span class="ch">'['</span>,<span class="dt">Just</span> <span class="ch">'-'</span>,<span class="dt">Just</span> <span class="ch">']'</span>,<span class="dt">Nothing</span>]}, memOf <span class="fu">=</span> <span class="dt">Tape</span> {front <span class="fu">=</span> [], current <span class="fu">=</span> <span class="dv">0</span>, back <span class="fu">=</span> []}}</code></pre></div>
<h3 id="実行する関数">実行する関数</h3>
<p>基本の動作は</p>
<ol type="1">
<li>一文字分を読み込んで</li>
<li>対応する処理をし</li>
<li>次の文字へ移動</li>
</ol>
<p>を終端文字(<code>Nothing</code>)まで繰り返す．</p>
<p>2 の部分に IO が含まれる可能性があるので，1-3 の処理は <code>Machine -&gt; IO Machine</code> となる． 特別意味はないがループ部分と処理部分を分けてみた．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">Machine</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Machine</span>
run <span class="fu">=</span> loopM run' ((<span class="fu">/=</span>) fin <span class="fu">.</span> current <span class="fu">.</span> programOf)

<span class="ot">loopM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m a
loopM f p a <span class="fu">=</span> <span class="kw">if</span> p a <span class="kw">then</span> f a <span class="fu">&gt;&gt;=</span> loopM f p <span class="kw">else</span> return a

<span class="ot">run' ::</span> <span class="dt">Machine</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Machine</span>
run' <span class="fu">=</span> undefined</code></pre></div>
<p><code>(/=) fin . current . programOf</code> の部分は <code>Machine</code> 型の値から現在見てるコードの文字が終端文字(<code>Nothing</code>)かどうかを判定している． <code>loopM f p a</code> は <code>p a</code> が <code>False</code> になるまで，<code>f a</code> を繰り返し適用している．</p>
<h3 id="処理部分">処理部分</h3>
<p>あとは処理部分を分岐して書くだけ．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span> (chr, ord)

<span class="ot">run' ::</span> <span class="dt">Machine</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Machine</span>
run' m<span class="fu">@</span>(<span class="dt">Machine</span> prog mem) <span class="fu">=</span>
  (\m' <span class="ot">-&gt;</span> m' { programOf <span class="fu">=</span> moveBack' <span class="fu">$</span> programOf m' }) <span class="fu">&lt;$&gt;</span> cond (current prog)
  <span class="kw">where</span>
    cond (<span class="dt">Just</span> <span class="ch">'&gt;'</span>) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Machine</span> prog (moveBack <span class="dv">0</span> mem)
    cond (<span class="dt">Just</span> <span class="ch">'&lt;'</span>) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Machine</span> prog (moveFront mem)
    cond (<span class="dt">Just</span> <span class="ch">'+'</span>) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Machine</span> prog (mapCrr (<span class="fu">+</span> <span class="dv">1</span>) mem)
    cond (<span class="dt">Just</span> <span class="ch">'-'</span>) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Machine</span> prog (mapCrr (<span class="fu">+</span> (<span class="fu">-</span><span class="dv">1</span>)) mem)
    cond (<span class="dt">Just</span> <span class="ch">'.'</span>) <span class="fu">=</span> return m <span class="fu">&lt;*</span> putChar (chr <span class="fu">$</span> current mem)
    cond (<span class="dt">Just</span> <span class="ch">','</span>) <span class="fu">=</span>
      (\c <span class="ot">-&gt;</span> <span class="dt">Machine</span> prog (mapCrr (const <span class="fu">$</span> ord c) mem)) <span class="fu">&lt;$&gt;</span> getChar
    cond (<span class="dt">Just</span> <span class="ch">'['</span>) <span class="fu">=</span> return <span class="fu">.</span> flip <span class="dt">Machine</span> mem <span class="fu">$</span>
      (<span class="kw">if</span> current mem <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> jump (<span class="ch">'['</span>, <span class="ch">']'</span>) moveBack' <span class="kw">else</span> id) prog
    cond (<span class="dt">Just</span> <span class="ch">']'</span>) <span class="fu">=</span> return <span class="fu">.</span> flip <span class="dt">Machine</span> mem <span class="fu">$</span>
      (<span class="kw">if</span> current mem <span class="fu">/=</span> <span class="dv">0</span> <span class="kw">then</span> jump (<span class="ch">']'</span>, <span class="ch">'['</span>) moveFront <span class="kw">else</span> id) prog
    cond _   <span class="fu">=</span> return m
    moveBack' <span class="fu">=</span> moveBack fin

<span class="ot">jump ::</span> (<span class="dt">Char</span>, <span class="dt">Char</span>) <span class="ot">-&gt;</span> (<span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">Program</span>) <span class="ot">-&gt;</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">Program</span>
jump (a, b) f <span class="fu">=</span> go <span class="dv">1</span>
  <span class="kw">where</span>
    go <span class="dv">0</span> prog <span class="fu">=</span> prog
    go n prog <span class="fu">=</span> go (updateCounter (p a) (p b) (current <span class="fu">$</span> f prog) n) (f prog)
    p x <span class="fu">=</span> (<span class="fu">==</span>) (<span class="dt">Just</span> x)

<span class="ot">updateCounter ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
updateCounter p q a <span class="fu">=</span> (<span class="fu">+</span>) (<span class="kw">if</span> p a <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="kw">if</span> q a <span class="kw">then</span> <span class="fu">-</span><span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</code></pre></div>
<p><code>\m' -&gt; m' { programOf = moveBack' $ programOf m' }</code> が「3. 次の文字へ移動」にあたり，<code>cond (current prog)</code> が「1. 一文字分を読み込んで」にあたる．</p>
<p><code>cond</code> 補助関数が 2. にあたる． <code>[</code> (ないしは <code>]</code>)の移動は <code>jump</code> 関数を利用して，単純に一個ずつ前(ないしは後ろ)に移動し，対応する <code>]</code> (ないしは <code>[</code>)を探している(<strong>そのため，対応していないと止まらない</strong>)． 対応してるかどうかは <code>go n</code> の <code>n</code> をカウンターとして保持している． <code>updateCounter</code> 関数は，そのカウンターを更新するための関数である．</p>
<h3 id="main-関数">Main 関数</h3>
<p>別に要らないけど</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  [filepath] <span class="ot">&lt;-</span> getArgs
  prog <span class="ot">&lt;-</span> readFile filepath
  _ <span class="ot">&lt;-</span> run <span class="fu">$</span> initMachine prog
  putStrLn <span class="st">&quot;&quot;</span></code></pre></div>
<h2 id="実行">実行</h2>
<p>試しに，<a href="https://ja.wikipedia.org/wiki/Hello_world%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E4%B8%80%E8%A6%A7#Brainfuck">Wikipedia にある HelloWorld プログラム</a>を実行してみる．</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">cat</span> hw.bf
<span class="ex">+++++++++</span>[<span class="op">&gt;</span>++++++++<span class="op">&gt;</span>+++++++++++<span class="op">&gt;</span>+++++<span class="op">&lt;&lt;&lt;</span>-]<span class="op">&gt;</span>.<span class="op">&gt;</span>++.+++++++..+++.<span class="op">&gt;</span>-.
<span class="ex">------------.</span><span class="op">&lt;</span>++++++++.--------.+++.------.--------.<span class="op">&gt;</span>+.
$ <span class="ex">stack</span> runghc brainfuck.hs hw.bf
<span class="ex">Hello</span>, world!</code></pre></div>
<p>紙コップのやつは，まぁ，自分でやってみて．</p>
<h2 id="おしまい">おしまい</h2>
<p>もっとコンパクトに書こうと思えば書けるけど，なんか綺麗なので満足． <a href="https://gist.github.com/matsubara0507/d855acd68a7fd54005b7f04b104cd8e6#file-_brainfuck-hs">2,3年前に書いたモノ</a>と比べると，成長した気がする(笑)</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
