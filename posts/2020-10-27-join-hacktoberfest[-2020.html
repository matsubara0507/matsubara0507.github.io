<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="Hacktoberfest 2020 なので PR を4つ出してみた" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  
    <meta property="og:image" content="/assets/join-hacktoberfest-2020/status.jpg" />
  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        Hacktoberfest 2020 なので PR を4つ出してみた
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Hacktoberfest 2020 なので PR を4つ出してみた</h1>
    <p class="post-meta">
      <time datetime="2020-10-27" itemprop="datePublished">
        Oct 27, 2020
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="../tags/event.html">event</a> <a href="../tags/Haskell.html">Haskell</a> <a href="../tags/Egison.html">Egison</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Hacktoberfest 2020 がきたので今年もPRを出してきました．</p>
<p><img src="../assets/join-hacktoberfest-2020/status.jpg" /></p>
<h2 id="hacktoberfest-2020">Hacktoberfest 2020</h2>
<p>例年と異なり，PR のカウントの仕方が（途中から）変わった． もともとは Public なリポジトリに対する PR ならなんでもよかったが，途中から次のいずれかのみカウントされるようになった：</p>
<ul>
<li><code>hacktoberfest</code> topic のついた Public リポジトリに対する PR で，Approve か Merge されたもの</li>
<li>Public リポジトリの PR で <code>hacktoberfest-accepted</code> ラベルがついたもの</li>
</ul>
<p>普段使っているパッケージのリポジトリなどには軒並み <code>hacktoberfest</code> topic がついていなかったので，ついてるリポジトリを1つ選んで献上しようかなと考えた． <code>hacktoberfest</code> topic と Haskell で検索したところ，昔から興味のあった Egison 言語にも <code>hacktoberfest</code> topic がついていたので，これにコミットすることにした．</p>
<h3 id="egison">Egison</h3>
<p><a href="https://github.com/egison/egison">Egison</a> はパターンマッチ指向プログラミング言語というもので，他のプログラミング言語とは比べ物にならないほど強力なパターンマッチ機能を持っている：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- 素数の無限リストから全ての双子素数をパターンマッチにより抽出</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>def twinPrimes <span class="op">:=</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  matchAll primes as list integer with</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="op">|</span> _ <span class="op">++</span> <span class="op">$</span><span class="ot">p ::</span> <span class="op">#</span>(p <span class="op">+</span> <span class="dv">2</span>)<span class="ot"> ::</span> _ <span class="ot">-&gt;</span> (p, p <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">-- 最初の5個の双子素数を列挙</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="fu">take</span> <span class="dv">5</span> twinPrimes</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="co">-- =&gt; [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31)]</span></span></code></pre></div>
<p>これは <a href="https://www.egison.org">Egison の公式サイト</a>に載っている例だ． 素数の無限リスト <code>primes</code> 自体は標準パッケージに（なぜか）入っているものだ． 双子素数は差が 2 しかない素数の組である．</p>
<p>最近だと数式処理などにも力を入れているようだ．</p>
<h3 id="出した-pr">出した PR</h3>
<ol type="1">
<li><a href="https://github.com/egison/egison/pull/255">コマンドオプションのテスト</a></li>
<li><a href="https://github.com/egison/egison/pull/258">ドキュメントの修正（<code>def</code> キーワードの追加）</a></li>
<li><a href="https://github.com/egison/egison/pull/260">中置関数の導入</a></li>
<li><a href="https://github.com/egison/egison/pull/261">テストの個別実行を可能にする</a></li>
</ol>
<h2 id="コマンドオプションのテスト">1. コマンドオプションのテスト</h2>
<p>これは <code>good first issue</code> としてすでにあったやつだ．</p>
<p><a href="https://github.com/egison/egison/issues/244"><img src="../assets/join-hacktoberfest-2020/test-cli-opts-issue.jpg" /></a></p>
<p>どうしようかなと考えた結果 <a href="http://hackage.haskell.org/package/process-1.6.10.0/docs/System-Process.html#v:readProcess"><code>readProcess</code></a> を使うことにした． <code>stack exec -- egison</code> をこの関数で実行して，その出力が意図通りかをテストする：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework</span>                 (defaultMain)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework.Providers.HUnit</span> (hUnitTestToTests)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.HUnit</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">System.Process</span>                 (readProcess)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>main <span class="ot">=</span> defaultMain <span class="op">.</span> hUnitTestToTests <span class="op">.</span> test <span class="op">$</span> <span class="dt">TestList</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    [ <span class="dt">TestLabel</span> <span class="st">&quot;eval option&quot;</span> <span class="op">.</span> <span class="dt">TestCase</span> <span class="op">$</span> assertEgisonCmd</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>        <span class="st">&quot;[[], [1], [1, 2], [1, 2, 3]]\n&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        [<span class="st">&quot;--eval&quot;</span>, <span class="st">&quot;matchAll [1,2,3] as list something with $x ++ _ -&gt; x&quot;</span>]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>        <span class="st">&quot;&quot;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    ]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>assertEgisonCmd</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="ot">  ::</span> <span class="dt">String</span>   <span class="co">-- The expected value</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>  <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="co">-- any arguments for egison command</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>   <span class="co">-- standard input for egison command</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">Assertion</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>assertEgisonCmd expected args input <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>  actual <span class="ot">&lt;-</span> readProcess <span class="st">&quot;stack&quot;</span> (<span class="st">&quot;exec&quot;</span> <span class="op">:</span> <span class="st">&quot;--&quot;</span> <span class="op">:</span> <span class="st">&quot;egison&quot;</span> <span class="op">:</span> args) input</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>  assertEqual <span class="st">&quot;&quot;</span> expected actual</span></code></pre></div>
<p>こういうことをやってくれるライブラリもあるかもしれないが，あまり依存パッケージを増やすのも嫌だったので既に使われてるパッケージで実現できる方法にした． ちなみに，<code>egison</code> コマンドは <code>--eval</code> オプションなどを使わない場合はREPLが起動する：</p>
<pre><code>$ stack exec -- egison
Egison Version 4.1.1
https://www.egison.org
Welcome to Egison Interpreter!
&gt; 1 + 1
2
&gt;
Leaving Egison Interpreter.</code></pre>
<p><code>readProcess</code> は標準入力も与えることができるので，これを使ってREPLを介したテストも可能だ：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Version</span>    (showVersion)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Language.Egison</span> (version)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="op">...</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    [ <span class="dt">TestLabel</span> <span class="st">&quot;load-file option&quot;</span> <span class="op">.</span> <span class="dt">TestCase</span> <span class="op">$</span> assertEgisonCmd</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        (interpreter <span class="st">&quot;1\n&quot;</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        [<span class="st">&quot;--load-file&quot;</span>, <span class="st">&quot;test/fixture/a.egi&quot;</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="st">&quot;x&quot;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    ]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="ot">interpreter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>interpreter output <span class="ot">=</span> <span class="fu">concat</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  [ <span class="st">&quot;Egison Version &quot;</span>, showVersion version, <span class="st">&quot;\n&quot;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  , <span class="st">&quot;https://www.egison.org\n&quot;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>  , <span class="st">&quot;Welcome to Egison Interpreter!\n&quot;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>  , <span class="st">&quot;&gt; &quot;</span>, output</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>  , <span class="st">&quot;&gt; Leaving Egison Interpreter.\n&quot;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  ]</span></code></pre></div>
<h2 id="ドキュメントの修正def-キーワードの追加">2. ドキュメントの修正（<code>def</code> キーワードの追加）</h2>
<p>コマンドオプションのテストケースは <a href="https://egison.readthedocs.io/en/latest/reference/command-line-options.html">Issue にあったドキュメント</a>を参考に実装した． そのドキュメントの通りに実装したらコンパイルエラーになった：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec -- egison -l test/fixture/name-of-file-to-load.egi</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ex">Parse</span> error at: egison:1:3:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="kw">|</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">x</span> := 1</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  <span class="kw">|</span>   ^</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="ex">unexpected</span> <span class="st">':'</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ex">expecting</span> <span class="st">&quot;...&quot;</span>, <span class="st">&quot;where&quot;</span>, atomic expression, end of input, index, or infix</span></code></pre></div>
<p>これは，Egison のバージョン4.1.0から変わった記法で，変数や関数定義のときに <code>def</code> キーワードが必要になったのだ． コマンドオプションのテスト追加PRで「ついでにこのPRでドキュメントも修正しますか？それとも別で出した方が良いですか？」と聞いたところ「余力があるならぜひ別で良いので出してください」と返って来たので別PRで出した次第．</p>
<h2 id="中置関数の導入">3. 中置関数の導入</h2>
<p>Haskell に関数の中置記法がある． 任意の関数に対して，バッククォートで囲ってあげることで二項演算子のように使うことができる：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> <span class="dv">1</span> <span class="ot">`add`</span> <span class="dv">2</span> <span class="co">-- =&gt; display `3`</span></span></code></pre></div>
<p>これを Egison にも導入して欲しいという Issue が既にあった：</p>
<p><a href="https://github.com/egison/egison/issues/135"><img src="../assets/join-hacktoberfest-2020/infix-func-issue.jpg" /></a></p>
<p>他の出したPRと異なりガッツリ処理系をいじる必要がある． 言わずもがな，一番難しかった．</p>
<p>Issue には注意点として，右に閉じバッククォートがない場合は <code>QuoteSymbolExpr</code> となると書いてあった（おそらくLispのマクロ由来の逆クォート）． 試しに，現状の Egison で中置関数を記述してみると：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec -- egison</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ex">Egison</span> Version 4.1.1</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="ex">https</span>://www.egison.org</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="ex">Welcome</span> to Egison Interpreter!</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">1</span> + 2</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">def</span> add x y := x + y</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">add</span> 1 2</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">1</span> <span class="kw">`</span><span class="ex">add</span><span class="kw">`</span> 2</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a><span class="ex">Parse</span> error at: egison:1:8:</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>  <span class="kw">|</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">1</span> <span class="kw">`</span><span class="ex">add</span><span class="kw">`</span> 2</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>  <span class="kw">|</span>        ^^</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="ex">unexpected</span> <span class="st">&quot; 2&quot;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a><span class="ex">expecting</span> atomic expression</span></code></pre></div>
<p>もちろんダメだった．</p>
<h3 id="演算子のパーサーはどこか">演算子のパーサーはどこか</h3>
<p>Egison はパーサーに megaparsec を利用しており，演算子のパーサーは次のようになっている：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">CustomError</span> <span class="dt">String</span> <span class="dt">RuntimeM</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="ot">opExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>opExpr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  ops <span class="ot">&lt;-</span> gets exprOps</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  makeExprParser exprInOp (makeExprTable ops)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="ot">exprInOp ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>exprInOp <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="ot">makeExprTable ::</span> [<span class="dt">Op</span>] <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>makeExprTable ops <span class="ot">=</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  <span class="fu">map</span> (<span class="fu">map</span> toOperator) (groupBy (\x y <span class="ot">-&gt;</span> priority x <span class="op">==</span> priority y) ops)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    <span class="co">-- 実装は割愛</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="ot">    unary ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a><span class="ot">    binary ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="ot">    toOperator ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span></code></pre></div>
<p><code>makeExprParser</code> は <a href="https://hackage.haskell.org/package/parser-combinators-1.2.1/docs/Control-Monad-Combinators-Expr.html#v:makeExprParser">megaparsec（が依存している parser-combinators パッケージ）の関数</a>である．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>makeExprParser</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="ot">  ::</span> <span class="dt">MonadPlus</span> m	 </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="ot">=&gt;</span> m a              <span class="co">-- 二項演算子の引数に当たる部分のパーサー</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> m a]] <span class="co">-- 演算子のパーサーのテーブル</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>2引数目の <code>[[Operator m a]]</code> が今回のキモだ． <code>Operator m a</code> は演算子のパーサーで，<code>[[Operator m a]]</code> は演算子の優先順位（<code>priority</code>）の高い順に <code>Operator m a</code> のリストが並んでいる． <code>gets exprOps</code> は <code>Parser</code> が保持している演算子（<code>Op</code> 型）の集合を返している（<code>ReaderT</code> で保持している）：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Op</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Op</span> {<span class="ot"> repr     ::</span> <span class="dt">String</span>  <span class="co">-- representation</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>       ,<span class="ot"> priority ::</span> <span class="dt">Int</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>       ,<span class="ot"> assoc    ::</span> <span class="dt">Assoc</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>       ,<span class="ot"> isWedge  ::</span> <span class="dt">Bool</span>    <span class="co">-- これはよくわからない</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>       }</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Assoc</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">InfixL</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">InfixR</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">InfixN</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Prefix</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>そして，<code>makeExprTable</code> はこの演算子のリストをもらって，<code>makeExprParser</code> 関数に渡すための演算子パーサー群を生成するための関数だ．</p>
<h3 id="中置関数のパーサーを作る">中置関数のパーサーを作る</h3>
<p>最初は愚直に，関数定義のたびに演算子（<code>Op</code> 型）を生成して，<code>Parser</code> にセットしてあげれば良いかなと雑に考えていたが、これを網羅的にやるのはめんどくさいコトに気づいた． <code>makeExprTable</code> では演算子（<code>Op</code> 型）と演算子パーサーが一対一対応するように作っているが，よく考えたら <code>Operator m a</code> 型はただのパーサーなのでもっと自由に書けるはずだということに気づいた． ということで，中置関数を追加するために <code>makeExprTable</code> へ新しい中治関数用の演算子パーサーを追加することにした：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">makeExprTable ::</span> [<span class="dt">Op</span>] <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>makeExprTable ops <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="fu">reverse</span> <span class="op">$</span> <span class="fu">map</span> (<span class="fu">map</span> <span class="fu">snd</span>) <span class="op">$</span> groupBy ((<span class="op">==</span>) <span class="ot">`on`</span> <span class="fu">fst</span>) <span class="op">$</span> sortOn <span class="fu">fst</span> <span class="op">$</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    (infixFuncOpPriority, infixFuncOperator) <span class="op">:</span> <span class="fu">map</span> (\op <span class="ot">-&gt;</span> (priority op, toOperator op)) ops</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    <span class="co">-- 実装は割愛</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="ot">    unary ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="ot">    binary ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="ot">    toOperator ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="ot">    infixFuncOperator ::</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    infixFuncOperator <span class="ot">=</span> <span class="dt">InfixL</span> <span class="op">$</span> <span class="dt">InfixExpr</span> <span class="op">&lt;$&gt;</span> infixFuncOp</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a><span class="ot">infixFuncOp ::</span> <span class="dt">Parser</span> <span class="dt">Op</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>infixFuncOp <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>  func <span class="ot">&lt;-</span> try (indented <span class="op">&gt;&gt;</span> between (symbol <span class="st">&quot;`&quot;</span>) (symbol <span class="st">&quot;`&quot;</span>) ident)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Op</span> { repr <span class="ot">=</span> func, priority <span class="ot">=</span> infixFuncOpPriority, assoc <span class="ot">=</span> <span class="dt">E.InfixL</span>, isWedge <span class="ot">=</span> <span class="dt">False</span> }</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a><span class="ot">infixFuncOpPriority ::</span> <span class="dt">Int</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>infixFuncOpPriority <span class="ot">=</span> <span class="dv">7</span></span></code></pre></div>
<p>優先順位をいい感じに組み立てるために，少しわかりにくい実装をしているが，順に読んでいけばわかるはずだ：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="fu">map</span> (\op <span class="ot">-&gt;</span> (priority op, toOperator op)) ops    <span class="co">-- [(優先順位 (Int), Op から生成した演算子パーサー)]</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="op">&amp;</span> ((infixFuncOpPriority, infixFuncOperator) <span class="op">:</span>) <span class="co">-- 中置関数の演算子パーサーを追加</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="op">&amp;</span> sortOn <span class="fu">fst</span>                                   <span class="co">-- 優先順位でソート (groupBy するため)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="op">&amp;</span> groupBy ((<span class="op">==</span>) <span class="ot">`on`</span> <span class="fu">fst</span>)                      <span class="co">-- 優先順位でグループ化 ([[(優先順位, 演算子パーサー)]])</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  <span class="op">&amp;</span> <span class="fu">map</span> (<span class="fu">map</span> <span class="fu">snd</span>)                                <span class="co">-- 演算子パーサーだけ取り出す ([[演算子パーサー]])</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>  <span class="op">&amp;</span> <span class="fu">reverse</span>                                      <span class="co">-- 優先順位の低い順になっているので反転  </span></span></code></pre></div>
<p>中置関数のパーサーはシンプルでバッククォートで囲まれた識別子（<code>ident</code>）をとってきているだけだ（<code>ident</code> は変数のパーサーなどで使われている）． <code>symbol</code> を使っているのでバッククォート前後にスペースがあっても動作する． これは Haskell がそうなっていたのでそうしたが，<code>QuoteSymbolExpr</code> のある Egison ではやめた方がいいかもしれない：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ex">ghci</span><span class="op">&gt;</span> 13 <span class="kw">`</span><span class="ex">mod</span><span class="kw">`</span> 10 :: Int</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="ex">ghci</span><span class="op">&gt;</span> 13<span class="kw">`</span><span class="ex">mod</span><span class="kw">`</span>10 :: Int</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="ex">ghci</span><span class="op">&gt;</span> 13<span class="kw">`</span> <span class="ex">mod</span> <span class="kw">`</span>10 :: Int</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="ex">3</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="ex">ghci</span><span class="op">&gt;</span> 13<span class="kw">`</span> <span class="ex">mod</span>    <span class="kw">`</span>10 :: Int</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="ex">3</span></span></code></pre></div>
<h3 id="quotesymbolexpr-の対応">QuoteSymbolExpr の対応</h3>
<p>あとは，注意点にあった <code>QuoteSymbolExpr</code> の部分をなんとかするだけだ：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">-- Atomic expressions without index</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="ot">atomExpr' ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>atomExpr' <span class="ot">=</span> anonParamFuncExpr</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">ConstantExpr</span> <span class="op">&lt;$&gt;</span> constantExpr</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">FreshVarExpr</span> <span class="op">&lt;$</span> symbol <span class="st">&quot;#&quot;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">VarExpr</span> <span class="op">&lt;$&gt;</span> ident</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> vectorExpr</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> collectionExpr</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> tupleOrParenExpr</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> hashExpr</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">QuoteExpr</span> <span class="op">&lt;$&gt;</span> (char <span class="ch">'\''</span> <span class="op">&gt;&gt;</span> atomExpr')</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a> <span class="co">-- 元々 &lt;|&gt; QuoteSymbolExpr &lt;$&gt; (char '`' &gt;&gt; atomExpr')</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">QuoteSymbolExpr</span> <span class="op">&lt;$&gt;</span> try (char <span class="ch">'`'</span> <span class="op">&gt;&gt;</span> atomExpr' <span class="op">&lt;*</span> notFollowedBy (char <span class="ch">'`'</span>))</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>        <span class="op">&lt;|&gt;</span> <span class="dt">AnonParamExpr</span>  <span class="op">&lt;$&gt;</span> try (char <span class="ch">'%'</span> <span class="op">&gt;&gt;</span> positiveIntegerLiteral)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>        <span class="op">&lt;?&gt;</span> <span class="st">&quot;atomic expression&quot;</span></span></code></pre></div>
<p><a href="https://hackage.haskell.org/package/megaparsec-9.0.0/docs/Text-Megaparsec.html#v:notFollowedBy"><code>notFollowedBy</code></a> 関数を使って後ろにバッククォートがないかをチェックしている（<code>try</code> を付けないとパーサーが入力を消費してしまう）．</p>
<h3 id="セクション記法">セクション記法</h3>
<p>実はもう1つやることがある． セクション記法に対応する必要がある（<code>(+ 1)</code> とか <code>(1 +)</code>って感じのやつ）． セクション記法のパーサーはそれぞれ <code>leftSection</code> と <code>rightSection</code> があるので，これに <code>infixFuncOp</code> を追記してあげるだけだ：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">leftSection ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>leftSection <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  ops  <span class="ot">&lt;-</span> gets exprOps</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  op   <span class="ot">&lt;-</span> choice <span class="op">$</span> <span class="fu">map</span> (infixLiteral <span class="op">.</span> repr) ops</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  op   <span class="ot">&lt;-</span> choice <span class="op">$</span> infixFuncOp <span class="op">:</span> <span class="fu">map</span> (infixLiteral <span class="op">.</span> repr) ops <span class="co">-- この (infixFuncOp :)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>  rarg <span class="ot">&lt;-</span> optional expr</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span class="kw">case</span> rarg <span class="kw">of</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>    _ <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">SectionExpr</span> op <span class="dt">Nothing</span> rarg)</span></code></pre></div>
<p>あとはよしなにテストを追加して完成．</p>
<h2 id="テストの個別実行を可能にする">4. テストの個別実行を可能にする</h2>
<p>中置関数の導入で実際は，先にテストを追加して TDD っぽく実装をしていた． その際に，<code>stack test</code> で全部のテストが実行されると非常に遅いのでテストケースを適当に指定して実行したい． ということで，そういうことができるようにした PR が最後のやつだ．</p>
<p><code>stack test</code> は <code>--test-arguments</code> オプションで実行されるテストプログラムにコマンドライン引数を渡すことができる． さらに，テストで使われている test-framework では <a href="https://hackage.haskell.org/package/test-framework-0.8.2.0/docs/Test-Framework-Runners-Console.html#v:defaultMainWithArgs"><code>defaultMainWithArgs</code></a> を使うことで簡単にリッチなオプションを追加できる：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework</span>                 (defaultMain)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework</span>                 (defaultMainWithArgs)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Framework.Providers.HUnit</span> (hUnitTestToTests)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.HUnit</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>  args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>  <span class="fu">flip</span> defaultMainWithArgs args <span class="op">$</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>    hUnitTestToTests <span class="op">$</span> test <span class="op">$</span> <span class="fu">map</span> runTestCase testCases</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a><span class="ot">testCases ::</span> [<span class="dt">FilePath</span>]</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>testCases <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a><span class="ot">runTestCase ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Test</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>runTestCase <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>こんなふうに実行できる（ちなみに，<code>--ta=--help</code> とすれば色々見れる）：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>$ <span class="ex">stack</span> test egison:test --ta=--select-tests=<span class="st">&quot;test/syntax.egi&quot;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="ex">egison</span><span class="op">&gt;</span> test (suite: test, args: --select-tests=test/syntax.egi)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="ex">io</span> and do expression</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="ex">io</span> and do expression without newline</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>:<span class="ex">test</span>/syntax.egi: [<span class="ex">OK</span>]</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>         <span class="ex">Test</span> Cases  Total      </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a> <span class="ex">Passed</span>  1           1          </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a> <span class="ex">Failed</span>  0           0          </span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a> <span class="ex">Total</span>   1           1          </span></code></pre></div>
<p><code>egison:test</code> の部分は Cabal ファイルに複数の <code>Test-Suite</code> が書いてある場合に指定することができる（Egison にはCLIオプションの <code>Test-Suite</code> が増えているので）．</p>
<h2 id="おしまい">おしまい</h2>
<p>今年の Hacktoberfest はちょっと炎上（このイベントをクリアするためにスパムなPRが乱立した）してて，最初はモチベーション下がっていました。 しかし，こういう時こそ正しい形で参加するのは Hacktoberfest 側にとって喜ばしいことかなと思い参加することにしました． 無事OSSに献上できてよかったです（レビューしてくれた方ありがとうございます）．</p>
  </div>

  <footer class="post-footer">
    <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
  </footer>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
