<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="req を使って REST API Haskell パッケージを作る その１" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        req を使って REST API Haskell パッケージを作る その１
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">req を使って REST API Haskell パッケージを作る その１</h1>
    <p class="post-meta">
      <time datetime="2017-08-07" itemprop="datePublished">
        Aug 7, 2017
      </time>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>こういう名前は正しくないかもしれないが，ここでは REST API パッケージ(ライブラリ)とは，既存の REST API を走査するための Haskell パッケージのことを指してる． 例えば，既にあるものだと，<a href="https://developer.github.com/v3/">GitHub API</a> の <a href="http://hackage.haskell.org/package/github"><code>github</code></a> や <a href="https://api.slack.com/">Slack API</a> の <a href="https://hackage.haskell.org/package/slack-api"><code>slack-api</code></a> などがある．</p>
<p>今回はとある事情で，<a href="http://developer.chatwork.com/">ChatWork API</a> の Haskell パッケージを <a href="https://hackage.haskell.org/package/req"><code>req</code></a> ライブラリを使って作ったので，その過程を残してく．</p>
<p>ちなみに，完成品は<a href="https://github.com/matsubara0507/chatwork">ココ</a>にある．</p>
<h2 id="いきさつ">いきさつ</h2>
<p>Haskell でプログラミングする(別に Haskell だけではないけど)アルバイトをしてて，そこで ChatWork API を走査する Haskell パッケージが無いから作ってと言われた． だけ．</p>
<h3 id="なぜ-req-か">なぜ <code>req</code> か</h3>
<p>他に同種の有名なものには以下のものがある．</p>
<ul>
<li><a href="https://github.com/snoyberg/http-client"><code>http-client</code></a></li>
<li><a href="https://github.com/snoyberg/http-client/tree/master/http-conduit"><code>http-conduit</code></a></li>
<li><a href="https://hackage.haskell.org/package/wreq"><code>wreq</code></a></li>
</ul>
<p><code>http-client</code> は “同種” というと語弊がある． <code>req</code> を含め，他の3つのライブラリのベースになるような，低レイヤーのライブラリだ． ちなみに，<code>github</code> ライブラリは <code>http-client</code> を直接使っている．</p>
<h2 id="section"></h2>
<p><code>http-conduit</code> は <code>http-client</code> と同じリポジトリで開発されてるだけあって，<code>http-client</code> の割と公式的な高レイヤーライブラリなのかもしれない． 事実多くの REST API ライブラリが <code>http-conduit</code> を採用している．</p>
<ul>
<li><a href="https://hackage.haskell.org/package/aws">aws: Amazon Web Services (AWS) for Haskell</a></li>
<li><a href="https://hackage.haskell.org/package/fb">fb: Bindings to Facebook’s API.</a></li>
<li><a href="https://hackage.haskell.org/package/twitter-conduit">twitter-conduit: Twitter API package with conduit interface and Streaming API support.</a></li>
</ul>
<p>日本語の使い方を紹介した記事もあった．</p>
<ul>
<li><a href="http://qiita.com/lotz/items/f8440fa08a62d1c44e1a">Haskellから簡単にWeb APIを叩く方法 - Qiita</a></li>
</ul>
<p>なぜ，<code>http-conduit</code> を使わなかったかと言うと，<code>conduit</code> ありきなのに少し抵抗があったからだ． <strong>実際に使ったことは無いので，ありきでは無いかもしれないけど</strong>．</p>
<h2 id="section-1"></h2>
<p><code>wreq</code> は <code>slack-api</code> で使われている． 最近の Reddit のコメントを見ると，この手のものであれば，一番有名なのだろうか？</p>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/6ra2sv/which_libraries_should_i_use_for_writing_a_simple/">Which libraries should I use for writing a simple REST web client? : haskell</a></li>
</ul>
<h2 id="section-2"></h2>
<p>で，実は <code>req</code> には「何故これらのライブラリがあるのに新しく開発したのか」が<a href="https://hackage.haskell.org/package/req#motivation-and-req-vs-other-libraries">書いてあった</a>． その中に <code>wreq</code> の開発が遅いから <code>req</code> 作った，的なことが書いてあった．</p>
<p>どーせ新しく作るなら，割と活発のモノの方がいいかなという(軽い)理由で <code>req</code> を使うことにした． もっと本音を言えば，良さそうな割に<a href="https://github.com/search?q=req+extension%3A.cabal&amp;type=Code&amp;ref=advsearch">あんまり使ってる人いない</a>感じだったので，目立つかなぁという下心もあった(笑)</p>
<h2 id="作る">作る</h2>
<p>ずいぶん余計な話が長くなったが，ここから本題．</p>
<h2 id="ちなみに">ちなみに</h2>
<p><code>curl</code> を使う場合は次のように書く．</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">curl</span> -X GET -H <span class="st">&quot;X-ChatWorkToken: XXXXX&quot;</span> <span class="st">&quot;https://api.chatwork.com/v2/me&quot;</span></code></pre></div>
<p><code>XXXXX</code> が発行したトークン．</p>
<h3 id="返ってくる-json-の型を作る">返ってくる JSON の型を作る</h3>
<p><a href="http://developer.chatwork.com/ja/endpoint_me.html"><code>https://api.chatwork.com/v2/me</code></a> というエンドポイントを考える．</p>
<p>返ってくる JSON は次のような感じ．</p>
<div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;account_id&quot;</span><span class="fu">:</span> <span class="dv">123</span><span class="fu">,</span>
  <span class="dt">&quot;room_id&quot;</span><span class="fu">:</span> <span class="dv">322</span><span class="fu">,</span>
  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;John Smith&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;chatwork_id&quot;</span><span class="fu">:</span> <span class="st">&quot;tarochatworkid&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;organization_id&quot;</span><span class="fu">:</span> <span class="dv">101</span><span class="fu">,</span>
  <span class="dt">&quot;organization_name&quot;</span><span class="fu">:</span> <span class="st">&quot;Hello Company&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;department&quot;</span><span class="fu">:</span> <span class="st">&quot;Marketing&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;title&quot;</span><span class="fu">:</span> <span class="st">&quot;CMO&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;url&quot;</span><span class="fu">:</span> <span class="st">&quot;http://mycompany.com&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;introduction&quot;</span><span class="fu">:</span> <span class="st">&quot;Self Introduction&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;mail&quot;</span><span class="fu">:</span> <span class="st">&quot;taro@example.com&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;tel_organization&quot;</span><span class="fu">:</span> <span class="st">&quot;XXX-XXXX-XXXX&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;tel_extension&quot;</span><span class="fu">:</span> <span class="st">&quot;YYY-YYYY-YYYY&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;tel_mobile&quot;</span><span class="fu">:</span> <span class="st">&quot;ZZZ-ZZZZ-ZZZZ&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;skype&quot;</span><span class="fu">:</span> <span class="st">&quot;myskype_id&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;facebook&quot;</span><span class="fu">:</span> <span class="st">&quot;myfacebook_id&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;twitter&quot;</span><span class="fu">:</span> <span class="st">&quot;mytwitter_id&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;avatar_image_url&quot;</span><span class="fu">:</span> <span class="st">&quot;https://example.com/abc.png&quot;</span>
<span class="fu">}</span></code></pre></div>
<p>コレをレコードで表現する． どう考えても <code>account_id</code> とか <code>name</code> とかが重複しそうなので適当なプレフィックスを付ける(ダサいけど…)．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import </span><span class="dt">GHC.Generic</span> (<span class="dt">Generic</span>)

<span class="kw">data</span> <span class="dt">Me</span> <span class="fu">=</span> <span class="dt">Me</span>
         {<span class="ot"> meToAccountId        ::</span> <span class="dt">Int</span>
         ,<span class="ot"> meToRoomId           ::</span> <span class="dt">Int</span>
         ,<span class="ot"> meToName             ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToChatworkId       ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToOrganizationId   ::</span> <span class="dt">Int</span>
         ,<span class="ot"> meToOrganizationName ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToDepartment       ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToTitle            ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToUrl              ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToIntroduction     ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToMail             ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToTelOrganization  ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToTelExtension     ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToTelMobile        ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToSkype            ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToFacebook         ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToTwitter          ::</span> <span class="dt">Text</span>
         ,<span class="ot"> meToAvatarImageUrl   ::</span> <span class="dt">Text</span>
         } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)</code></pre></div>
<p>これを <code>FronJSON</code> 型クラスのインスタンスにしてやる(<code>ToJSON</code> はついで)．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Aeson.Casing</span> (aesonDrop, snakeCase)
<span class="kw">import </span><span class="dt">Data.Aeson</span> (<span class="dt">FromJSON</span> (..), <span class="dt">ToJSON</span> (..),
                   genericParseJSON, genericToJSON)

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Me</span> <span class="kw">where</span>
  toJSON <span class="fu">=</span> genericToJSON <span class="fu">$</span> aesonDrop (length <span class="st">&quot;meTo&quot;</span>) snakeCase
<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Me</span> <span class="kw">where</span>
  parseJSON <span class="fu">=</span> genericParseJSON <span class="fu">$</span> aesonDrop (length <span class="st">&quot;meTo&quot;</span>) snakeCase</code></pre></div>
<p><code>Data.Aeson.Casing</code> は <a href="https://hackage.haskell.org/package/aeson-casing"><code>aeson-casing</code></a> というパッケージのモジュールで，これを利用すると簡単に <code>aeson</code> のための前処理を記述できる．</p>
<h3 id="エンドポイント用の関数を作る">エンドポイント用の関数を作る</h3>
<p>トークンを与えてエンドポイント用の関数を実行すると，先に定義した <code>Me</code> 型の値が返ってくる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.HTTP.Req</span>

<span class="kw">type</span> <span class="dt">Token</span> <span class="fu">=</span> <span class="dt">ByteString</span>

<span class="ot">baseUrl ::</span> <span class="dt">Url</span> <span class="ch">'Https</span>
baseUrl <span class="fu">=</span> https <span class="st">&quot;api.chatwork.com&quot;</span> <span class="fu">/:</span> <span class="st">&quot;v2&quot;</span>

<span class="ot">mkHeader ::</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Option</span> <span class="ch">'Https</span>
mkHeader token <span class="fu">=</span> header <span class="st">&quot;X-ChatWorkToken&quot;</span> token

<span class="ot">getMe ::</span> (<span class="dt">MonadHttp</span> m) <span class="ot">=&gt;</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> m (<span class="dt">JsonResponse</span> <span class="dt">GetMeResponse</span>)
getMe token <span class="fu">=</span> req <span class="dt">GET</span> (baseUrl <span class="fu">/:</span> <span class="st">&quot;me&quot;</span>) <span class="dt">NoReqBody</span> jsonResponse (mkHeader token)</code></pre></div>
<p>べた書きはあんまりよくないが，<code>baseUrl</code> にどのエンドポイントでも変わらない，ベースとなる URL を定義しておく． <code>req</code> 関数の型は以下の通り</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">req
<span class="ot">  ::</span> ( <span class="dt">MonadHttp</span>    m
     , <span class="dt">HttpMethod</span>   method
     , <span class="dt">HttpBody</span>     body
     , <span class="dt">HttpResponse</span> response
     , <span class="dt">HttpBodyAllowed</span> (<span class="dt">AllowsBody</span> method) (<span class="dt">ProvidesBody</span> body) )
  <span class="ot">=&gt;</span> method            <span class="co">-- ^ HTTP method</span>
  <span class="ot">-&gt;</span> <span class="dt">Url</span> scheme        <span class="co">-- ^ 'Url'—location of resource</span>
  <span class="ot">-&gt;</span> body              <span class="co">-- ^ Body of the request</span>
  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> response    <span class="co">-- ^ A hint how to interpret response</span>
  <span class="ot">-&gt;</span> <span class="dt">Option</span> scheme     <span class="co">-- ^ Collection of optional parameters</span>
  <span class="ot">-&gt;</span> m response        <span class="co">-- ^ Response</span></code></pre></div>
<p>一見難しそうだが</p>
<ul>
<li><code>method</code> は <a href="https://hackage.haskell.org/package/req-0.4.0/docs/Network-HTTP-Req.html#t:GET"><code>GET</code></a> や <a href="https://hackage.haskell.org/package/req-0.4.0/docs/Network-HTTP-Req.html#t:POST"><code>POST</code></a> などの HTTPメソッド</li>
<li><code>Url scheme</code> は(細かいことを気にしなければ) エンドポイントURLを表している</li>
<li><code>body</code> はリクエストの本体(<code>POST</code> や <code>PUT</code> のときに用いる)</li>
<li><code>Proxy response</code> はレスポンスの型を Proxy 型で指定する(JSON なのか，生の文字列なのかなど)</li>
<li><code>Option scheme</code> はその他のリクエストパラメータ</li>
<li><code>m response</code> 返り値の型</li>
</ul>
<p><code>Url scheme</code> 型は <a href="https://hackage.haskell.org/package/req-0.4.0/docs/Network-HTTP-Req.html#v:-47-:"><code>/:</code></a>で組み立てていく． GETメソッドの場合は本体(<code>body</code>)を指定できない(これは <code>HttpBpdyAllowed</code> 型クラスで決まってる)ので <a href="https://hackage.haskell.org/package/req-0.4.0/docs/Network-HTTP-Req.html#t:NoReqBody"><code>NoReqBody</code></a> コンストラクタを使う． <code>Proxy response</code> の値は既に定義されているのでそれを使う(e.g. <code>jsonResponse</code>)． その他のリクエストパラメータにはトークンを指定したいので，<code>mkHeader</code> 関数で <code>Token</code> 型の値(まぁただの <code>ByteString</code>)から生成する．</p>
<h2 id="section-3"></h2>
<p>これを GHCi で実行すると次のようになる</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;</span> <span class="fu">:</span><span class="kw">module</span> <span class="dt">Network.HTTP.Req</span> <span class="dt">ChatWork</span>
<span class="fu">&gt;&gt;</span> token <span class="fu">=</span> <span class="dt">ChatWorkClient</span> <span class="st">&quot;xxx&quot;</span>
<span class="fu">&gt;&gt;</span> print <span class="fu">=&lt;&lt;</span> (responseBody <span class="fu">&lt;$&gt;</span> getMe token)
<span class="dt">Right</span> (<span class="dt">Me</span> {meToAccountId <span class="fu">=</span> <span class="dv">1234567</span>, meToRoomId <span class="fu">=</span> <span class="dv">9876543</span>, meToName <span class="fu">=</span> <span class="st">&quot;\26494\21407\20449\24544&quot;</span>, meToChatworkId <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToOrganizationId <span class="fu">=</span> <span class="dv">13579</span>, meToOrganizationName <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToDepartment <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToTitle <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToUrl <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToIntroduction <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToMail <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToTelOrganization <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToTelExtension <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToTelMobile <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToSkype <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToFacebook <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToTwitter <span class="fu">=</span> <span class="st">&quot;&quot;</span>, meToAvatarImageUrl <span class="fu">=</span> <span class="st">&quot;https://appdata.chatwork.com/avatar/1234/12345678.rsz.png&quot;</span>})</code></pre></div>
<h3 id="manager-を使ってカスタマイズ"><code>Manager</code> を使ってカスタマイズ</h3>
<p>ChatWork のエンドポイントのいくつかは配列が返ってくることがある．</p>
<p>例えば，<a href="http://developer.chatwork.com/ja/endpoint_contacts.html"><code>https://api.chatwork.com/v2/contacts</code></a>では次のようなJSONが返ってくる．</p>
<div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json"><span class="ot">[</span>
  <span class="fu">{</span>
    <span class="dt">&quot;account_id&quot;</span><span class="fu">:</span> <span class="dv">123</span><span class="fu">,</span>
    <span class="dt">&quot;room_id&quot;</span><span class="fu">:</span> <span class="dv">322</span><span class="fu">,</span>
    <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;John Smith&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;chatwork_id&quot;</span><span class="fu">:</span> <span class="st">&quot;tarochatworkid&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;organization_id&quot;</span><span class="fu">:</span> <span class="dv">101</span><span class="fu">,</span>
    <span class="dt">&quot;organization_name&quot;</span><span class="fu">:</span> <span class="st">&quot;Hello Company&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;department&quot;</span><span class="fu">:</span> <span class="st">&quot;Marketing&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;avatar_image_url&quot;</span><span class="fu">:</span> <span class="st">&quot;https://example.com/abc.png&quot;</span>
  <span class="fu">}</span>
<span class="ot">]</span></code></pre></div>
<p>問題は，配列が空の場合． その場合，<code>[]</code> ではなく，なにも返ってこない… そのため，次のようなエラーで落ちてしまう．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;</span> print <span class="fu">=&lt;&lt;</span> (responseBody <span class="fu">&lt;$&gt;</span> getContacts <span class="st">&quot;xxxx&quot;</span>)
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">JsonHttpException</span> <span class="st">&quot;Error in $: not enough input&quot;</span></code></pre></div>
<p><code>aeson</code> のパーサーは空文字 <code>&quot;&quot;</code> をパースできないのだ… 一度は完全に詰んだかと思ったが，たまたま作ってた当時の翌週に <code>req</code> パッケージが v3.0 にアップデートし，<a href="https://hackage.haskell.org/package/req-0.4.0/docs/Network-HTTP-Req.html#v:req-39-"><code>req'</code></a> と言う関数が追加された！</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Network.HTTP.Client</span> <span class="kw">as</span> <span class="dt">L</span>

req'
<span class="ot">  ::</span> forall m method body scheme a<span class="fu">.</span>
     ( <span class="dt">MonadHttp</span>  m
     , <span class="dt">HttpMethod</span> method
     , <span class="dt">HttpBody</span>   body
     , <span class="dt">HttpBodyAllowed</span> (<span class="dt">AllowsBody</span> method) (<span class="dt">ProvidesBody</span> body) )
  <span class="ot">=&gt;</span> method            <span class="co">-- ^ HTTP method</span>
  <span class="ot">-&gt;</span> <span class="dt">Url</span> scheme        <span class="co">-- ^ 'Url'—location of resource</span>
  <span class="ot">-&gt;</span> body              <span class="co">-- ^ Body of the request</span>
  <span class="ot">-&gt;</span> <span class="dt">Option</span> scheme     <span class="co">-- ^ Collection of optional parameters</span>
  <span class="ot">-&gt;</span> (<span class="dt">L.Request</span> <span class="ot">-&gt;</span> <span class="dt">L.Manager</span> <span class="ot">-&gt;</span> m a) <span class="co">-- ^ How to perform request</span>
  <span class="ot">-&gt;</span> m a</code></pre></div>
<p>変わったのは5引数目の <code>(L.Request -&gt; L.Manager -&gt; m a)</code> 型(もともとは <code>Proxy response</code> 型)． ざっくりいうと，<a href="https://hackage.haskell.org/package/http-client-0.5.7.0"><code>http-client</code></a> パッケージの <a href="https://hackage.haskell.org/package/http-client-0.5.7.0/docs/Network-HTTP-Client.html#t:Manager"><code>Manager</code></a> 型を使って，様々な前処理を書き加えることができるようになる(他の用途もあるだろうが)．</p>
<p>これで，空文字だったら <code>[]</code> に変化する前処理を加えてあげれば良い．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span> (<span class="dt">MonadIO</span> (..))
<span class="kw">import </span><span class="dt">Data.Default.Class</span> (def)
<span class="kw">import </span><span class="dt">Data.List</span> (lookup)
<span class="kw">import </span><span class="dt">Data.Maybe</span> (fromMaybe)
<span class="kw">import </span><span class="dt">Data.Proxy</span> (<span class="dt">Proxy</span> (..))
<span class="kw">import </span><span class="dt">Network.Connection</span> (initConnectionContext)
<span class="kw">import </span><span class="dt">Network.HTTP.Client</span> (<span class="dt">BodyReader</span>, <span class="dt">Manager</span>,
                            <span class="dt">ManagerSettings</span> (<span class="fu">..</span>), <span class="dt">Request</span>,
                            <span class="dt">Response</span> (<span class="fu">..</span>), newManager)
<span class="kw">import </span><span class="dt">Network.HTTP.Client.Internal</span> (constBodyReader)
<span class="kw">import </span><span class="dt">Network.HTTP.Client.TLS</span> (mkManagerSettingsContext)
<span class="kw">import </span><span class="dt">Network.HTTP.Req</span> (<span class="dt">AllowsBody</span>, <span class="dt">HttpBody</span>, <span class="dt">HttpBodyAllowed</span>,
                         <span class="dt">HttpMethod</span>, <span class="dt">HttpResponse</span>, <span class="dt">MonadHttp</span>, <span class="dt">Option</span>,
                         <span class="dt">ProvidesBody</span>, <span class="dt">Url</span>, req')
<span class="kw">import </span><span class="dt">Network.HTTP.Types.Header</span> (hContentLength)

<span class="ot">req ::</span>
  ( <span class="dt">MonadHttp</span> m, <span class="dt">HttpMethod</span> method, <span class="dt">HttpBody</span> body, <span class="dt">HttpResponse</span> response
  , <span class="dt">HttpBodyAllowed</span> (<span class="dt">AllowsBody</span> method) (<span class="dt">ProvidesBody</span> body))
  <span class="ot">=&gt;</span> method
  <span class="ot">-&gt;</span> <span class="dt">Url</span> scheme
  <span class="ot">-&gt;</span> body
  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> response
  <span class="ot">-&gt;</span> <span class="dt">Option</span> scheme
  <span class="ot">-&gt;</span> m response
req method url body proxy option <span class="fu">=</span>
  req' method url body option (getHttpResponse' proxy)

<span class="ot">getHttpResponse' ::</span> (<span class="dt">HttpResponse</span> a, <span class="dt">MonadHttp</span> m) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Manager</span> <span class="ot">-&gt;</span> m a)
getHttpResponse' <span class="dt">Proxy</span> r _ <span class="fu">=</span> liftIO <span class="fu">$</span> getHttpResponse r <span class="fu">=&lt;&lt;</span> fixEmptyStringManager

<span class="ot">fixEmptyStringManager ::</span> <span class="dt">IO</span> <span class="dt">Manager</span>
fixEmptyStringManager <span class="fu">=</span> <span class="kw">do</span>
  context <span class="ot">&lt;-</span> initConnectionContext
  <span class="kw">let</span> settings <span class="fu">=</span> mkManagerSettingsContext (<span class="dt">Just</span> context) def <span class="dt">Nothing</span>
  newManager <span class="fu">$</span> settings { managerModifyResponse <span class="fu">=</span> fixEmptyString }

<span class="ot">fixEmptyString ::</span> <span class="dt">Response</span> <span class="dt">BodyReader</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">BodyReader</span>)
fixEmptyString res <span class="fu">=</span> <span class="kw">do</span>
  reader <span class="ot">&lt;-</span> constBodyReader [<span class="st">&quot;[]&quot;</span>]
  <span class="kw">let</span>
    contentLength <span class="fu">=</span> fromMaybe <span class="st">&quot;0&quot;</span> <span class="fu">$</span> lookup hContentLength (responseHeaders res)
  return <span class="fu">$</span> <span class="kw">if</span> contentLength <span class="fu">/=</span> <span class="st">&quot;0&quot;</span> <span class="kw">then</span> res <span class="kw">else</span> res { responseBody <span class="fu">=</span> reader }</code></pre></div>
<p>レスポンスパラメータの <code>ContentLength</code> が <code>0</code> だった場合は，<code>&quot;[]&quot;</code> を新しく返している，という処理だ． 元の <code>Network.HTTP.Req.req</code> 関数の代わりに，この <code>req</code> 関数を使えばうまく動作するはずだ．</p>
<h3 id="post-や-put-はどうするか">POST や PUT はどうするか</h3>
<p>例えば，チャットルームを作るエンドポイントの場合を考える． <code>curl</code> であれば次のように書く．</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">curl</span> -X POST -H <span class="st">&quot;X-ChatWorkToken: 自分のAPIトークン&quot;</span> -d <span class="st">&quot;description=group+chat+description&amp;icon_preset=meeting&amp;members_admin_ids=123%2C542%2C1001&amp;members_member_ids=21%2C344&amp;members_readonly_ids=15%2C103&amp;name=Website+renewal+project&quot;</span> <span class="st">&quot;https://api.chatwork.com/v2/rooms&quot;</span></code></pre></div>
<p><code>-d</code> オプションを使ってルーム名 <code>name</code> や誰を招待するか <code>members_member_ids</code> を指定している． <code>req</code> パッケージでは次のように書く．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.HTTP.Req</span>  (<span class="dt">MonadHttp</span>, <span class="dt">POST</span> (..), <span class="dt">ReqBodyUrlEnc</span> (..),
                          jsonResponse, (<span class="fu">/:</span>))

<span class="kw">newtype</span> <span class="dt">RoomIdWrap</span> <span class="fu">=</span> <span class="dt">RoomIdWrap</span> {<span class="ot"> getRoomId ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">data</span> <span class="dt">CreateRoomParams</span> <span class="fu">=</span> <span class="dt">CreateRoomParams</span>
                      {<span class="ot"> cRoomDescription    ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
                      ,<span class="ot"> cIconPreset         ::</span> <span class="dt">Maybe</span> <span class="dt">IconPreset</span>
                      ,<span class="ot"> cMembersAdminIds    ::</span> [<span class="dt">Int</span>]
                      ,<span class="ot"> cMembersMemberIds   ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]
                      ,<span class="ot"> cMembersReadonlyIds ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]
                      ,<span class="ot"> cRoomName           ::</span> <span class="dt">Text</span>
                      } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">createRoom ::</span> (<span class="dt">MonadHttp</span> m) <span class="ot">=&gt;</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">CreateRoomParams</span> <span class="ot">-&gt;</span> m (<span class="dt">ChatWorkResponse</span> <span class="dt">RoomIdWrap</span>)
createRoom token params <span class="fu">=</span>
  req <span class="dt">POST</span> (baseUrl c <span class="fu">/:</span> <span class="st">&quot;rooms&quot;</span>) (<span class="dt">ReqBodyUrlEnc</span> params') jsonResponse <span class="fu">$</span> mkHeader token
  <span class="kw">where</span>
    params' <span class="fu">=</span> toReqParam <span class="st">&quot;description&quot;</span> (cRoomDescription params)
           <span class="fu">&lt;&gt;</span> toReqParam <span class="st">&quot;icon_preset&quot;</span> (cIconPreset params)
           <span class="fu">&lt;&gt;</span> toReqParam <span class="st">&quot;members_admin_ids&quot;</span> (cMembersAdminIds params)
           <span class="fu">&lt;&gt;</span> toReqParam <span class="st">&quot;members_member_ids&quot;</span> (cMembersMemberIds params)
           <span class="fu">&lt;&gt;</span> toReqParam <span class="st">&quot;members_readonly_ids&quot;</span> (cMembersReadonlyIds params)
           <span class="fu">&lt;&gt;</span> toReqParam <span class="st">&quot;name&quot;</span> (cRoomName params)</code></pre></div>
<p><code>IconPreset</code> 型は <code>icon_preset</code> パラメータに丁度対応するように作った型である(長いので割愛してる)． 今回はURLエンコードする必要があるので，<a href="https://hackage.haskell.org/package/req-0.4.0/docs/Network-HTTP-Req.html#t:ReqBodyUrlEnc"><code>ReqBodyUrlEnc</code></a> コンストラクタを使う． コンストラクタの引数には <a href="https://hackage.haskell.org/package/req-0.4.0/docs/Network-HTTP-Req.html#t:FormUrlEncodedParam"><code>FormUrlEncodedParam</code></a> 型の値を指定してやる必要があり，本来は <code>(=:)</code> 演算子を使って次のように定義する．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">param ::</span> <span class="dt">FormUrlEncodedParam</span>
param <span class="fu">=</span> <span class="st">&quot;price&quot;</span> <span class="fu">=:</span> (<span class="dv">24</span><span class="ot"> ::</span> <span class="dt">Int</span>)
     <span class="fu">&lt;&gt;</span> <span class="st">&quot;mmember&quot;</span> <span class="fu">=:</span> (<span class="st">&quot;hoge&quot;</span><span class="ot"> ::</span> <span class="dt">Text</span>)</code></pre></div>
<p><code>Int</code> 型や <code>Text</code> 型だけなら楽だが，<code>Maybe</code> 型やリスト型のようなコンテナ型が関わってくるとめんどくさい．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">param ::</span> <span class="dt">FormUrlEncodedParam</span>
param <span class="fu">=</span> fromMaybe mempty (<span class="st">&quot;price&quot;</span> <span class="fu">=:</span>) (<span class="dv">24</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>)
     <span class="fu">&lt;&gt;</span> <span class="st">&quot;member&quot;</span> <span class="fu">=:</span> (foldl1 (\acc txt <span class="ot">-&gt;</span> mconcat [acc, <span class="st">&quot;,&quot;</span>, txt]) ([<span class="st">&quot;hoge&quot;</span>, <span class="st">&quot;fuga&quot;</span>]<span class="ot"> ::</span> [<span class="dt">Text</span>]))</code></pre></div>
<p>なので，これを抽象化した <code>toReqParam</code> 型クラスを作った．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ToReqParam</span> a <span class="kw">where</span>
<span class="ot">  toReqParam ::</span> (<span class="dt">QueryParam</span> param, <span class="dt">Monoid</span> param) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> param

<span class="kw">instance</span> <span class="dt">ToReqParam</span> <span class="dt">Int</span> <span class="kw">where</span>
  toReqParam <span class="fu">=</span> (<span class="fu">=:</span>)

<span class="kw">instance</span> <span class="dt">ToReqParam</span> <span class="dt">Text</span> <span class="kw">where</span>
  toReqParam <span class="fu">=</span> (<span class="fu">=:</span>)

<span class="kw">instance</span> <span class="dt">ToReqParam</span> a <span class="ot">=&gt;</span> <span class="dt">ToReqParam</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  toReqParam <span class="fu">=</span> maybe mempty <span class="fu">.</span> toReqParam

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">ToReqParam</span> [a] <span class="kw">where</span>
  toReqParam name <span class="fu">=</span> toReqParam name <span class="fu">.</span> foldl1 (\acc txt <span class="ot">-&gt;</span> mconcat [acc, <span class="st">&quot;,&quot;</span>, txt]) <span class="fu">.</span> fmap (pack <span class="fu">.</span> show)</code></pre></div>
<p>楽になった．</p>
<h3 id="あとは">あとは…</h3>
<p>あとはこれらをエンドポイントの種類だけ書く． まぁこれがしんどいんだが….</p>
<h2 id="おしまい">おしまい</h2>
<p>概ねこれで完成だが，「その２」では 「API に関するエラーの場合の処理の加え方」と「自分流のテストの書き方」を書こうと思う． ちなみに，「レコードだとフィールド名の重複がつらい問題」は <a href="https://hackage.haskell.org/package/extensible"><code>extensible</code></a> パッケージを入れていずれ何とかしたい．</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
