<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="Dockerfileを並列に結ぶコマンドを作りたい(作った？)" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  
    <meta property="og:image" content="/assets/want-to-make-docker-merge/merge-layer.jpg" />
  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        Dockerfileを並列に結ぶコマンドを作りたい(作った？)
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Dockerfileを並列に結ぶコマンドを作りたい(作った？)</h1>
    <p class="post-meta">
      <time datetime="2017-04-02" itemprop="datePublished">
        Apr 2, 2017
      </time>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Docker コンテナは階層構造になっている． 例えば，次のような Dockaerfile の場合は</p>
<div class="sourceCode"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span class="kw">FROM</span> buildpack-deps:jessie-scm

<span class="kw">MAINTAINER</span> MATSUBARA Nobutada

<span class="kw">WORKDIR</span> ~

<span class="co"># Install Haskell</span>
<span class="co">## with stack</span>

<span class="kw">RUN</span> echo <span class="st">'deb http://ppa.launchpad.net/hvr/ghc/ubuntu trusty main'</span> &gt; /etc/apt/sources.list.d/ghc.list \
    &amp;&amp; apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F6F88286 \
    &amp;&amp; apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
    ca-certificates \
    g++ \
    ghc-8.0.2 \
    libtinfo-dev \
    &amp;&amp; apt-get clean \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
<span class="kw">RUN</span> apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 575159689BEFB442 \
    &amp;&amp; echo <span class="st">'deb http://download.fpcomplete.com/debian jessie main'</span> | tee /etc/apt/sources.list.d/fpco.list \
    &amp;&amp; apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
    stack \
    &amp;&amp; apt-get clean \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
<span class="kw">RUN</span> stack config set system-ghc --global true
<span class="kw">ENV</span> PATH /opt/ghc/8.0.2/bin:$PATH</code></pre></div>
<p>次のような階層構造になる．</p>
<div class="figure">
<img src="../assets/want-to-make-docker-merge/layer.jpg" />

</div>
<p>要するに，直列にどんどん乗っけていくことは可能なのだ．</p>
<p>対して，ベースが同じ Dockerfile がふたつあったとき，それをいい感じに並列に繋げることはできない．</p>
<div class="figure">
<img src="../assets/want-to-make-docker-merge/merge-layer.jpg" />

</div>
<p>上図の赤枠のレイヤーは同一である． 上ふたつずつが異なる． なので，ふたつの Dockerfile を前半の共通部分をまず実行し，つぎに異なる部分を実行するような階層構造にしてほしい．</p>
<p>こうすることで，独立した Dockerfile，例えば Ruby をインストールする Dockerfile と Haskell をインストールする Dockerfile を別々に作成・テストし，それを組み合わせて(マージして)，Ruby と Haskell をインストールする Dockerfile を作りたい．</p>
<p>と<a href="../2017-03-30-write-lightweight-dockerfile.html">前回の記事</a>の最後で言った(つもり)．</p>
<p>ので，そういうことをしてくれるコマンドを作ってみた．</p>
<h2 id="どうつくるか">どうつくるか</h2>
<p>もちろん Haskell (ぶれない)．</p>
<p>そもそも，パーサーが必要なので Haskell が向いてるに決まってる(暴論)．</p>
<p>というかあるんじゃないか？と思った(パーサーが)．</p>
<div class="figure">
<img src="../assets/want-to-make-docker-merge/google-haskell-dockerfile-parser.jpg" alt="あった" />
<p class="caption">あった</p>
</div>
<p>流石，Haskeller 達は抜かりない．</p>
<ul>
<li><a href="https://hackage.haskell.org/package/language-dockerfile">language-dockerfile: Dockerfile linter, parser, pretty-printer and embedded DSL</a></li>
</ul>
<p>これは，Dockerfile のパーサーに加えて，Dockerfile のデータ構造を Dockerfile の形式で綺麗に出力する pretty-printer ，Haskell での Dockerfile の内部DSLなど，DOckerfile に関するより取り見取りなライブラリである． <a href="https://github.com/lukasmartinelli/hadolint">hdolint</a> という Haskell製の Dockerfile の静的検査プログラムをベースにしてるらしい． なので，linter も含まれている． すごい</p>
<p>わざわざ車輪の再発名をする必要は無いので，巨人の肩にのさせてもらおう．</p>
<h2 id="つくった">つくった</h2>
<p>GitHub は<a href="https://github.com/matsubara0507/docker-merge">こちら</a>．</p>
<p>数時間で適当に作った．</p>
<p>Dockerfile の命令で綺麗にデータ構造になっているので，ふたつの Dockerfile の命令の等価性を頭からチェックし，違ったら直列に繋げてる． だけ，なので，正直バグ含む可能性は十分にある．</p>
<p>まぁそういうのはおいおい直します．</p>
<p>コマンドの引数の処理は例の如く <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> を使った． まぁ，まだオプションは無いんですけど(Dockerfile のパスを好きなだけ渡すだけ)．</p>
<h3 id="コード">コード</h3>
<p>こんだけしかない．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toInstructions ::</span> <span class="dt">Dockerfile</span> <span class="ot">-&gt;</span> [<span class="dt">Instruction</span>]
toInstructions <span class="fu">=</span> fmap instruction

<span class="ot">removeEOL ::</span> [<span class="dt">Instruction</span>] <span class="ot">-&gt;</span> [<span class="dt">Instruction</span>]
removeEOL <span class="fu">=</span> filter (<span class="fu">/=</span> <span class="dt">EOL</span>)

<span class="ot">mergeDockerfiles ::</span> [<span class="dt">Instruction</span>] <span class="ot">-&gt;</span> [<span class="dt">Instruction</span>] <span class="ot">-&gt;</span> [<span class="dt">Instruction</span>]
mergeDockerfiles [] df <span class="fu">=</span> df
mergeDockerfiles xs<span class="fu">@</span>(x<span class="fu">:</span>xs') ys<span class="fu">@</span>(y<span class="fu">:</span>ys')
  <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> x <span class="fu">:</span> mergeDockerfiles xs' ys'
  <span class="fu">|</span> otherwise <span class="fu">=</span> xs <span class="ot">`mappend`</span> ys

<span class="ot">merge ::</span> [<span class="dt">Dockerfile</span>] <span class="ot">-&gt;</span> <span class="dt">Dockerfile</span>
merge <span class="fu">=</span> toDockerfile <span class="fu">.</span> foldl mergeDockerfiles [] <span class="fu">.</span> fromDockerfile
  <span class="kw">where</span>
    toDockerfile <span class="fu">=</span> fmap instructionPos
    fromDockerfile <span class="fu">=</span> fmap (removeEOL <span class="fu">.</span> toInstructions)</code></pre></div>
<p>これをメイン関数で呼んでるだけ．</p>
<p>language-dockerfile の <code>Dockerfile</code> 型は <code>[InstructionPos]</code> の型シノニム． <code>InstructionPos</code> は Dockerfile の命令コマンドに行番号やファイル名が含まれている． 等価性をチェックするのに，これらの余分な情報は要らないから消している(<code>toInstructions</code>)．</p>
<p><code>EOL</code> (改行) も要らないから消している(<code>removeEOL</code>)</p>
<p>あとは再帰的に等しいかをチェックしている(<code>mergeDockerfiles</code>)． <code>Eq</code> はもとから定義してあったのでそれに準拠した．</p>
<p>これを複数の Dockerfile に対し，畳み込んで適用している(<code>merge</code>)．</p>
<p>簡単ですね．</p>
<h3 id="実行">実行</h3>
<p>次の Ruby をインストールする Dockerfile と，さっきの Haskell をインストールする Dockerfileをマージする．</p>
<div class="sourceCode"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span class="kw">FROM</span> buildpack-deps:jessie-scm

<span class="kw">MAINTAINER</span> MATSUBARA Nobutada

<span class="kw">WORKDIR</span> ~

<span class="co"># install Ruby</span>
<span class="co">## use rbenv</span>

<span class="kw">RUN</span> apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
    g++ \
    gcc \
    make \
    &amp;&amp; apt-get clean \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
<span class="kw">RUN</span> git clone https://github.com/rbenv/rbenv.git ~/.rbenv
<span class="kw">RUN</span> cd ~/.rbenv \
    &amp;&amp; src/configure \
    &amp;&amp; make -C src
<span class="kw">RUN</span> git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
<span class="kw">RUN</span> echo <span class="st">'export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;'</span> &gt;&gt; ~/.bashrc</code></pre></div>
<pre><code>$ stack exec -- docker-merge .\Dockerfiles\ruby\Dockerfile .\Dockerfiles\haskell\Dockerfile
FROM buildpack-deps:jessie-scm
MAINTAINER MATSUBARA Nobutada
WORKDIR ~
#  install Ruby
# # use rbenv
RUN apt-get update \
 &amp;&amp; apt-get install -y --no-install-recommends g++ gcc make \
 &amp;&amp; apt-get clean \
 &amp;&amp; rm -rf /var/lib/apt/lists/*
RUN git clone https://github.com/rbenv/rbenv.git ~/.rbenv
RUN cd ~/.rbenv \
 &amp;&amp; src/configure \
 &amp;&amp; make -C src
RUN git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
RUN echo 'export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;' &gt;&gt; ~/.bashrc
#  Install Haskell
# # with stack
RUN echo 'deb http://ppa.launchpad.net/hvr/ghc/ubuntu trusty main' &gt; /etc/apt/sources.list.d/ghc.list \
 &amp;&amp; apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F6F88286 \
 &amp;&amp; apt-get update \
 &amp;&amp; apt-get install -y --no-install-recommends ca-certificates g++ ghc-8.0.2 libtinfo-dev \
 &amp;&amp; apt-get clean \
 &amp;&amp; rm -rf /var/lib/apt/lists/*
RUN apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 575159689BEFB442 \
 &amp;&amp; echo 'deb http://download.fpcomplete.com/debian jessie main' | tee /etc/apt/sources.list.d/fpco.list \
 &amp;&amp; apt-get update \
 &amp;&amp; apt-get install -y --no-install-recommends stack \
 &amp;&amp; apt-get clean \
 &amp;&amp; rm -rf /var/lib/apt/lists/*
RUN stack config set system-ghc --global true
ENV PATH=&quot;/opt/ghc/8.0.2/bin:$PATH&quot;</code></pre>
<p>うん，取りあえずはいい感じ．</p>
<h2 id="おしまい">おしまい</h2>
<p>今回はとりあえず合体させるコマンドを作っただけ． なので，合体させてもいいかどうかもチェックできるように改良したい．</p>
<p>あと，language-dockerfile と Haskell の Testing ライブラリを組み合わせれば，簡単にテストもできそう． 既にある hdolint も使えるしね．</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

</footer>


      </div>
  </body>

</html>
