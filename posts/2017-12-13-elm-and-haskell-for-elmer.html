<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="Elm と Haskell で作る ToDo アプリ" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  
    <meta property="og:image" content="/assets/create-haskell-and-elm/sample.jpg" />
  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        Elm と Haskell で作る ToDo アプリ
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Elm と Haskell で作る ToDo アプリ</h1>
    <p class="post-meta">
      <time datetime="2017-12-13" itemprop="datePublished">
        Dec 13, 2017
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="../tags/Haskell.html">Haskell</a> <a href="../tags/Elm.html">Elm</a> <a href="../tags/application.html">application</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://qiita.com/advent-calendar/2017/elm">Elm Advent Calendar 2017</a> の13日目の記事です．</p>
<p>普段はよく Haskell を使っていますが，ひょんなことから Elm を触り始め，フロントを表現する良いサブウェポンとしてかなり気に入りました．</p>
<p>今回は Elm の相棒として大本命である(要出典) Haskell と組み合わせた場合の書き方などを ToDo アプリを例にして説明します．</p>
<p>最終的なコードは以下にあります．</p>
<ul>
<li><a href="https://github.com/matsubara0507/haskell-and-elm/tree/unuse-extensible">matsubara0507/haskell-and-elm tree:unuse-extensible - GitHub</a></li>
</ul>
<p>ちなみに，この内容については以前に記事にしました．</p>
<ul>
<li><a href="https://matsubara0507.github.io/posts/2017-09-17-create-haskell-and-elm.html">Haskell × Elm のサンプルアプリケーションを書いてみた - ひげメモ</a></li>
</ul>
<p>同じこと書いてもアレなので，今回は Haskell 知らない人向けにブラッシュアップします(できるだけ)．</p>
<h2 id="haskell-の準備">Haskell の準備</h2>
<p>(Haskell は分かってるよ勢は読み飛ばして)</p>
<p>Elm 処理系は既にある前提です． Haskell は特殊な要件(Backpack システムを使いたいとか)が無い限りはstack を使いましょう．</p>
<p><a href="https://docs.haskellstack.org/en/stable/README/#how-to-install">公式サイトにある</a>通り，Windows は専用のインストーラーを，それ以外は <code>curl -sSL https://get.haskellstack.org/ | sh</code> と叩けばいいはず．</p>
<h3 id="プロジェクト">プロジェクト</h3>
<p>Haskell プロジェクトは <code>.cabal</code> ファイルというのに構成を書く． ただし，<code>.cabal</code> ファイルは独自記法なため慣れてないと扱いにくい． そこで，<a href="https://github.com/sol/hpack">hpack</a> というのを用いて，よくある yaml ファイルによる構成記述から <code>.cabal</code> に変換して使うのが最近の主流だ．</p>
<p>例えば以下のような <code>package.yaml</code> ファイルを書く．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">name:</span><span class="at">                haskell-and-elm</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">version:</span><span class="at">             </span><span class="fl">0.1.0.0</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="fu">homepage:</span><span class="at">            https://github.com/matsubara0507/haskell-and-elm</span><span class="co">#readme</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="fu">license:</span><span class="at">             MIT</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="fu">author:</span><span class="at">              MATSUBARA Nobutada</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="fu">copyright:</span><span class="at">           2017 MATSUBARA Nobutada</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="fu">category:</span><span class="at">            Web</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="kw">-</span> aeson</a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="kw">-</span> base &gt;= 4.7 &amp;&amp; &lt; 5</a>
<a class="sourceLine" id="cb1-12" title="12">  <span class="kw">-</span> elm-export</a>
<a class="sourceLine" id="cb1-13" title="13">  <span class="kw">-</span> servant-elm</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="fu">library:</span></a>
<a class="sourceLine" id="cb1-16" title="16">  <span class="fu">source-dirs:</span><span class="at">        src</span></a>
<a class="sourceLine" id="cb1-17" title="17">  <span class="fu">exposed-modules:</span></a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="kw">-</span> Hoge</a>
<a class="sourceLine" id="cb1-19" title="19">  <span class="fu">other-modules:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="fu">executables:</span></a>
<a class="sourceLine" id="cb1-22" title="22">  <span class="fu">hoge-exe:</span></a>
<a class="sourceLine" id="cb1-23" title="23">    <span class="fu">source-dirs:</span><span class="at">      src</span></a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="fu">main:</span><span class="at">             Main.hs</span></a></code></pre></div>
<p><code>homepage</code> とか <code>license</code> とか <code>author</code> とかは無くても動く． <code>dependencies</code> は依存パッケージを指定し，<code>library</code> はプロジェクトで作るライブラリの設定を記述し，<code>executables</code> は実行プログラムの設定を記述する． 他にも <code>tests</code> とかもある．</p>
<h3 id="stack-の役割">stack の役割</h3>
<p><code>.cabal</code> ファイル(<code>package.yaml</code>) の他に <code>stack.yaml</code> ファイルを用意する必要がある． そもそも stack の役割は，依存しているパッケージ間のバージョンをいい感じに取ってきてくれるパッケージ群のスナップショットを提供することだ．</p>
<p>例えば次のような <code>stack.yaml</code> を書く．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">resolver:</span><span class="at"> lts-9.17</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="fu">extra-deps:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="fu">flags:</span><span class="at"> </span><span class="kw">{}</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="fu">extra-package-dbs:</span><span class="at"> </span><span class="kw">[]</span></a></code></pre></div>
<p>重要なのは <code>resolver</code> で，他は無くてもたぶん動きます． <code>resolver</code> でいい感じのパッケージ群のスナップショットを指定する． どんなのがあるかは<a href="https://www.stackage.org/">公式サイト</a>を参照．</p>
<p>もし，指定したスナップショットにはないパッケージやバージョンを使いたい場合は <code>extra-deps</code> に書くといい．</p>
<h2 id="作るもの">作るもの</h2>
<p>さて本題．</p>
<p>タイトルの通り，フロントを Elm で，バックを Haskell で書いた，超簡易版 ToDo アプリを書きます．</p>
<p>具体的には以下の記事と同じものを書きます．</p>
<ul>
<li><a href="https://qiita.com/lotz/items/883b41fa79f060e59efa#単純な例">【型レベルWeb DSL】 Servantの紹介 - Qiita</a></li>
</ul>
<p>整理すると以下のようなエンドポイントを Haskell で実装し，Elm 側でアクセスして操作する UI を作る．</p>
<pre><code>GET    /todos
POST   /todos
PUT    /todos/:id
DELETE /todos/:id</code></pre>
<p>ちなみに，めんどくさいので DB は使わず，Haskell 内部で配列のようにして持つだけにする．</p>
<h2 id="作る">作る</h2>
<p>肝になるのは Elm と Haskell をどうやってつなぐか． もちろん RESTful API を定義するので，各々を別々に書くこともできるが，ここはもっと賢くやってみよう．</p>
<h3 id="まずは-haskell-から">まずは Haskell から</h3>
<h4 id="プロジェクトの準備">プロジェクトの準備</h4>
<p><code>stack new</code> でプロジェクトを生成する．</p>
<pre><code>$ stack new haskell-and-elm simple-hpack</code></pre>
<p><code>elm-and-haskell</code> がプロジェクト名で，<code>simple-hpack</code> がテンプレート名だ．</p>
<p>次に <code>package.yaml</code> を書き換える．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">name:</span><span class="at"> haskell-and-elm</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="fu">version:</span><span class="at"> </span><span class="fl">0.1.0.0</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="fu">ghc-options:</span><span class="at"> -Wall</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="kw">-</span> aeson</a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="kw">-</span> base &gt;= 4.7 &amp;&amp; &lt; 5</a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="kw">-</span> containers</a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="kw">-</span> elm-export</a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="kw">-</span> http-api-data</a>
<a class="sourceLine" id="cb5-11" title="11">  <span class="kw">-</span> servant</a>
<a class="sourceLine" id="cb5-12" title="12">  <span class="kw">-</span> servant-ede</a>
<a class="sourceLine" id="cb5-13" title="13">  <span class="kw">-</span> servant-elm</a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="kw">-</span> servant-server</a>
<a class="sourceLine" id="cb5-15" title="15">  <span class="kw">-</span> stm</a>
<a class="sourceLine" id="cb5-16" title="16">  <span class="kw">-</span> transformers</a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="fu">library:</span></a>
<a class="sourceLine" id="cb5-19" title="19">  <span class="fu">source-dirs:</span><span class="at"> src</span></a>
<a class="sourceLine" id="cb5-20" title="20">  <span class="fu">exposed-modules:</span></a>
<a class="sourceLine" id="cb5-21" title="21">    <span class="kw">-</span> Todo</a>
<a class="sourceLine" id="cb5-22" title="22">  <span class="fu">other-modules:</span><span class="at"> </span><span class="kw">[]</span></a></code></pre></div>
<p>少し依存パッケージが多いが気にしない．</p>
<p><code>src</code> 以下にある <code>Main.hs</code> は要らないので削除して，代わりに <code>Todo.hs</code> を作ろう． まだ以下だけで十分．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">module</span> <span class="dt">Todo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">data</span> <span class="dt">Todo</span></a></code></pre></div>
<p>取りあえずコンパイルしてみると怒られるはずだ．</p>
<pre><code># stack build
Error: While constructing the build plan, the following exceptions were encountered:

In the dependencies for haskell-and-elm-0.1.0.0:
    servant-ede must match -any, but the stack configuration has no specified version (latest applicable is 0.6)
needed since haskell-and-elm-0.1.0.0 is a build target.

Recommended action: try adding the following to your extra-deps in C:\Users\noob\git\haskell\haskell-and-elm\stack.yaml:
- servant-ede-0.6

You may also want to try the 'stack solver' command
Plan construction failed.</code></pre>
<p><code>package.yaml</code> で <code>servant-ede</code> を依存パッケージに指定してるけど，<code>stack.yaml</code> で指定してるスナップショットには無いから <code>stack.yaml</code> の <code>extra-deps</code> のところに書き加えて，と言われてるので，その通りにする．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" title="1"><span class="fu">resolver:</span><span class="at"> lts-9.18</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">-</span> servant-ede-0.6</a>
<a class="sourceLine" id="cb8-6" title="6"><span class="fu">flags:</span><span class="at"> </span><span class="kw">{}</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="fu">extra-package-dbs:</span><span class="at"> </span><span class="kw">[]</span></a></code></pre></div>
<p>これで <code>stack build</code> が通るはず．</p>
<h4 id="型を考える">型を考える</h4>
<p>Haskell はまず，扱う型から考える． Elm もきっと同じですよね(Model の型から考えるよね？？)</p>
<p>今回扱うのは ToDo タスクの型． 話を簡単にするために，識別子と，ToDo タスクのタイトルと，タスクの完了を表す真偽値のみをフィールドに持つとする．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="co">-- src/Todo.hs</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">module</span> <span class="dt">Todo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">data</span> <span class="dt">Todo</span> <span class="fu">=</span> <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb9-6" title="6">  {<span class="ot"> todoId ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-7" title="7">  ,<span class="ot"> title  ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-8" title="8">  ,<span class="ot"> done   ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-9" title="9">  }</a></code></pre></div>
<p>ちなみに，<code>data</code> 宣言による型定義は Elm での <code>type</code> 宣言による定義と同義だ．</p>
<p>次に，RESTful API の仕様を型として定義しよう． そのためには <a href="https://hackage.haskell.org/package/servant">servant</a> と呼ばれるパッケージを用いる． それを用いると次のような API の型を書ける．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="co">-- src/Todo.hs</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">{-# LANGUAGE DataKinds     #-}</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">module</span> <span class="dt">Todo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="kw">import</span>           <span class="dt">Servant.API</span></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="kw">import</span>           <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb10-10" title="10"></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="kw">data</span> <span class="dt">Todo</span> <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb10-12" title="12"></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="kw">type</span> <span class="dt">CRUD</span></a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="fu">=</span> <span class="st">&quot;todos&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">Todo</span>]</a>
<a class="sourceLine" id="cb10-15" title="15"> <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;todos&quot;</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> '[<span class="dt">JSON</span>, <span class="dt">FormUrlEncoded</span>] <span class="dt">Todo</span> <span class="fu">:&gt;</span> <span class="dt">Post</span> '[<span class="dt">JSON</span>] <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb10-16" title="16"> <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;todos&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;id&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> '[<span class="dt">JSON</span>, <span class="dt">FormUrlEncoded</span>] <span class="dt">Todo</span> <span class="fu">:&gt;</span> <span class="dt">Put</span> '[<span class="dt">JSON</span>] ()</a>
<a class="sourceLine" id="cb10-17" title="17"> <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;todos&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;id&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Delete</span> '[<span class="dt">JSON</span>] ()</a></code></pre></div>
<p><code>{-# LANGUAGE ... #-}</code> というのは GHC拡張と呼ばれるもので，Haskell の仕様にはないが，GHC にのみ(便利・面白いから)取り入れられてる機能を使うというフラグみたいなものだ． <code>DataKinds</code> 拡張によって型定義に値レベルのはずの文字列やリストを扱えるようになり(<code>&quot;todos&quot;</code> とか <code>'[JSON]</code> の部分)，<code>TypeOperators</code> 拡張で型定義に演算子が使えるようになる．</p>
<p>ちなみに，<code>type</code> 宣言は Elm でいう <code>type alias</code> 宣言と同義で，型の別名を与えているだけだ．</p>
<p><code>CRUD</code> 型の意味は何となくわかるはずだ． 前述した RESTful API の仕様をそのまんま型にした感じでしょう？</p>
<h4 id="型クラスとジェネリクス">型クラスとジェネリクス</h4>
<p>これで一応ビルドは通るが <code>Todo</code> 型の JSON へのデコーダー・エンコーダーと，リクエスト Body にエンコードする関数が未定義のため，後々に怒られるだろう． 怒られないようにするためには <code>Todo</code> 型を <code>FromJSON</code>，<code>ToJSON</code>，<code>FromForm</code> 型クラスのインスタンスにしてやればよい(特定の関数を実装するだけ)． しかし，デコーダーやエンコーダーを手書きするのはめんどくさいよね？</p>
<p>そこで，Haskell のメタプログラミングのひとつ，ジェネリクスを用いる．</p>
<p><code>src/Todo.hs</code> に以下のようなのを書き加える．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">import</span>           <span class="dt">Data.Aeson</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="kw">import</span>           <span class="dt">GHC.Generics</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="kw">import</span>           <span class="dt">Web.Internal.FormUrlEncoded</span> (<span class="dt">FromForm</span>)</a>
<a class="sourceLine" id="cb11-6" title="6"></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="kw">data</span> <span class="dt">Todo</span> <span class="fu">=</span> <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb11-8" title="8">  {<span class="ot"> todoId ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-9" title="9">  ,<span class="ot"> title  ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-10" title="10">  ,<span class="ot"> done   ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb11-11" title="11">  } <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb11-12" title="12"></a>
<a class="sourceLine" id="cb11-13" title="13"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb11-14" title="14"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb11-15" title="15"><span class="kw">instance</span> <span class="dt">FromForm</span> <span class="dt">Todo</span></a></code></pre></div>
<p><code>deriving</code> というのは型クラスのインスタンスを自動で設定する仕組みだ． <code>deriving</code> は本来，<code>Show</code> や <code>Eq</code> のような組み込みにある型クラスにのみ使える． ここでは，GHC 固有の <code>Generic</code> と呼ばれる型クラスも <code>deriving</code> したいので，<code>DeriveGeneric</code> 拡張を書き加えている． <code>Generic</code> 型クラスのインスタンスであれば，多くの型クラスのインスタンスを自動で実装してくれる(型クラスを提供してる人がそのような仕組みを作る)．</p>
<p>結果として，<code>instance FromJSON Todo</code> と書くだけで <code>FromJSON</code> のインスタンス化が出来てしまう． すごいよね．</p>
<h4 id="サーバーを立てる">サーバーを立てる</h4>
<p>ここはざっくりと(丁寧にやると長くなるので)． 以下のような <code>app/Main.hs</code> ファイルを用意する．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">{-# LANGUAGE DataKinds     #-}</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="kw">import</span>           <span class="dt">Control.Arrow</span>             (second)</a>
<a class="sourceLine" id="cb12-7" title="7"><span class="kw">import</span>           <span class="dt">Control.Concurrent.STM</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Class</span>    (liftIO)</a>
<a class="sourceLine" id="cb12-9" title="9"><span class="kw">import</span>           <span class="dt">Data.Aeson</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="kw">import</span>           <span class="dt">Data.IntMap</span>               (<span class="dt">IntMap</span>)</a>
<a class="sourceLine" id="cb12-11" title="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.IntMap</span>               <span class="kw">as</span> <span class="dt">IntMap</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="kw">import</span>           <span class="dt">Data.Proxy</span>                (<span class="dt">Proxy</span> (..))</a>
<a class="sourceLine" id="cb12-13" title="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.Wai.Handler.Warp</span>  <span class="kw">as</span> <span class="dt">Warp</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="kw">import</span>           <span class="dt">Servant.API</span></a>
<a class="sourceLine" id="cb12-15" title="15"><span class="kw">import</span>           <span class="dt">Servant.EDE</span>               (<span class="dt">HTML</span>, loadTemplates)</a>
<a class="sourceLine" id="cb12-16" title="16"><span class="kw">import</span>           <span class="dt">Servant.Server</span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="kw">import</span>           <span class="dt">Servant.Utils.StaticFiles</span> (serveDirectoryFileServer)</a>
<a class="sourceLine" id="cb12-18" title="18"><span class="kw">import</span>           <span class="dt">Todo</span>                      (<span class="dt">Todo</span> (..))</a>
<a class="sourceLine" id="cb12-19" title="19"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb12-20" title="20"></a>
<a class="sourceLine" id="cb12-21" title="21"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-22" title="22">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-23" title="23">  db <span class="ot">&lt;-</span> atomically <span class="fu">$</span> newTVar (<span class="fu">length</span> initTodoList, IntMap.fromList initTodoList)</a>
<a class="sourceLine" id="cb12-24" title="24">  _ <span class="ot">&lt;-</span> loadTemplates api [] <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb12-25" title="25">  <span class="fu">putStrLn</span> <span class="st">&quot;Listening on port 8080&quot;</span></a>
<a class="sourceLine" id="cb12-26" title="26">  Warp.run <span class="dv">8080</span> <span class="fu">$</span> serve api (server db)</a>
<a class="sourceLine" id="cb12-27" title="27"></a>
<a class="sourceLine" id="cb12-28" title="28"><span class="kw">type</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb12-29" title="29">    <span class="fu">=</span> <span class="dt">Get</span> '[<span class="dt">HTML</span> <span class="st">&quot;index.html&quot;</span>] <span class="dt">Object</span></a>
<a class="sourceLine" id="cb12-30" title="30"> <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;static&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Raw</span></a>
<a class="sourceLine" id="cb12-31" title="31"> <span class="fu">:&lt;|&gt;</span> <span class="dt">Todo.CRUD</span></a>
<a class="sourceLine" id="cb12-32" title="32"></a>
<a class="sourceLine" id="cb12-33" title="33"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb12-34" title="34">api <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb12-35" title="35"></a>
<a class="sourceLine" id="cb12-36" title="36"><span class="ot">server ::</span> <span class="dt">TVar</span> (<span class="dt">Int</span>, <span class="dt">IntMap</span> <span class="dt">Todo</span>) <span class="ot">-&gt;</span> <span class="dt">Server</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb12-37" title="37">server db <span class="fu">=</span> <span class="fu">index</span></a>
<a class="sourceLine" id="cb12-38" title="38">     <span class="fu">:&lt;|&gt;</span> serveDirectoryFileServer <span class="st">&quot;static&quot;</span></a>
<a class="sourceLine" id="cb12-39" title="39">     <span class="fu">:&lt;|&gt;</span> getTodos</a>
<a class="sourceLine" id="cb12-40" title="40">     <span class="fu">:&lt;|&gt;</span> postTodo</a>
<a class="sourceLine" id="cb12-41" title="41">     <span class="fu">:&lt;|&gt;</span> putTodoId</a>
<a class="sourceLine" id="cb12-42" title="42">     <span class="fu">:&lt;|&gt;</span> deleteTodoId</a>
<a class="sourceLine" id="cb12-43" title="43">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-44" title="44">    <span class="fu">index</span> <span class="fu">=</span> <span class="fu">pure</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb12-45" title="45">    getTodos <span class="fu">=</span> liftIO <span class="fu">$</span> IntMap.elems <span class="fu">.</span> <span class="fu">snd</span> <span class="fu">&lt;$&gt;</span> atomically (readTVar db)</a>
<a class="sourceLine" id="cb12-46" title="46">    postTodo todo <span class="fu">=</span> liftIO <span class="fu">.</span> atomically <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-47" title="47">      (maxId, m) <span class="ot">&lt;-</span> readTVar db</a>
<a class="sourceLine" id="cb12-48" title="48">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb12-49" title="49">        newId <span class="fu">=</span> maxId <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-50" title="50">        newTodo <span class="fu">=</span> todo { todoId <span class="fu">=</span> newId }</a>
<a class="sourceLine" id="cb12-51" title="51">      writeTVar db (newId, IntMap.insert newId newTodo m)</a>
<a class="sourceLine" id="cb12-52" title="52">      <span class="fu">pure</span> newTodo</a>
<a class="sourceLine" id="cb12-53" title="53">    putTodoId tid todo <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-54" title="54">      liftIO <span class="fu">.</span> atomically <span class="fu">.</span> modifyTVar db <span class="fu">.</span> second <span class="fu">$</span> IntMap.insert tid todo</a>
<a class="sourceLine" id="cb12-55" title="55">    deleteTodoId tid   <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-56" title="56">      liftIO <span class="fu">.</span> atomically <span class="fu">.</span> modifyTVar db <span class="fu">.</span> second <span class="fu">$</span> IntMap.delete tid</a>
<a class="sourceLine" id="cb12-57" title="57"></a>
<a class="sourceLine" id="cb12-58" title="58"><span class="ot">initTodoList ::</span> [(<span class="dt">Int</span>, <span class="dt">Todo</span>)]</a>
<a class="sourceLine" id="cb12-59" title="59">initTodoList <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-60" title="60">  [ (<span class="dv">1</span>, <span class="dt">Todo</span> <span class="dv">1</span> <span class="st">&quot;アドベントカレンダーを書く&quot;</span> <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb12-61" title="61">  , (<span class="dv">2</span>, <span class="dt">Todo</span> <span class="dv">2</span> <span class="st">&quot;Haskellで仕事する&quot;</span> <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb12-62" title="62">  , (<span class="dv">3</span>, <span class="dt">Todo</span> <span class="dv">3</span> <span class="st">&quot;寝る&quot;</span> <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb12-63" title="63">  ]</a></code></pre></div>
<p>キモなのは <code>server</code> 関数のところ． <code>getTodos</code> や <code>deleteTodoId</code> などの補助関数が，<code>src/Todo.hs</code> で定義した <code>CRUD</code> 型に対応しているのが分かるだろう．</p>
<p><code>API</code> 型は <code>CRUD</code> 型に <code>index.html</code> 用のパスと静的ファイル用のパス <code>static</code> を追加しただけだ． ちなみに，<code>TVar</code> 型とか <code>atomically</code> 関数とかは，並列処理の Software Transactional Memory という機能のためのモノです．</p>
<h2 id="section"></h2>
<p><code>stack build</code> したのち，<code>stack exec server</code> とすると API サーバーを起動できる．</p>
<pre><code>$ stack exec server
Listening on port 8080</code></pre>
<p>実際に curl でアクセスしてみる．</p>
<pre><code>$ curl http://localhost:8080/todos
[{&quot;done&quot;:true,&quot;todoId&quot;:1,&quot;title&quot;:&quot;アドベントカレンダーを書く&quot;},{&quot;done&quot;:false,&quot;todoId&quot;:2,&quot;title&quot;:&quot;Haskellで仕事する&quot;},{&quot;done&quot;:false,&quot;todoId&quot;:3,&quot;title&quot;:&quot;寝る&quot;}]</code></pre>
<h3 id="elm-にバトンタッチ">Elm にバトンタッチ</h3>
<p>Haskell の話ばっかりですいません… ここからはお待ちかねの Elm です．</p>
<h4 id="の前に準備">の前に準備</h4>
<p>Elm で HTTP リクエストを送るには <code>Http.request</code> を使うのが一般的だと思う． それで <code>http://localhost:8080/todos</code> を叩けば一応 ToDo タスクのリストは手に入る． しかし，せっかく自分で API を定義したなら，そのクライアントも自動で生成したいじゃない．</p>
<p>そこで使うのが <a href="https://hackage.haskell.org/package/servant-elm">servant-elm</a> パッケージ！ (あれ，また Haskell の話に戻ってる？)</p>
<h2 id="section-1"></h2>
<p>servant-elm と <a href="https://hackage.haskell.org/package/elm-export">elm-export</a> というパッケージを使うと</p>
<ul>
<li>Haskell の型から Elm の型の生成</li>
<li>生成した Elm の型のための JSON デコーダー・エンコーダーの生成</li>
<li>Servant の API 型から Elm のためのクライアントを生成</li>
</ul>
<p>してくれる． すごいね！</p>
<p>(ただし，<a href="https://github.com/krisajenkins/elm-export#status">全ての Haskell の型を Elm の型に変換できるわけではない…</a>)</p>
<h2 id="section-2"></h2>
<p>まずは Elm の型に変換できるように，<code>src/Todo.hs</code> に以下の行を書き加える．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">instance</span> <span class="dt">FromForm</span> <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="kw">instance</span> <span class="dt">ElmType</span> <span class="dt">Todo</span>  <span class="co">-- コレ</span></a></code></pre></div>
<p>そして，<code>app/Generate.hs</code> というファイルを作る．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="kw">import</span>           <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="kw">import</span>           <span class="dt">Elm</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">import</span>           <span class="dt">Servant.Elm</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="kw">import</span>           <span class="dt">Shelly</span>      (mkdir_p, shelly)</a>
<a class="sourceLine" id="cb16-9" title="9"><span class="kw">import</span>           <span class="dt">Todo</span>        (<span class="dt">CRUD</span>, <span class="dt">Todo</span>)</a>
<a class="sourceLine" id="cb16-10" title="10"></a>
<a class="sourceLine" id="cb16-11" title="11"></a>
<a class="sourceLine" id="cb16-12" title="12"><span class="ot">elmOpts ::</span> <span class="dt">ElmOptions</span></a>
<a class="sourceLine" id="cb16-13" title="13">elmOpts <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-14" title="14">  defElmOptions</a>
<a class="sourceLine" id="cb16-15" title="15">    { urlPrefix <span class="fu">=</span> <span class="dt">Static</span> <span class="st">&quot;http://localhost:8080&quot;</span> }</a>
<a class="sourceLine" id="cb16-16" title="16"></a>
<a class="sourceLine" id="cb16-17" title="17"><span class="ot">spec ::</span> <span class="dt">Spec</span></a>
<a class="sourceLine" id="cb16-18" title="18">spec <span class="fu">=</span> <span class="dt">Spec</span> [<span class="st">&quot;Generated&quot;</span>, <span class="st">&quot;TodoAPI&quot;</span>]</a>
<a class="sourceLine" id="cb16-19" title="19">            (defElmImports</a>
<a class="sourceLine" id="cb16-20" title="20">             <span class="fu">:</span> toElmTypeSource    (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Todo</span>)</a>
<a class="sourceLine" id="cb16-21" title="21">             <span class="fu">:</span> toElmDecoderSource (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Todo</span>)</a>
<a class="sourceLine" id="cb16-22" title="22">             <span class="fu">:</span> toElmEncoderSource (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Todo</span>)</a>
<a class="sourceLine" id="cb16-23" title="23">             <span class="fu">:</span> generateElmForAPIWith elmOpts  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">CRUD</span>))</a>
<a class="sourceLine" id="cb16-24" title="24"></a>
<a class="sourceLine" id="cb16-25" title="25"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-26" title="26">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-27" title="27">  shelly <span class="fu">$</span> mkdir_p <span class="st">&quot;elm-src/Generated&quot;</span></a>
<a class="sourceLine" id="cb16-28" title="28">  specsToDir [spec] <span class="st">&quot;elm-src&quot;</span></a></code></pre></div>
<p><a href="https://hackage.haskell.org/package/shelly">Shelly</a> というのは Hasksell 上で UNIX コマンドみたいのを叩くためのパッケージ．</p>
<p><code>spec</code> 関数の <code>Spec [&quot;Generated&quot;, &quot;TodoAPI&quot;]</code> で <code>Generated.TodoAPI</code> というモジュールを生成することを指定している． <code>main</code> 関数の <code>specsToDir [spec] &quot;elm-src&quot;</code> で <code>Generated.TodoAPI</code> モジュールを <code>elm-src</code> ディレクトリ以下に生成する． 結果として <code>elm-src/Generated/TodoAPI.elm</code> ファイルが生成される．</p>
<p>これを <code>package.yaml</code> にテストとして設定することで，<code>stack test</code> で生成してくれるようになる．</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb17-1" title="1"><span class="co"># package.yaml</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="fu">tests:</span></a>
<a class="sourceLine" id="cb17-4" title="4">  <span class="fu">generate:</span></a>
<a class="sourceLine" id="cb17-5" title="5">    <span class="fu">source-dirs:</span><span class="at"> app</span></a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="fu">main:</span><span class="at"> Generate.hs</span></a>
<a class="sourceLine" id="cb17-7" title="7">    <span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb17-8" title="8">      <span class="kw">-</span> haskell-and-elm</a>
<a class="sourceLine" id="cb17-9" title="9">      <span class="kw">-</span> shelly</a>
<a class="sourceLine" id="cb17-10" title="10">    <span class="fu">other-modules:</span><span class="at"> </span><span class="kw">[]</span></a></code></pre></div>
<pre><code>$ stack test
haskell-and-elm-0.1.0.0: test (suite: generate)

Writing: elm-src/Generated/TodoAPI.elm</code></pre>
<p>生成されたファイルは<a href="https://github.com/matsubara0507/haskell-and-elm/blob/unuse-extensible/elm-src/Generated/TodoAPI.elm">コチラ</a>(長いので載せない)．</p>
<h4 id="elm-の準備">Elm の準備</h4>
<p>さていよいよ Elm を手書きしよう． <code>elm-src/Generated/TodoAPI.elm</code> というファイルを生成していたので，<code>elm-src/Main.elm</code> というパスで <code>Main</code> ファイルを書く． 以下のような <code>elm-package.json</code> を用意する．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb19-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb19-2" title="2">    <span class="dt">&quot;version&quot;</span><span class="fu">:</span> <span class="st">&quot;0.1.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="dt">&quot;summary&quot;</span><span class="fu">:</span> <span class="st">&quot;Sample for haskell and elm&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="dt">&quot;repository&quot;</span><span class="fu">:</span> <span class="st">&quot;https://github.com/yourname/haskell-and-elm.git&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-5" title="5">    <span class="dt">&quot;license&quot;</span><span class="fu">:</span> <span class="st">&quot;MIT&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="dt">&quot;source-directories&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb19-7" title="7">        <span class="st">&quot;elm-src&quot;</span></a>
<a class="sourceLine" id="cb19-8" title="8">    <span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-9" title="9">    <span class="dt">&quot;exposed-modules&quot;</span><span class="fu">:</span> <span class="ot">[]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-10" title="10">    <span class="dt">&quot;dependencies&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb19-11" title="11">        <span class="dt">&quot;elm-lang/core&quot;</span><span class="fu">:</span> <span class="st">&quot;5.1.1 &lt;= v &lt; 6.0.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-12" title="12">        <span class="dt">&quot;elm-lang/html&quot;</span><span class="fu">:</span> <span class="st">&quot;2.0.0 &lt;= v &lt; 3.0.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-13" title="13">        <span class="dt">&quot;elm-lang/http&quot;</span><span class="fu">:</span> <span class="st">&quot;1.0.0 &lt;= v &lt; 2.0.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-14" title="14">        <span class="dt">&quot;elm-lang/navigation&quot;</span><span class="fu">:</span> <span class="st">&quot;2.0.0 &lt;= v &lt; 3.0.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-15" title="15">        <span class="dt">&quot;elm-community/json-extra&quot;</span><span class="fu">:</span> <span class="st">&quot;2.0.0 &lt;= v &lt; 3.0.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-16" title="16">        <span class="dt">&quot;elm-community/list-extra&quot;</span><span class="fu">:</span> <span class="st">&quot;6.0.0 &lt;= v &lt; 7.0.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-17" title="17">        <span class="dt">&quot;Bogdanp/elm-route&quot;</span><span class="fu">:</span> <span class="st">&quot;4.0.0 &lt;= v &lt; 5.0.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-18" title="18">        <span class="dt">&quot;krisajenkins/remotedata&quot;</span><span class="fu">:</span> <span class="st">&quot;4.3.0 &lt;= v &lt; 5.0.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb19-19" title="19">        <span class="dt">&quot;NoRedInk/elm-decode-pipeline&quot;</span><span class="fu">:</span> <span class="st">&quot;3.0.0 &lt;= v &lt; 4.0.0&quot;</span></a>
<a class="sourceLine" id="cb19-20" title="20">    <span class="fu">},</span></a>
<a class="sourceLine" id="cb19-21" title="21">    <span class="dt">&quot;elm-version&quot;</span><span class="fu">:</span> <span class="st">&quot;0.18.0 &lt;= v &lt; 0.19.0&quot;</span></a>
<a class="sourceLine" id="cb19-22" title="22"><span class="fu">}</span></a></code></pre></div>
<h4 id="モデルとメッセージの型">モデルとメッセージの型</h4>
<p>まずはモデル(フロントが持つべき状態)から．</p>
<p>あまり Elm の流儀を知らないが，HTTPリクエストのように外部から取得するデータは，<a href="http://package.elm-lang.org/packages/krisajenkins/remotedata/latest">remotedata</a> パッケージの <a href="http://package.elm-lang.org/packages/krisajenkins/remotedata/4.3.3/RemoteData#RemoteData"><code>RemoteData</code></a> 型のようなデータ構造を使う(？)</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">module</span> <span class="dt">Main</span> exposing (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="kw">import</span> <span class="dt">Generated.TodoAPI</span> <span class="kw">as</span> <span class="dt">API</span> exposing (<span class="dt">Todo</span>)</a>
<a class="sourceLine" id="cb20-4" title="4"><span class="kw">import</span> <span class="dt">RemoteData</span> exposing (<span class="dt">RemoteData</span>(..))</a>
<a class="sourceLine" id="cb20-5" title="5"></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="kw">type</span> alias <span class="dt">Model</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-7" title="7">  { todos <span class="fu">:</span> <span class="dt">RemoteData</span> <span class="dt">String</span> (<span class="dt">List</span> <span class="dt">API.Todo</span>)</a>
<a class="sourceLine" id="cb20-8" title="8">  , title <span class="fu">:</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb20-9" title="9">  }</a></code></pre></div>
<p><code>title</code> フィールドは ToDo タスクを追加するときに使うテキストボックスの値だ．</p>
<p>次に <code>Msg</code> を考える． <code>Msg</code> はフロントで起こり得る状態変化のパターンを考えればよい(んだよね？)．</p>
<p>今回は以下の4つがしたかった．</p>
<ol type="1">
<li>ToDo タスクを全て取得</li>
<li>ToDo タスクの追加(テキストボックス)</li>
<li>ToDo タスクを完了する(チェックボックス)</li>
<li>ToDo タスクの削除(ボタンを押す)</li>
</ol>
<p>(2)は更に細分化されて，「テキストボックスの入力」と「追加ボタンを押す」がある． また，追加や削除をした後に，(あんまり賢くないが)画面をリロードして再度 ToDo タスクを取得してくるべきだろう．</p>
<p>以上から以下のような <code>Msg</code> を定義すればよい(全部で6種類のパターンがある)．</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">type</span> <span class="dt">Msg</span></a>
<a class="sourceLine" id="cb21-2" title="2">    <span class="fu">=</span> <span class="dt">FetchTodos</span> (<span class="dt">Result</span> <span class="dt">Http.Error</span> (<span class="dt">List</span> <span class="dt">API.Todo</span>))</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="fu">|</span> <span class="dt">Reload</span></a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="fu">|</span> <span class="dt">ChangeTodo</span> <span class="dt">Todo</span></a>
<a class="sourceLine" id="cb21-5" title="5">    <span class="fu">|</span> <span class="dt">Title</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb21-6" title="6">    <span class="fu">|</span> <span class="dt">Push</span> <span class="dt">Button</span></a>
<a class="sourceLine" id="cb21-7" title="7"></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="kw">type</span> <span class="dt">Button</span></a>
<a class="sourceLine" id="cb21-9" title="9">    <span class="fu">=</span> <span class="dt">Post</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb21-10" title="10">    <span class="fu">|</span> <span class="dt">Delete</span> <span class="dt">Int</span></a></code></pre></div>
<h4 id="トップダウンに書いていく">トップダウンに書いていく</h4>
<p>型はできたので，あとはトップダウンに作っていこう．</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1">main <span class="fu">:</span> <span class="dt">Program</span> <span class="dt">Never</span> <span class="dt">Model</span> <span class="dt">Msg</span></a>
<a class="sourceLine" id="cb22-2" title="2">main <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-3" title="3">    Html.program</a>
<a class="sourceLine" id="cb22-4" title="4">        { <span class="fu">init</span> <span class="fu">=</span> <span class="fu">init</span> model</a>
<a class="sourceLine" id="cb22-5" title="5">        , view <span class="fu">=</span> view</a>
<a class="sourceLine" id="cb22-6" title="6">        , update <span class="fu">=</span> update</a>
<a class="sourceLine" id="cb22-7" title="7">        , subscriptions <span class="fu">=</span> \_ <span class="ot">-&gt;</span> Sub.none</a>
<a class="sourceLine" id="cb22-8" title="8">        }</a>
<a class="sourceLine" id="cb22-9" title="9"></a>
<a class="sourceLine" id="cb22-10" title="10">model <span class="fu">:</span> <span class="dt">Model</span></a>
<a class="sourceLine" id="cb22-11" title="11">model <span class="fu">=</span> <span class="fu">undefined</span> ()</a>
<a class="sourceLine" id="cb22-12" title="12"></a>
<a class="sourceLine" id="cb22-13" title="13"><span class="fu">init</span> <span class="fu">:</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> ( <span class="dt">Model</span>, <span class="dt">Cmd</span> <span class="dt">Msg</span> )</a>
<a class="sourceLine" id="cb22-14" title="14"><span class="fu">init</span> model <span class="fu">=</span> <span class="fu">undefined</span> ()</a>
<a class="sourceLine" id="cb22-15" title="15"></a>
<a class="sourceLine" id="cb22-16" title="16">view <span class="fu">:</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Html</span> <span class="dt">Msg</span></a>
<a class="sourceLine" id="cb22-17" title="17">view model <span class="fu">=</span> <span class="fu">undefined</span> ()</a>
<a class="sourceLine" id="cb22-18" title="18"></a>
<a class="sourceLine" id="cb22-19" title="19">update <span class="fu">:</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> ( <span class="dt">Model</span>, <span class="dt">Cmd</span> <span class="dt">Msg</span> )</a>
<a class="sourceLine" id="cb22-20" title="20">update msg model <span class="fu">=</span> <span class="fu">undefined</span> ()</a>
<a class="sourceLine" id="cb22-21" title="21"></a>
<a class="sourceLine" id="cb22-22" title="22"><span class="fu">undefined</span> <span class="fu">:</span> () <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb22-23" title="23"><span class="fu">undefined</span> _ <span class="fu">=</span> Debug.crash <span class="st">&quot;undefined...&quot;</span></a></code></pre></div>
<p>まずは <code>main</code> 関数だけ書いた． Haskell でいう <code>undefined</code> という値が Elm では見つからなかったので自分で <code>undefined</code> という関数を定義した(Elm は正格評価なので関数にして遅延させないといけない)． (<code>undefind</code> が標準にない事から)Elm ではあまりなじみが無いのかもしれないが，Haskell (というか関数型プログラミング)ではまずは型だけ書いてトップから順に実装を書き加えていくのがセオリー(だよね？)．</p>
<p>まずはこれでビルドしてみる．</p>
<pre><code>$ elm make elm-src/Main.elm --output=static/main.js
Success! Compiled 1 module.
Successfully generated static/main.js</code></pre>
<p><code>index.html</code> を書いてなかったので適当に書いておく．</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">&lt;head&gt;</span></a>
<a class="sourceLine" id="cb24-2" title="2">  <span class="kw">&lt;link</span><span class="ot"> rel=</span><span class="st">&quot;stylesheet&quot;</span><span class="ot"> type=</span><span class="st">&quot;text/css&quot;</span><span class="ot"> href=</span><span class="st">&quot;https://cdnjs.cloudflare.com/ajax/libs/Primer/10.0.0-rc.21/build.css&quot;</span><span class="ot"> media=</span><span class="st">&quot;all&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb24-3" title="3">  <span class="kw">&lt;link</span><span class="ot"> rel=</span><span class="st">&quot;stylesheet&quot;</span><span class="ot"> type=</span><span class="st">&quot;text/css&quot;</span><span class="ot"> href=</span><span class="st">&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css&quot;</span><span class="ot"> media=</span><span class="st">&quot;all&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="kw">&lt;/head&gt;</span></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;main&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;static/main.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span></a>
<a class="sourceLine" id="cb24-7" title="7"><span class="kw">&lt;script&gt;</span></a>
<a class="sourceLine" id="cb24-8" title="8">  <span class="kw">var</span> node <span class="op">=</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">'main'</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb24-9" title="9">  <span class="kw">var</span> app <span class="op">=</span> <span class="va">Elm</span>.<span class="va">Main</span>.<span class="at">embed</span>(node)<span class="op">;</span></a>
<a class="sourceLine" id="cb24-10" title="10"><span class="kw">&lt;/script&gt;</span></a></code></pre></div>
<p>もう一度サーバーを立てて <code>localhost:8080</code> にアクセスしてみる． もちろん，真っ白で <code>Uncaught Error: Ran into a Debug.crash in module Main on line 68</code> というエラーメッセージが出るだけなんだが(笑)</p>
<h2 id="section-3"></h2>
<p><code>model</code> 式はただの初期値で，<code>init</code> 関数はただの初期化関数だ．</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1">model <span class="fu">:</span> <span class="dt">Model</span></a>
<a class="sourceLine" id="cb25-2" title="2">model <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-3" title="3">    { todos <span class="fu">=</span> <span class="dt">NotAsked</span>, title <span class="fu">=</span> <span class="st">&quot;&quot;</span> }</a>
<a class="sourceLine" id="cb25-4" title="4"></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="fu">init</span> <span class="fu">:</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> ( <span class="dt">Model</span>, <span class="dt">Cmd</span> <span class="dt">Msg</span> )</a>
<a class="sourceLine" id="cb25-6" title="6"><span class="fu">init</span> model <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-7" title="7">    ( model, fetchTodos )</a>
<a class="sourceLine" id="cb25-8" title="8"></a>
<a class="sourceLine" id="cb25-9" title="9">fetchTodos <span class="fu">:</span> <span class="dt">Cmd</span> <span class="dt">Msg</span></a>
<a class="sourceLine" id="cb25-10" title="10">fetchTodos <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-11" title="11">    Http.send <span class="dt">FetchTodos</span> API.getTodos</a></code></pre></div>
<p>まず最初に ToDo タスクを全て取得してくる必要があるので，<code>http://localhost:8080/todos</code> を叩く HTTP リクエストを呼んでいる．</p>
<p><code>view</code> 関数は泥臭くなるので割愛(<a href="https://github.com/matsubara0507/haskell-and-elm/blob/unuse-extensible/elm-src/Main.elm#L50">コードを見てね</a>)．</p>
<p><code>update</code> 関数は次のようになる</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1">update <span class="fu">:</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> ( <span class="dt">Model</span>, <span class="dt">Cmd</span> <span class="dt">Msg</span> )</a>
<a class="sourceLine" id="cb26-2" title="2">update msg model <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-3" title="3">  <span class="kw">case</span> msg <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-4" title="4">    <span class="dt">FetchTodos</span> (<span class="dt">Ok</span> todos) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-5" title="5">      ( { model <span class="fu">|</span> todos <span class="fu">=</span> <span class="dt">Success</span> todos }, Cmd.none )</a>
<a class="sourceLine" id="cb26-6" title="6">    <span class="dt">FetchTodos</span> (<span class="dt">Err</span> _) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-7" title="7">      ( { model <span class="fu">|</span> todos <span class="fu">=</span> <span class="dt">Failure</span> <span class="st">&quot;Something went wrong..&quot;</span> }, Cmd.none )</a>
<a class="sourceLine" id="cb26-8" title="8">    <span class="dt">ChangeTodo</span> todo <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-9" title="9">      ( model, changeTodo todo )</a>
<a class="sourceLine" id="cb26-10" title="10">    <span class="dt">Title</span> title <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-11" title="11">      ( { model <span class="fu">|</span> title <span class="fu">=</span> title }, Cmd.none )</a>
<a class="sourceLine" id="cb26-12" title="12">    <span class="dt">Push</span> (<span class="dt">Post</span> title) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-13" title="13">      ( model, addTodo <span class="fu">&lt;|</span> <span class="dt">Todo</span> <span class="dv">0</span> title <span class="dt">False</span> )</a>
<a class="sourceLine" id="cb26-14" title="14">    <span class="dt">Push</span> (<span class="dt">Delete</span> todoId) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-15" title="15">      ( model, removeTodo todoId )</a>
<a class="sourceLine" id="cb26-16" title="16">    <span class="dt">Reload</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-17" title="17">      ( model, fetchTodos )</a>
<a class="sourceLine" id="cb26-18" title="18"></a>
<a class="sourceLine" id="cb26-19" title="19">changeTodo <span class="fu">:</span> <span class="dt">Todo</span> <span class="ot">-&gt;</span> <span class="dt">Cmd</span> <span class="dt">Msg</span></a>
<a class="sourceLine" id="cb26-20" title="20">changeTodo todo <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-21" title="21">  Http.send (always <span class="dt">Reload</span>) (API.putTodosById todo<span class="fu">.</span>todoId todo)</a>
<a class="sourceLine" id="cb26-22" title="22"></a>
<a class="sourceLine" id="cb26-23" title="23"></a>
<a class="sourceLine" id="cb26-24" title="24">addTodo <span class="fu">:</span> <span class="dt">Todo</span> <span class="ot">-&gt;</span> <span class="dt">Cmd</span> <span class="dt">Msg</span></a>
<a class="sourceLine" id="cb26-25" title="25">addTodo todo <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-26" title="26">  Http.send (always <span class="dt">Reload</span>) (API.postTodos todo)</a>
<a class="sourceLine" id="cb26-27" title="27"></a>
<a class="sourceLine" id="cb26-28" title="28"></a>
<a class="sourceLine" id="cb26-29" title="29">removeTodo <span class="fu">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cmd</span> <span class="dt">Msg</span></a>
<a class="sourceLine" id="cb26-30" title="30">removeTodo todoId <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-31" title="31">  Http.send (always <span class="dt">Reload</span>) (API.deleteTodosById todoId)</a></code></pre></div>
<p>各種 HTTP レスポンスのラッパー関数を用意して，対応する <code>Msg</code> で読んでいるだけだ． ただし，GET 以外の HTTP レスポンスが完了したときに，再度 ToDo タスクを読み込むよう <code>always Reload</code> という <code>Msg</code> 生成関数を渡している． ちなみに，<code>Todo</code> 型の <code>todoId</code> はサーバーサイドで勝手に書き換えるので，POST するときは <code>0</code> で良い．</p>
<h2 id="section-4"></h2>
<p>これで完成</p>
<h2 id="実行">実行</h2>
<p><img src="../assets/create-haskell-and-elm/sample.gif" /></p>
<h2 id="おまけ">おまけ</h2>
<p>いちいち，Elm をビルドしたり，Haskell ビルドしたり，サーバー起動したりめんどくさいよね． そこで <code>app/Generate.hs</code> の <code>main</code> 関数に以下を記述して</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb27-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb27-3" title="3">  shelly <span class="fu">$</span> mkdir_p <span class="st">&quot;elm-src/Generated&quot;</span></a>
<a class="sourceLine" id="cb27-4" title="4">  specsToDir [spec] <span class="st">&quot;elm-src&quot;</span></a>
<a class="sourceLine" id="cb27-5" title="5">  <span class="co">-- ココから</span></a>
<a class="sourceLine" id="cb27-6" title="6">  shelly <span class="fu">$</span></a>
<a class="sourceLine" id="cb27-7" title="7">    run_ <span class="st">&quot;elm-make&quot;</span> [<span class="st">&quot;elm-src/Main.elm&quot;</span>, <span class="st">&quot;--output=static/main.js&quot;</span>]</a></code></pre></div>
<p><code>stack test --file-watch</code> と <code>stack exec server</code> を起動しておくと，勝手にどんどん更新される．</p>
<h2 id="おしまい">おしまい</h2>
<p>長くなってしまった． しかもほとんど Haskell のハナシ… Elm のカレンダーなのに…すいません…</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
