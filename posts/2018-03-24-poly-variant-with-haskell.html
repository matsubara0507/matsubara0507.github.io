<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="多相バリアントを使いこなそう with Haskell" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        多相バリアントを使いこなそう with Haskell
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">多相バリアントを使いこなそう with Haskell</h1>
    <p class="post-meta">
      <time datetime="2018-03-24" itemprop="datePublished">
        Mar 24, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="../tags/Haskell.html">Haskell</a> <a href="../tags/extensible-package.html">extensible-package</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://sampou.connpass.com/event/80492/">この前の「『Haskellによる関数プログラミングの思考法』読書会」</a>の後の懇親会(？)で <strong>多相バリアント</strong> の話になりまして，その時に以下の記事が話題にあがった．</p>
<ul>
<li><a href="http://osiire.hatenablog.com/entry/20090510/1241957550">多相バリアントを使いこなそう(1) - osiire’s blog</a></li>
<li><a href="http://osiire.hatenablog.com/entry/20090512/1242055541">多相バリアントを使いこなそう(2) - osiire’s blog</a></li>
<li><a href="http://osiire.hatenablog.com/entry/20090514/1242235108">多相バリアントを使いこなそう(3) - osiire’s blog</a></li>
<li><a href="http://osiire.hatenablog.com/entry/20090516/1242456737">多相バリアントを使いこなそう(4) - osiire’s blog</a></li>
</ul>
<p>これらの記事は OCaml で多相バリアントの紹介をしています． ということで，同様の議論を Haskell でもしてみた！というのが，この記事の内容です．</p>
<h2 id="section"></h2>
<p>(2018.04.13 追記アリ)</p>
<h3 id="haskell-と多相バリアント">Haskell と多相バリアント</h3>
<p>悲しいことに，Haskell には組み込みで多相バリアントは無い(バリアントとは Haskell の代数的データ型における直和型と概ね一緒)． なので，多相バリアントを Haskell で模倣するために，毎度おなじみ <a href="https://hackage.haskell.org/package/extensible"><code>extensible</code></a> パッケージを用いる．</p>
<h2 id="section-1"></h2>
<p>ネタバレをすると Haskell で同じことをするのは難しかった． なので，本質的な議論は osiire’s blog の方を読んだ方がいいと思うよ． 結局，本記事は osiire’s blog のと同様のことを Haskell もとい，<code>extensible</code> パッケージでどのように行うか，という記事って感じになった．</p>
<h2 id="多相バリアントの基本">多相バリアントの基本</h2>
<p>多相バリアントとは，名前の通り，多相的なバリアントである． バリアントは前述したとおり，直和型と基本的に同じ．</p>
<p>例えば，普通の直和型として次のようなものがあったとする．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Joker</span> <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span> <span class="dt">InData</span> <span class="fu">=</span> <span class="dt">Str</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Int</span></a></code></pre></div>
<p>「最初の型はジョーカーと数字札があるトランプの型，次の型は何かファイルからデータを読み込む時に文字列と数字のデータを統一的に扱うための型」だそうです(<a href="http://osiire.hatenablog.com/entry/20090510/1241957550">多相バリアントを使いこなそう(1)</a> より)． どちらの型にも <code>Number Int</code> という部分があるので次のような関数を両方に適用できそうな気がする．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">getNumber (<span class="dt">Number</span> n) <span class="fu">=</span> <span class="dt">Just</span> n</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">getNumber _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>もちろん，そんなことはできない(そもそも，Haskell の値コンストラクタは名前空間を共有してしまうので同時に利用はできないのだが…)． そこで多相バリアントを用いれば，このような関数を実装することが出来るようになる．</p>
<h3 id="多相バリアントを定義">多相バリアントを定義</h3>
<p><code>extensible</code> パッケージを使って多相バリアント(拡張可能バリアント)を定義すると次のようになる(<code>DataKinds</code> と <code>TypeOperators</code> 言語拡張が必要)．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="ch">'[ &quot;joker&quot; &gt;: (), &quot;number&quot; &gt;: Int ]</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">type</span> <span class="dt">InData</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="ch">'[ &quot;str&quot; &gt;: String, &quot;number&quot; &gt;: Int ]</span></a></code></pre></div>
<p>とくに細かい説明はしないが，なんとなく意味が読み取れるだろう． <code>getNumber</code> 関数の実装は難しいので後回しにするとして，<code>getNumber</code> 関数の型は <code>extensible</code> パッケージの <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#t:-8838-"><code>⊆</code></a> 型クラスを用いて次のように書ける(意味は見た通り)．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">getNumber ::</span> (<span class="ch">'[&quot;number&quot; &gt;: Int] ⊆ xs) =&gt; Variant xs -&gt; Maybe Int</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">getNumber <span class="fu">=</span> undefined</a></code></pre></div>
<p>GHCi で試してみる．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t getNumber (undefined<span class="ot"> ::</span> <span class="dt">Card</span>)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">getNumber (undefined<span class="ot"> ::</span> <span class="dt">Card</span>)<span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t getNumber (undefined<span class="ot"> ::</span> <span class="dt">InData</span>)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">getNumber (undefined<span class="ot"> ::</span> <span class="dt">InData</span>)<span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a></code></pre></div>
<p>確かに動作する．</p>
<h2 id="包含関係">包含関係</h2>
<p>さて，<code>getNumber</code> 関数をどのように実装するかだが，その前に多相バリアントの包含関係を議論しておく(この議論は<a href="http://osiire.hatenablog.com/entry/20090514/1242235108">多相バリアントを使いこなそう(3)</a>に対応する)．</p>
<p>次のような簡単なバリアント型を考える．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Hoge</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">HogeFields</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">type</span> <span class="dt">HogeFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="ch">'[ &quot;hoge&quot; &gt;: ()</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">   , <span class="st">&quot;fuga&quot;</span> <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">   ]</a></code></pre></div>
<p>このバリアント型に対し，<code>⊆</code> を用いて多相的な関数は2種類考えれる．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">toInt1 ::</span> (<span class="dt">HogeFields</span> ⊆ xs) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">toInt1 <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="ot">toInt2 ::</span> (xs ⊆ <span class="dt">HogeFields</span>) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">toInt2 <span class="fu">=</span> undefined</a></code></pre></div>
<p><code>toInt1</code> は <code>&quot;hoge&quot; &gt;: ()</code> と <code>&quot;fuga&quot; &gt;: ()</code> を要素に持つバリアント型全てが利用できる関数である(さっきの <code>getNumber</code> と同じ)． <code>toInt2</code> は <code>&quot;hoge&quot; &gt;: ()</code> か <code>&quot;fuga&quot; &gt;: ()</code> のどれかを要素に持つ(それ以外は持ってはいけない)バリアント型全てに利用できる関数である． 試しに，次の3つのバリアント型の値を定義し，GHCi で試してみよう．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">hoge1 ::</span> <span class="dt">Hoge</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">hoge1 <span class="fu">=</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>hoge <span class="fu">@=</span> ()</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">hoge2 ::</span> <span class="dt">Variant</span> (<span class="st">&quot;piyo&quot;</span> <span class="fu">&gt;:</span> () <span class="ch">': HogeFields)</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">hoge2 <span class="fu">=</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>piyo <span class="fu">@=</span> ()</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">hoge3 ::</span> <span class="dt">Variant</span> <span class="ch">'[&quot;hoge&quot; &gt;: ()]</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">hoge3 <span class="fu">=</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>hoge <span class="fu">@=</span> ()</a></code></pre></div>
<p>見てわかるように(？)，<code>hoge3 ⊆ hoge1 ⊆ hoge2</code> である(厳密にはバリアントの要素の集合で成り立つ関係だが)．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt1 hoge1</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">toInt1<span class="ot"> hoge1 ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt1 hoge2</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">toInt1<span class="ot"> hoge2 ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt1 hoge3</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    <span class="fu">?</span> <span class="dt">Couldn't</span> match <span class="kw">type</span> ‘<span class="ch">'Missing (&quot;fuga&quot; '</span><span class="fu">:&gt;</span> ())’</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">                     with ‘<span class="ch">'Expecting pos0’</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        arising from a use <span class="kw">of</span> ‘toInt1’</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    <span class="fu">?</span> <span class="dt">In</span> the expression<span class="fu">:</span> toInt1 hoge3</a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt2 hoge1</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">toInt2<span class="ot"> hoge1 ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt2 hoge2</a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    <span class="fu">?</span> <span class="dt">Couldn't</span> match <span class="kw">type</span> ‘<span class="ch">'Missing (&quot;piyo&quot; '</span><span class="fu">:&gt;</span> ())’</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">                     with ‘<span class="ch">'Expecting pos0’</span></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">        arising from a use <span class="kw">of</span> ‘toInt2’</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">    <span class="fu">?</span> <span class="dt">In</span> the expression<span class="fu">:</span> toInt2 hoge2</a>
<a class="sourceLine" id="cb9-21" data-line-number="21"><span class="fu">&gt;&gt;</span> <span class="fu">:</span>t toInt2 hoge3</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">toInt2<span class="ot"> hoge3 ::</span> <span class="dt">Int</span></a></code></pre></div>
<p>確かに，<code>toInt1</code> は <code>hoge1</code> と <code>hoge2</code> に適用でき，<code>toInt2</code> は <code>hoge1</code> と <code>hoge3</code> に適用できている．</p>
<h2 id="section-2"></h2>
<p>さて，<code>toInt1</code> と <code>toInt2</code> の実装を与えてみる． 実は簡単なのは後者 <code>toInt2</code> だ．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">toInt2 ::</span> (xs ⊆ <span class="dt">HogeFields</span>) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">toInt2 <span class="fu">=</span> flip matchField (spread<span class="ot"> xs ::</span> <span class="dt">Hoge</span>)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="fu">$</span> <span class="fu">#</span>hoge <span class="fu">@=</span> (const <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">   <span class="fu">&lt;:</span> <span class="fu">#</span>fuga <span class="fu">@=</span> (const <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">   <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p>(<a href="https://matsubara0507.github.io/posts/2017-11-28-fun-of-extensible-1.html">昔の記事</a>でも紹介した) <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#v:spread"><code>spread</code></a> 関数を用いることで <strong>バリアント型を拡張できる</strong> (<a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"><code>matchField</code></a> 関数の使い方についてはこの<a href="https://matsubara0507.github.io/posts/2018-01-31-fun-of-extensible-2.html">記事</a>を参照して)．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">shrink ::</span> (xs ⊆ ys) <span class="ot">=&gt;</span> <span class="dt">Record</span> ys <span class="ot">-&gt;</span> <span class="dt">Record</span> xs</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">spread ::</span> (xs ⊆ ys) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Variant</span> ys</a></code></pre></div>
<p><del>拡縮する関数 <code>spread</code> や <code>shrink</code> は強力なのだが，多相的すぎて前後の型が分からないとエラーになる(気がする(パッケージの作者じゃないので細かいことはよくわからん))ので，型注釈 (<code>spread xs :: Hoge</code> の部分)を与える必要がある．</del></p>
<p>(2018.04.13 追記) <code>spread</code> や <code>shrink</code> の代わりに <code>shrinkAssoc</code> や <code>spreadAssoc</code> を使えば値が多相でもうまく扱えるとのコトを<a href="https://www.reddit.com/r/haskell_jp/comments/86rx9b/多相バリアントを使いこなそう_with_haskell/dwaq3cw/">作者様よりコメント</a>いただいた． 感謝．</p>
<h3 id="必殺-coinclusion">必殺 Coinclusion</h3>
<p>前者が難しいのは，<code>spread</code> や <code>shrink</code> とは逆の振る舞いを要求するからだ． そのために(この前作者から教えてもらった隠し技(別に隠してない)) <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Nullable.html"><code>Nullable</code></a> を使う！ <code>Nullable</code> を使うとバリアントやレコードの全ての要素を簡単に <code>Maybe</code> でラップできる(なんかいいテーマがあったら，そのうち解説する)． さらに <code>Nullable</code> を用いることで，Coinclusion を定義できる！</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">wrench ::</span> (<span class="dt">Generate</span> ys, xs ⊆ ys) <span class="ot">=&gt;</span> (h <span class="fu">:*</span> xs) <span class="ot">-&gt;</span> <span class="dt">Nullable</span> h <span class="fu">:*</span> ys</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">retrench ::</span> (<span class="dt">Generate</span> ys, xs ⊆ ys) <span class="ot">=&gt;</span> (h <span class="fu">:|</span> ys) <span class="ot">-&gt;</span> <span class="dt">Nullable</span> ((<span class="fu">:|</span>) h) xs</a></code></pre></div>
<p><code>wrench</code> や <code>retrench</code> は <code>shrink</code> と <code>spread</code> の逆向きの変換になっているのが分かるだろうか？ 逆向きにしたせいで足りない部分は <code>Nullable</code> によって <code>Nothing</code> となる． 例えば <code>Variant (&quot;piyo&quot; &gt;: () ': HogeFields)</code> から <code>Hoge</code> に縮小する場合は，<code>embedAssoc (#piyo @= ())</code> が <code>Nothing</code> となり，他が <code>Just</code> でラップされる．</p>
<h2 id="section-3"></h2>
<p>Coinclusion を用いて <code>toInt2</code> 関数を実装してみると次のようになる．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">{-# LANGUAGE PolyKinds           #-}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">{-# LANGUAGE RankNTypes          #-}</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ot">toInt1 ::</span> (<span class="dt">Generate</span> xs, <span class="dt">HogeFields</span> ⊆ xs) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">toInt1 <span class="fu">=</span> matchFieldWithDefault <span class="dv">0</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="fu">$</span> <span class="fu">#</span>hoge <span class="fu">@=</span> (const <span class="dv">1</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">   <span class="fu">&lt;:</span> <span class="fu">#</span>fuga <span class="fu">@=</span> (const <span class="dv">2</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="ot">matchFieldWithDefault ::</span> forall xs ys h r <span class="fu">.</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  (<span class="dt">Generate</span> ys, xs ⊆ ys) <span class="ot">=&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">RecordOf</span> (<span class="dt">Match</span> h r) xs <span class="ot">-&gt;</span> <span class="dt">VariantOf</span> h ys <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">matchFieldWithDefault defaultValue pat <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">  fromMaybe defaultValue <span class="fu">.</span> matchFieldWithMaybe pat</a>
<a class="sourceLine" id="cb13-15" data-line-number="15"></a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="ot">matchFieldWithMaybe ::</span> forall xs ys h r <span class="fu">.</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">  (<span class="dt">Generate</span> ys, xs ⊆ ys) <span class="ot">=&gt;</span> <span class="dt">RecordOf</span> (<span class="dt">Match</span> h r) xs <span class="ot">-&gt;</span> <span class="dt">VariantOf</span> h ys <span class="ot">-&gt;</span> <span class="dt">Maybe</span> r</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">matchFieldWithMaybe pat <span class="fu">=</span> matchWith func (wrench pat)</a>
<a class="sourceLine" id="cb13-19" data-line-number="19">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="ot">    func ::</span> forall x <span class="fu">.</span> <span class="dt">Nullable</span> (<span class="dt">Field</span> (<span class="dt">Match</span> h r)) x <span class="ot">-&gt;</span> <span class="dt">Field</span> h x <span class="ot">-&gt;</span> <span class="dt">Maybe</span> r</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">    func fx gx <span class="fu">=</span> (\x <span class="ot">-&gt;</span> runMatch (getField x) <span class="fu">$</span> getField gx) <span class="fu">&lt;$&gt;</span> getNullable fx</a></code></pre></div>
<p>めんどくさいので細かい解説はしない(そもそももっといい方法があるかもしれない)． この <code>matchFieldWithMaybe</code> を用いれば <code>getNumber</code> も簡単に実装できるだろう．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">getNumber ::</span> (<span class="dt">Generate</span> xs, <span class="ch">'[&quot;number&quot; &gt;: Int] ⊆ xs) =&gt; Variant xs -&gt; Maybe Int</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">getNumber <span class="fu">=</span> matchFieldWithMaybe <span class="fu">$</span> <span class="fu">#</span>number <span class="fu">@=</span> id <span class="fu">&lt;:</span> nil</a></code></pre></div>
<h2 id="例-イベントを拡張する">例 : イベントを拡張する</h2>
<p>ここからは「多相バリアントを使いこなそう」で取り上げられてた例を Haskell で示そう． ひとつ目は次のふたつのイベント型を考える．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">type</span> <span class="dt">KeyboardEvent</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">KeyboardEventFields</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">type</span> <span class="dt">KeyboardEventFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ch">'[ &quot;keyPress&quot; &gt;: Char</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">   , <span class="st">&quot;keyRelease&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   ]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">type</span> <span class="dt">MouseEvent</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">MouseEventFields</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="kw">type</span> <span class="dt">MouseEventFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="ch">'[ &quot;mousePress&quot; &gt;: (Int, Int)</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">   , <span class="st">&quot;mouseRelease&quot;</span> <span class="fu">&gt;:</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">   , <span class="st">&quot;click&quot;</span> <span class="fu">&gt;:</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">   ]</a></code></pre></div>
<p>さて，これらの両方の型許容する型 <code>Event</code> を作りたい． 普通の直和型を用いて次のように書くことが出来る．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Event</span> <span class="fu">=</span> <span class="dt">Key</span> <span class="dt">KeyboardEvent</span> <span class="fu">|</span> <span class="dt">Mouse</span> <span class="dt">MouseEvent</span></a></code></pre></div>
<p>もちろん，これでは元のふたつの型をうまく再利用できていない． 既に何度か登場している型レベルリストの連結 <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#t:-43--43-"><code>++</code></a> を使って次のように書くこともできる．</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Event</span> <span class="fu">=</span> <span class="dt">Variant</span> (<span class="dt">KeyboardEventFields</span> <span class="fu">++</span> <span class="dt">MouseEventFields</span>)</a></code></pre></div>
<p>こうすると，<code>Event</code> 型と <code>KeyboardEvent</code> 型・<code>MouseEvent</code> 型には包含関係ができ，前述した <code>Hoge</code> 型で示した方法により各々で関数を共有することが出来る． 例えば次の <code>getCharFromEvent</code> 関数は <code>KeyboardEvent</code> 型と <code>Event</code> 型の両方で利用できる．</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">getCharFromEvent ::</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  (<span class="dt">Generate</span> xs, <span class="dt">KeyboardEventFields</span> ⊆ xs) <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">getCharFromEvent <span class="fu">=</span> matchFieldWithDefault (error <span class="st">&quot;not a key&quot;</span>)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="fu">$</span> <span class="fu">#</span>keyPress   <span class="fu">@=</span> id</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">   <span class="fu">&lt;:</span> <span class="fu">#</span>keyRelease <span class="fu">@=</span> id</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">   <span class="fu">&lt;:</span> nil</a></code></pre></div>
<h2 id="例-トランプで-expression-problem">例 : トランプで Expression Problem</h2>
<p>Expression Problem が何なのかは各位ググってもらうとして，「多相バリアントを使いこなそう」の最後で紹介されていた，多相バリアントによる Expression Problem の解法を Haskell でもやってみる．</p>
<p>次のような型と関数があったとする．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">CardFields</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="kw">type</span> <span class="dt">CardFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="ch">'[ &quot;number&quot; &gt;: Int</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">   , <span class="st">&quot;jack&quot;</span>   <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">   , <span class="st">&quot;queen&quot;</span>  <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">   , <span class="st">&quot;king&quot;</span>   <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">   ]</a>
<a class="sourceLine" id="cb19-8" data-line-number="8"></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">cardNum ::</span> <span class="dt">Card</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">cardNum <span class="fu">=</span> matchField cardNumPattern</a>
<a class="sourceLine" id="cb19-11" data-line-number="11"></a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="ot">cardNumPattern ::</span> <span class="dt">RecordOf</span> (<span class="dt">Match</span> <span class="dt">Identity</span> <span class="dt">Int</span>) <span class="dt">CardFields</span></a>
<a class="sourceLine" id="cb19-13" data-line-number="13">cardNumPattern</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    <span class="fu">=</span> <span class="fu">#</span>number <span class="fu">@=</span> id</a>
<a class="sourceLine" id="cb19-15" data-line-number="15">   <span class="fu">&lt;:</span> <span class="fu">#</span>jack   <span class="fu">@=</span> const <span class="dv">11</span></a>
<a class="sourceLine" id="cb19-16" data-line-number="16">   <span class="fu">&lt;:</span> <span class="fu">#</span>queen  <span class="fu">@=</span> const <span class="dv">12</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17">   <span class="fu">&lt;:</span> <span class="fu">#</span>king   <span class="fu">@=</span> const <span class="dv">13</span></a>
<a class="sourceLine" id="cb19-18" data-line-number="18">   <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p>(<code>cardNumPattern</code> を切り出しているのがあからさまに恣意的だが…)これに以下のことは可能だろうか？</p>
<ol type="1">
<li>静的で安全に(キャストせず)</li>
<li>元のコードを一切変更せず</li>
<li>新しい場合分けを加え</li>
<li>新しい操作も加えた</li>
<li>新しい場合分け構造を定義する</li>
</ol>
<p>最後の「構造」というのは今回は置いておいて(OCaml ではモジュールとして定義してたが，Haskell でモジュールに切り分けるにはファイルを切り分ける必要があるので…めんどい…)，1-4を考えてみよう． <code>Card</code> 型やその関数を拡張したものとして，次のような <code>CardExt</code> 型とその関数を定義した．</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">type</span> <span class="dt">CardExt</span> <span class="fu">=</span> <span class="dt">Variant</span> <span class="dt">CardExtFields</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">type</span> <span class="dt">CardExtFields</span> <span class="fu">=</span> <span class="dt">CardFields</span> <span class="fu">++</span> <span class="ch">'[&quot;joker&quot; &gt;: ()]</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">cardExtNum ::</span> <span class="dt">CardExt</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">cardExtNum <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  matchField <span class="fu">$</span> shrink (<span class="fu">#</span>joker <span class="fu">@=</span> (const <span class="dv">0</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="fu">&lt;:</span> cardNumPattern)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="ot">nextCardExt ::</span> <span class="dt">CardExt</span> <span class="ot">-&gt;</span> <span class="dt">CardExt</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">nextCardExt <span class="fu">=</span> matchField</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    <span class="fu">$</span> <span class="fu">#</span>number <span class="fu">@=</span> (\n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="fu">&lt;</span> <span class="dv">10</span> <span class="kw">then</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>number <span class="fu">@=</span> n <span class="fu">+</span> <span class="dv">1</span> <span class="kw">else</span> embedAssoc <span class="fu">$</span> <span class="fu">#</span>jack <span class="fu">@=</span> ())</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">   <span class="fu">&lt;:</span> <span class="fu">#</span>jack   <span class="fu">@=</span> const (embedAssoc <span class="fu">$</span> <span class="fu">#</span>queen  <span class="fu">@=</span> ())</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">   <span class="fu">&lt;:</span> <span class="fu">#</span>queen  <span class="fu">@=</span> const (embedAssoc <span class="fu">$</span> <span class="fu">#</span>king   <span class="fu">@=</span> ())</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">   <span class="fu">&lt;:</span> <span class="fu">#</span>king   <span class="fu">@=</span> const (embedAssoc <span class="fu">$</span> <span class="fu">#</span>joker  <span class="fu">@=</span> ())</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">   <span class="fu">&lt;:</span> <span class="fu">#</span>joker  <span class="fu">@=</span> const (embedAssoc <span class="fu">$</span> <span class="fu">#</span>number <span class="fu">@=</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">   <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p>これで一応</p>
<ol type="1">
<li>静的で安全に(もちろん!)</li>
<li>既存のコードを改造せず</li>
<li><code>&quot;joker&quot; &gt;: ()</code> という新しい場合分けを加え</li>
<li><code>nextCardExt</code> という新しい操作(関数)を加える</li>
</ol>
<p>ことができた．</p>
<h2 id="おしまい">おしまい</h2>
<p>組込みでこれらの機能がある OCaml はいいなぁとなった．</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
