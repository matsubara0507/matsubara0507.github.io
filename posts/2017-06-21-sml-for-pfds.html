<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="「純粋関数型データ構造」を読み進めるための SML/NJ Tips" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        「純粋関数型データ構造」を読み進めるための SML/NJ Tips
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">「純粋関数型データ構造」を読み進めるための SML/NJ Tips</h1>
    <p class="post-meta">
      <time datetime="2017-06-21" itemprop="datePublished">
        Jun 21, 2017
      </time>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>「<a href="http://asciidwango.jp/post/160831986220/">純粋関数型データ構造</a>」を読んでる． 中身は SML/NJ で書かれており，演習とかやってるとイロイロ調べるんで，そのまとめを．</p>
<p>正直，何番煎じだって感じですけど．</p>
<p>読み進めながら，少しずつ増やしていくつもりです．</p>
<p>(まだ，3章までしか読んでない)</p>
<h2 id="環境">環境</h2>
<p>僕は，<a href="../posts/2017-06-18-create-smlnj-kernel-for-jupyter.html">前回</a>に自分が作った <a href="https://hub.docker.com/r/matsubara0507/simple-ismlnj/">Docker イメージ</a>を使ってる．</p>
<p>その中身は <a href="http://www.smlnj.org/">SML/NJ</a> のバージョン 110.81． Docker の OS は Debian だと思う．</p>
<h2 id="tips">Tips</h2>
<h4 id="対話型処理系">対話型処理系</h4>
<p>(Docker イメージは <a href="http://jupyter.org/">Jupyter</a> なんでホントは関係ないんだけど)</p>
<p><code>sml</code> で対話型処理系が起動し，<code>Ctrl-D</code> で終了する．</p>
<p>最後に <code>;</code> が無いと処理され始めないので注意．</p>
<h4 id="サンプルコードについて">サンプルコードについて</h4>
<p>基本的なことはめんどくさいのでサンプルコードで解説</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" data-line-number="1">signature STACK =</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">sig</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">type</span> 'a <span class="dt">Stack</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">val</span> empty : 'a <span class="dt">Stack</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">val</span> isEmpty : 'a <span class="dt">Stack</span> -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">val</span> cons : 'a * 'a <span class="dt">Stack</span> -&gt; 'a <span class="dt">Stack</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="kw">val</span> head : 'a <span class="dt">Stack</span> -&gt; 'a        <span class="co">(* スタックが空なら Empty 例外を投げる *)</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="kw">val</span> tail : 'a <span class="dt">Stack</span> -&gt; 'a <span class="dt">Stack</span>  <span class="co">(* スタックが空なら Empty 例外を投げる *)</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">end</span>;</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">structure <span class="dt">List</span> : STACK =</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">struct</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="kw">type</span> 'a <span class="dt">Stack</span> = 'a <span class="dt">list</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  <span class="kw">val</span> empty = []</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  <span class="kw">fun</span> isEmpty s = null s</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  <span class="kw">fun</span> cons (x, s) = x :: s</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">  <span class="kw">fun</span> head s = hd s</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  <span class="kw">fun</span> tail s = tl s</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">end</span>;</a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">structure CustomStack : STACK =</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="kw">struct</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  datatype 'a <span class="dt">Stack</span> = NIL | CONS <span class="kw">of</span> 'a * 'a <span class="dt">Stack</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  <span class="kw">val</span> empty = NIL</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">  <span class="kw">fun</span> isEmpty NIL = <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">    | isEmpty _ = <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-27" data-line-number="27">  <span class="kw">fun</span> cons (x, s) = CONS (x, s)</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">  <span class="kw">fun</span> head NIL = <span class="dt">raise</span> Empty</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">    | head (CONS (x, s)) = x</a>
<a class="sourceLine" id="cb1-30" data-line-number="30">  <span class="kw">fun</span> tail NIL = <span class="dt">raise</span> Empty</a>
<a class="sourceLine" id="cb1-31" data-line-number="31">    | tail (CONS (x, s)) = s</a>
<a class="sourceLine" id="cb1-32" data-line-number="32"><span class="kw">end</span>;</a></code></pre></div>
<ul>
<li><code>signature</code> や <code>structure</code> ってのはモジュール
<ul>
<li><code>signature</code> はモジュールの型(インターフェース)みたいなもので</li>
<li><code>structure</code> はモジュールの値(実装)みたいなもの</li>
<li><code>signature</code> で宣言されてる型や関数や値しか <strong>外からは呼び出せない</strong></li>
<li>ちなみに <code>signature</code> を省いて <code>structure</code> だけ書くこともできる</li>
</ul></li>
<li><code>abc : 'a</code> は値(変数・関数)が <code>'a</code> 型であることを意味する</li>
<li><code>type</code> は型エイリアス</li>
<li><code>datatype</code> は代数データ型を定義する
<ul>
<li><code>CONS of ...</code> で <code>CONS</code> が <code>...</code> 型を引数に取るコンストラクタになる</li>
</ul></li>
<li><code>'a * 'b</code> は <code>'a</code> 型と <code>'b</code> 型の直積型(組型)になる
<ul>
<li>e.g. <code>(1, &quot;abc&quot;) : int * string</code></li>
</ul></li>
<li><code>-&gt;</code> は関数型で <code>'a -&gt; 'b</code> は <code>'a</code> 型を貰って <code>'b</code> 型を返すことを意味する</li>
<li><code>val</code> は変数定義</li>
<li><code>fun</code> は関数定義
<ul>
<li><code>|</code> でパターンマッチをしている</li>
</ul></li>
<li><code>'a</code> は型変数
<ul>
<li>ML系はシングルクォート <code>'</code> を付けると型変数になる</li>
</ul></li>
<li><code>type 'a Stack</code> は <code>Stack</code> 型が型変数を1つ貰うこと意味する(多相型)
<ul>
<li>Haskell と違って前に型変数が付く</li>
</ul></li>
<li><code>::</code> はリストの cons である
<ul>
<li>e.g. <code>[1] = 1 :: []</code></li>
</ul></li>
<li><code>raise</code> は例外を投げている</li>
<li><code>null</code>，<code>hd</code>，<code>tl</code> は組み込み(正確には基本モジュール)のリスト型 <code>'a list</code> の関数
<ul>
<li>ref. <a href="http://sml-family.org/Basis/list.html">The List structure - Standard ML</a></li>
<li><code>raise Empty</code> の <code>Empty</code> もリストモジュールで定義されている</li>
</ul></li>
<li><code>(* ... *)</code> はコメントアウト</li>
</ul>
<p>ちなみに，これらのモジュールは</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb2-1" data-line-number="1">- <span class="dt">List</span>.empty</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">- <span class="kw">val</span> s1 = <span class="dt">List</span>.cons (<span class="dv">1</span>, <span class="dt">List</span>.empty)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">- <span class="kw">val</span> s2 = CustomStack.cons (<span class="dv">2</span>, CustomStack.empty)</a></code></pre></div>
<p>のように使う． 前述したとおり，<code>NIL</code> や <code>CONS</code> を外から利用することはできない．</p>
<p>また，<code>List.</code> や <code>CustomStack.</code> を省きたいときは</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb3-1" data-line-number="1">- <span class="kw">open</span> <span class="dt">List</span></a></code></pre></div>
<p>とすればできるが，関数や変数のスコープが衝突することになるので注意．</p>
<h4 id="データ構造を全部表示">データ構造を全部表示</h4>
<p>例えば，ADS で定義した木構造なんかを出力すると</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb4-1" data-line-number="1">- IntTree.insert (<span class="dv">6</span>, IntTree.insert (<span class="dv">3</span>, IntTree.insert (<span class="dv">1</span>, IntTree.insert (<span class="dv">2</span>, IntTree.insert (<span class="dv">5</span>, IntTree.empty)))));</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">val</span> it = T (T (T #,<span class="dv">2</span>,T #),<span class="dv">5</span>,T (E,<span class="dv">6</span>,E)) : IntTree.<span class="dt">Set</span></a></code></pre></div>
<p>って感じで，ある以上の深さは <code>#</code> で省略されてしまう．</p>
<p>これを全部出力するためには</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb5-1" data-line-number="1">- Control.Print.printDepth := <span class="dv">100</span>;</a></code></pre></div>
<p>とすれば良い．</p>
<h5 id="ref.">ref.</h5>
<ul>
<li><a href="https://stackoverflow.com/questions/14412439/see-sml-full-list">See SML full list - Stack Overflow</a></li>
</ul>
<h4 id="スコープを制限">スコープを制限</h4>
<p>適当に <code>open</code> すると衝突するので</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb6-1" data-line-number="1">local</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">open</span> CustomStack</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">in</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">fun</span> append xs ys = <span class="kw">if</span> isEmpty xs <span class="kw">then</span> ys <span class="kw">else</span> cons (head xs, append (tail xs) ys)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">end</span>;</a></code></pre></div>
<p>とすると，<code>in ... end</code> だけでスコープを制限できる．</p>
<h4 id="ファンクター">ファンクター</h4>
<p>ファンクターはモジュール(<code>structure</code>)を生成する関数のようなモノ． Haskell の型クラスのように，多相的な関数(など)に特定の制約，比較関数が定義されているとか，を持たせるために利用する．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">(* 図 2.9 *)</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">signature SET =</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">sig</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">type</span> Elem</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">val</span> empty : <span class="dt">Set</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">val</span> insert : Elem * <span class="dt">Set</span> -&gt; <span class="dt">Set</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="kw">val</span> member : Elem * <span class="dt">Set</span> -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="kw">end</span>;</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">signature ORDERED =</a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="kw">sig</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="kw">type</span> T</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  <span class="kw">val</span> eq : T * T -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">  <span class="kw">val</span> lt : T * T -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">  <span class="kw">val</span> leq : T * T -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"><span class="kw">end</span>;</a>
<a class="sourceLine" id="cb7-18" data-line-number="18"></a>
<a class="sourceLine" id="cb7-19" data-line-number="19"><span class="kw">functor</span> UnbalancedSet (Element : ORDERED) : SET =</a>
<a class="sourceLine" id="cb7-20" data-line-number="20"><span class="kw">struct</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">  <span class="kw">type</span> Elem = Element.T</a>
<a class="sourceLine" id="cb7-22" data-line-number="22">  datatype Tree = E | T <span class="kw">of</span> Tree * Elem * Tree</a>
<a class="sourceLine" id="cb7-23" data-line-number="23">  <span class="kw">type</span> <span class="dt">Set</span> = Tree</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">  <span class="kw">val</span> empty = E</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">  <span class="kw">fun</span> member (x, E) = ...</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">  <span class="kw">fun</span> insert (x, E) = ...</a>
<a class="sourceLine" id="cb7-27" data-line-number="27"><span class="kw">end</span>;</a>
<a class="sourceLine" id="cb7-28" data-line-number="28"></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">structure IntElement : ORDERED =</a>
<a class="sourceLine" id="cb7-30" data-line-number="30"><span class="kw">struct</span></a>
<a class="sourceLine" id="cb7-31" data-line-number="31">  <span class="kw">type</span> T = <span class="dt">int</span></a>
<a class="sourceLine" id="cb7-32" data-line-number="32">  <span class="kw">fun</span> eq (x, y) = x = y</a>
<a class="sourceLine" id="cb7-33" data-line-number="33">  <span class="kw">fun</span> lt (x, y) = x &lt; y</a>
<a class="sourceLine" id="cb7-34" data-line-number="34">  <span class="kw">fun</span> leq (x, y) = x &lt;= y</a>
<a class="sourceLine" id="cb7-35" data-line-number="35"><span class="kw">end</span>;</a>
<a class="sourceLine" id="cb7-36" data-line-number="36"></a>
<a class="sourceLine" id="cb7-37" data-line-number="37">structure IntHeap = LeftistHeap (IntElement);</a>
<a class="sourceLine" id="cb7-38" data-line-number="38"><span class="kw">val</span> h1 = IntHeap.insert (<span class="dv">1</span>, IntHeap.empty);</a></code></pre></div>
<h4 id="as-パターン">as パターン</h4>
<p>例えば，演習 2.1 の <code>suffixes</code> を</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">fun</span> suffixes [] = [[]]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  | suffixes (x :: xs) = (x :: xs) :: suffixes xs;</a></code></pre></div>
<p>としちゃうと，一度リストを展開して再度 cons するので，いわゆるポインタが変わっちゃう． 展開する前と後を同時に利用する方法が as パターン．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">fun</span> suffixes [] = [[]]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  | suffixes (l <span class="kw">as</span> (x :: xs)) = l :: suffixes xs;</a></code></pre></div>
<p>と書けばよい．</p>
<h4 id="例外処理">例外処理</h4>
<p>例外の定義は <code>exception</code> 宣言で行う．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">exception</span> ExceptionName</a></code></pre></div>
<p><code>signature</code> や <code>structure</code> の中でも定義できる．</p>
<p>例外を発生させる場合は <code>raise</code> キーワードを使い，補足する場合は <code>handle</code> キーワードを使う．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">fun</span> hoge x = <span class="dt">raise</span> HogeException handle HogeException =&gt; x;</a></code></pre></div>
<p>発生する可能性のある式の後ろに <code>handle</code> を記述することで，その式の評価中に発生した例外を補足し，以降の処理を <code>handle</code> より後で記述できる． <code>handle</code> でパターンマッチすることもできる．</p>
<h5 id="ref.-1">ref.</h5>
<ul>
<li><a href="http://walk.wgag.net/sml/exception.html">例外処理 - ウォークスルー Standard ML</a></li>
</ul>
<h4 id="リスト処理">リスト処理</h4>
<p>畳み込み関数 <code>foldl</code> (Ruby でいう <code>reduce</code> とか <code>inject</code> とか)や，<code>map</code> 関数などの，よくある高階関数は，もちろん SML にもある． 以下で定義されており，とくにインポートする必要は無い．</p>
<h5 id="ref.-2">ref.</h5>
<ul>
<li><a href="http://sml-family.org/Basis/list.html">The List structure - Standard ML</a></li>
</ul>
<h4 id="ラムダ式無名関数">ラムダ式(無名関数)</h4>
<p>最近であれば，大抵のモダンな言語にあるラムダ式，SMLの場合は</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb12-1" data-line-number="1">fn x =&gt; x * x</a></code></pre></div>
<p>と書く．</p>
<p>2引数関数の場合は</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb13-1" data-line-number="1">fn (x, y) =&gt; x * y</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">fn x =&gt; fn y =&gt; x * y</a></code></pre></div>
<p>のどちらか．</p>
<h5 id="ref.-3">ref.</h5>
<ul>
<li><a href="http://walk.wgag.net/sml/higherorder.html">高階関数 - ウォークスルー Standard ML</a></li>
<li><a href="https://stackoverflow.com/questions/2437019/curried-anonymous-function-in-sml">smlnj - Curried anonymous function in SML - Stack Overflow</a></li>
</ul>
<h4 id="どう試すか">どう試すか</h4>
<p>だいたいこうしてる． これは 図 3.2 の <code>LeftistHeap</code> ファンクターを試している．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb14-1" data-line-number="1">structure IntHeap = LeftistHeap (IntElement);</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">val</span> h1 = foldl IntHeap.insert IntHeap.empty [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>];</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="kw">val</span> h2 = foldl IntHeap.insert IntHeap.empty [<span class="dv">0</span>,<span class="dv">4</span>];</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">IntHeap.findMin (h1);</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">IntHeap.findMin (IntHeap.deleteMin (h1));</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">IntHeap.findMin (IntHeap.merge(h1, h2));</a></code></pre></div>
<h2 id="おしまい">おしまい</h2>
<p>あと，証明とかで数式の性質なんかを調べるときに <a href="http://www.wolframalpha.com/">WolframAlpha</a> が便利．</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
