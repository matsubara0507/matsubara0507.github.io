<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="OCaml のモジュールについてのメモ その２" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        OCaml のモジュールについてのメモ その２
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">OCaml のモジュールについてのメモ その２</h1>
    <p class="post-meta">
      <time datetime="2016-12-11" itemprop="datePublished">
        Dec 11, 2016
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="../tags/OCaml.html">OCaml</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>表題の通り，OCaml のモジュールシステムについてのメモ．</p>
<p>ファーストクラスモジュールを学ぶために，<a href="https://realworldocaml.org/v1/en/html/first-class-modules.html">Web版 Real World OCaml の Chapter 10.</a> を全訳．</p>
<p>英語はザコなのでかなり意訳だと思われ．</p>
<h2 id="chapter-10.-ファーストクラスモジュール-first-class-module">Chapter 10. ファーストクラスモジュール (First-class module)</h2>
<p>OCaml は二つの部分に分割されていると考えることができる． 一つは型と値に関するコア言語であり，もう一つはモジュールとモジュールシグネチャに関するモジュール言語である． これらのサブ言語は階層化されており，モジュールは型と値を含むことができるが，通常，値はモジュールとモジュールシグネチャは含むことはできない． つまり，モジュールが値であるような変数を定義したり，モジュールを引数に取る関数を定義したりはできない．</p>
<p>OCaml はこの階層周りの方法をファーストクラスモジュールの形式で提供する． ファーストクラスモジュールは一般的なモジュールから作成して，一般的なモジュールに戻すことができる，通常の値である．</p>
<p>ファーストクラスモジュールは洗練されたテクニックであり，効果的に使用するためには言語のいくつかの高度な側面に慣れる必要があるだろう． しかし，モジュールをコア言語の中に置くことは非常に強力で，表現できる範囲が広がり，柔軟でモジュラーなシステムを容易に構築できるようになるため，学習する価値がある．</p>
<h3 id="working-with-first-class-modules">WORKING WITH FIRST-CLASS MODULES</h3>
<p>我々はまず，単純な例をいくつか用いてファーストクラスモジュールの基本的な仕組みをカバーすることから始める． 次の節ではより現実的な例を示す．</p>
<p>そういうことで，下記のような単一の整数変数を持つモジュールのシグネチャを考える．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" title="1"># <span class="kw">module</span> <span class="kw">type</span> X_int = <span class="kw">sig</span> <span class="kw">val</span> x : <span class="dt">int</span> <span class="kw">end</span> ;;</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">module</span> <span class="kw">type</span> X_int = <span class="kw">sig</span> <span class="kw">val</span> x : <span class="dt">int</span> <span class="kw">end</span></a></code></pre></div>
<p>個のシグネチャに合うモジュールも作成できる．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb2-1" title="1"># <span class="kw">module</span> Three : X_int = <span class="kw">struct</span> <span class="kw">let</span> x = <span class="dv">3</span> <span class="kw">end</span>;;</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">module</span> Three : X_int</a>
<a class="sourceLine" id="cb2-3" title="3"># Three.x;;</a>
<a class="sourceLine" id="cb2-4" title="4">- : <span class="dt">int</span> = <span class="dv">3</span></a></code></pre></div>
<p>ファーストクラスモジュールは，それ(作りたいファーストクラスモジュールの条件)を満たすシグネチャを持つモジュールをパッケージ化することによって作られる． これは，下記の構文のように，<code>module</code> キーワードを使うことで行える．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb3-1" title="1">(<span class="kw">module</span> &lt;Module&gt; : &lt;Module_type&gt;)</a></code></pre></div>
<p>そこで，下記のように <code>Three</code> をファーストクラスモジュールへと変換できる．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb4-1" title="1"># <span class="kw">let</span> three = (<span class="kw">module</span> Three : X_int);;</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">val</span> three : (<span class="kw">module</span> X_int) = &lt;<span class="kw">module</span>&gt;</a></code></pre></div>
<p>モジュール型を推論できる場合，ファーストクラスモジュールの構築は部分的に必要ない． 従って，次のように書ける．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb5-1" title="1"># <span class="kw">module</span> Four = <span class="kw">struct</span> <span class="kw">let</span> x = <span class="dv">4</span> <span class="kw">end</span>;;</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">module</span> Four : <span class="kw">sig</span> <span class="kw">val</span> x : <span class="dt">int</span> <span class="kw">end</span></a>
<a class="sourceLine" id="cb5-3" title="3"># <span class="kw">let</span> numbers = [ three; (<span class="kw">module</span> Four) ];;</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">val</span> numbers : (<span class="kw">module</span> X_int) <span class="dt">list</span> = [&lt;<span class="kw">module</span>&gt;; &lt;<span class="kw">module</span>&gt;]</a></code></pre></div>
<p>匿名モジュールからファーストクラスモジュールを作ることもできる．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb6-1" title="1"># <span class="kw">let</span> numbers = [three; (<span class="kw">module</span> <span class="kw">struct</span> <span class="kw">let</span> x = <span class="dv">4</span> <span class="kw">end</span>)] ;;</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">val</span> numbers : (<span class="kw">module</span> X_int) <span class="dt">list</span> = [&lt;<span class="kw">module</span>&gt;; &lt;<span class="kw">module</span>&gt;]</a></code></pre></div>
<p>ファーストクラスモジュールの中身にアクセスするためには，通常のモジュールへとアンパックする必要がある． これは，下記の構文のように，<code>val</code> キーワードを使うことで行える．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb7-1" title="1">(<span class="kw">val</span> &lt;first_class_module&gt; : &lt;Module_type&gt;)</a></code></pre></div>
<p>具体例は以下の通り．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb8-1" title="1"># <span class="kw">module</span> New_three = (<span class="kw">val</span> three : X_int) ;;</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">module</span> New_three : X_int</a>
<a class="sourceLine" id="cb8-3" title="3"># New_three.x;;</a>
<a class="sourceLine" id="cb8-4" title="4">- : <span class="dt">int</span> = <span class="dv">3</span></a></code></pre></div>
<h3 id="equality-of-first-class-module-types">Equality of First-Class Module Types</h3>
<p>ファーストクラスモジュールの型，例えば <code>(module X_int)</code>，はそれを構築するためのシグネチャの完全な修飾名に基づく． 例えそれが，実質的に同じシグネチャだとしても，異なる名前に基づくファーストクラスモジュールは異なる型という結果になる．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb9-1" title="1"># <span class="kw">module</span> <span class="kw">type</span> Y_int = X_int;;</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">module</span> <span class="kw">type</span> Y_int = X_int</a>
<a class="sourceLine" id="cb9-3" title="3"># <span class="kw">let</span> five = (<span class="kw">module</span> <span class="kw">struct</span> <span class="kw">let</span> x = <span class="dv">5</span> <span class="kw">end</span> : Y_int);;</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">val</span> five : (<span class="kw">module</span> Y_int) = &lt;<span class="kw">module</span>&gt;</a>
<a class="sourceLine" id="cb9-5" title="5"># [three; five];;</a>
<a class="sourceLine" id="cb9-6" title="6">Characters <span class="dv">8-12</span>:</a>
<a class="sourceLine" id="cb9-7" title="7">Error: This expression has <span class="kw">type</span> (<span class="kw">module</span> Y_int)</a>
<a class="sourceLine" id="cb9-8" title="8">       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> (<span class="kw">module</span> X_int)</a></code></pre></div>
<p>それらのファーストクラスモジュールとしての型が異なっているとしても，基礎となるモジュール型には互換性があるため(実際は同じ)，モジュールをアンパックして再パックすることで統一できる．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb10-1" title="1"># [three; (<span class="kw">module</span> (<span class="kw">val</span> five))];;</a>
<a class="sourceLine" id="cb10-2" title="2">- : (<span class="kw">module</span> X_int) <span class="dt">list</span> = [&lt;<span class="kw">module</span>&gt;; &lt;<span class="kw">module</span>&gt;]</a></code></pre></div>
<p>ファーストクラスモジュールの等価性を決定する方法は混乱することがある． よく書くことがあり，問題のあるケースの一つとして，他の場所で定義されたモジュールのエイリアスを作ろうとする場合が挙げられる． これは，可読性を挙げるためによく行われ，モジュール型の宣言する明示的な場合と宣言をインクルードする暗黙的な場合のどちらでも生じうる． どちらの場合も，元のモジュール型から構築されたファーストクラスモジュールと互換性のないファーストクラスモジュールを作るという意図しない副作用がある． これを対処するには，ファーストクラスモジュールを構築するときにシグネチャをどのように参照するかについて，よく考える必要がある．</p>
<p>ファーストクラスモジュールを引数に取ったり，戻り値にしたりするような通常の関数も書ける． 以下に二つの関数を定義を示す． <code>to_int</code> 関数は，<code>(module X_int)</code> を内部の <code>int</code> に変換する． <code>plus</code> 関数は二つのモジュール <code>(module X_int)</code> の和を返す．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb11-1" title="1"># <span class="kw">let</span> to_int m =</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="kw">let</span> <span class="kw">module</span> M = (<span class="kw">val</span> m : X_int) <span class="kw">in</span></a>
<a class="sourceLine" id="cb11-3" title="3">    M.x</a>
<a class="sourceLine" id="cb11-4" title="4">  ;;</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="kw">val</span> to_int : (<span class="kw">module</span> X_int) -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</a>
<a class="sourceLine" id="cb11-6" title="6"># <span class="kw">let</span> plus m1 m2 =</a>
<a class="sourceLine" id="cb11-7" title="7">    (<span class="kw">module</span> <span class="kw">struct</span></a>
<a class="sourceLine" id="cb11-8" title="8">       <span class="kw">let</span> x = to_int m1 + to_int m2</a>
<a class="sourceLine" id="cb11-9" title="9">     <span class="kw">end</span> : X_int)</a>
<a class="sourceLine" id="cb11-10" title="10">  ;;</a>
<a class="sourceLine" id="cb11-11" title="11"><span class="kw">val</span> plus : (<span class="kw">module</span> X_int) -&gt; (<span class="kw">module</span> X_int) -&gt; (<span class="kw">module</span> X_int) = &lt;<span class="kw">fun</span>&gt;</a></code></pre></div>
<p>これらの関数を手に入れることで，コア言語の簡潔さと単純さを利用して，より自然な形式で <code>(module X_int)</code> 型の値を扱えるようになった．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb12-1" title="1"># <span class="kw">let</span> six = plus three three;;</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">val</span> six : (<span class="kw">module</span> X_int) = &lt;<span class="kw">module</span>&gt;</a>
<a class="sourceLine" id="cb12-3" title="3"># to_int (<span class="dt">List</span>.fold ~init:six ~f:plus [three;three]);;</a>
<a class="sourceLine" id="cb12-4" title="4">- : <span class="dt">int</span> = <span class="dv">12</span></a></code></pre></div>
<p>ファーストクラスモジュールを扱うときに便利な構文糖衣がいくつかある． 注目すべき一つは，パターンマッチ内で普通のモジュールへと変換できることである． 従って，<code>to_int</code> 関数を次のように書き換えれる．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb13-1" title="1"># <span class="kw">let</span> to_int (<span class="kw">module</span> M : X_int) = M.x ;;</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">val</span> to_int : (<span class="kw">module</span> X_int) -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</a></code></pre></div>
<p>ファーストクラスモジュールは <code>int</code> のような単純な値に加えて，型と関数を含むことができる． 以下に，型と，その型の値を受け取って対応する新しい値を生成する <code>bump</code> 関数を含むインターフェースを示す．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb14-1" title="1"># <span class="kw">module</span> <span class="kw">type</span> Bumpable = <span class="kw">sig</span></a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="kw">type</span> t</a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="kw">val</span> bump : t -&gt; t</a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="kw">end</span>;;</a>
<a class="sourceLine" id="cb14-5" title="5"><span class="kw">module</span> <span class="kw">type</span> Bumpable = <span class="kw">sig</span> <span class="kw">type</span> t <span class="kw">val</span> bump : t -&gt; t <span class="kw">end</span></a></code></pre></div>
<p>異なる型の下に，複数のインスタンスを作ることができる．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb15-1" title="1"># <span class="kw">module</span> Int_bumper = <span class="kw">struct</span></a>
<a class="sourceLine" id="cb15-2" title="2">    <span class="kw">type</span> t = <span class="dt">int</span></a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="kw">let</span> bump n = n + <span class="dv">1</span></a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="kw">end</span>;;</a>
<a class="sourceLine" id="cb15-5" title="5"><span class="kw">module</span> Int_bumper : <span class="kw">sig</span> <span class="kw">type</span> t = <span class="dt">int</span> <span class="kw">val</span> bump : t -&gt; t <span class="kw">end</span></a>
<a class="sourceLine" id="cb15-6" title="6"># <span class="kw">module</span> Float_bumper = <span class="kw">struct</span></a>
<a class="sourceLine" id="cb15-7" title="7">     <span class="kw">type</span> t = <span class="dt">float</span></a>
<a class="sourceLine" id="cb15-8" title="8">     <span class="kw">let</span> bump n = n +. <span class="dv">1</span>.</a>
<a class="sourceLine" id="cb15-9" title="9">  <span class="kw">end</span>;;</a>
<a class="sourceLine" id="cb15-10" title="10"><span class="kw">module</span> Float_bumper : <span class="kw">sig</span> <span class="kw">type</span> t = <span class="dt">float</span> <span class="kw">val</span> bump : t -&gt; t <span class="kw">end</span></a></code></pre></div>
<p>そして，それらをファーストクラスモジュールｎ変換できる．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb16-1" title="1"># <span class="kw">let</span> int_bumper = (<span class="kw">module</span> Int_bumper : Bumpable);;</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">val</span> int_bumper : (<span class="kw">module</span> Bumpable) = &lt;<span class="kw">module</span>&gt;</a></code></pre></div>
<p>しかし，<code>int_bumper</code> は抽象的すぎるため，もはや問題の型が <code>int</code> であることを復元することができない．</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb17-1" title="1"># <span class="kw">let</span> (<span class="kw">module</span> Bumpable) = int_bumper <span class="kw">in</span> Bumpable.bump <span class="dv">3</span>;;</a>
<a class="sourceLine" id="cb17-2" title="2">Characters <span class="dv">52-53</span>:</a>
<a class="sourceLine" id="cb17-3" title="3">Error: This expression has <span class="kw">type</span> <span class="dt">int</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></a>
<a class="sourceLine" id="cb17-4" title="4">         Bumpable.t</a></code></pre></div>
<p><code>int_bumper</code> を(上記のように)使うためには，以下のように，(モジュールの)型を明記する必要がある．</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb18-1" title="1"># <span class="kw">let</span> int_bumper = (<span class="kw">module</span> Int_bumper : Bumpable <span class="kw">with</span> <span class="kw">type</span> t = <span class="dt">int</span>);;</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="kw">val</span> int_bumper : (<span class="kw">module</span> Bumpable <span class="kw">with</span> <span class="kw">type</span> t = <span class="dt">int</span>) = &lt;<span class="kw">module</span>&gt;</a>
<a class="sourceLine" id="cb18-3" title="3"># <span class="kw">let</span> float_bumper = (<span class="kw">module</span> Float_bumper : Bumpable <span class="kw">with</span> <span class="kw">type</span> t = <span class="dt">float</span>);;</a>
<a class="sourceLine" id="cb18-4" title="4"><span class="kw">val</span> float_bumper : (<span class="kw">module</span> Bumpable <span class="kw">with</span> <span class="kw">type</span> t = <span class="dt">float</span>) = &lt;<span class="kw">module</span>&gt;</a></code></pre></div>
<p>上記で追加した，共有制約 (sharing constraint) により，ファーストクラスモジュールは型 <code>t</code> によって多相的になる． その結果，これらの値を一致する型の値として用いることができるようになった．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb19-1" title="1"># <span class="kw">let</span> (<span class="kw">module</span> Bumpable) = int_bumper <span class="kw">in</span> Bumpable.bump <span class="dv">3</span>;;</a>
<a class="sourceLine" id="cb19-2" title="2">- : <span class="dt">int</span> = <span class="dv">4</span></a>
<a class="sourceLine" id="cb19-3" title="3"># <span class="kw">let</span> (<span class="kw">module</span> Bumpable) = float_bumper <span class="kw">in</span> Bumpable.bump <span class="fl">3.5</span>;;</a>
<a class="sourceLine" id="cb19-4" title="4">- : <span class="dt">float</span> = <span class="fl">4.5</span></a></code></pre></div>
<p>このよう多相的なファーストモジュールを使う関数も書くことができる． 以下の関数は二つの引数，<code>Bumpable</code> モジュールと，<code>Bumpable</code> モジュー内の <code>t</code> 型となる型の要素を持つリスト，を取る</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb20-1" title="1"># <span class="kw">let</span> bump_list</a>
<a class="sourceLine" id="cb20-2" title="2">       (<span class="kw">type</span> a)</a>
<a class="sourceLine" id="cb20-3" title="3">       (<span class="kw">module</span> B : Bumpable <span class="kw">with</span> <span class="kw">type</span> t = a)</a>
<a class="sourceLine" id="cb20-4" title="4">       (l: a <span class="dt">list</span>)</a>
<a class="sourceLine" id="cb20-5" title="5">    =</a>
<a class="sourceLine" id="cb20-6" title="6">    <span class="dt">List</span>.map ~f:B.bump l</a>
<a class="sourceLine" id="cb20-7" title="7">  ;;</a>
<a class="sourceLine" id="cb20-8" title="8"><span class="kw">val</span> bump_list : (<span class="kw">module</span> Bumpable <span class="kw">with</span> <span class="kw">type</span> t = 'a) -&gt; 'a <span class="dt">list</span> -&gt; 'a <span class="dt">list</span> =</a>
<a class="sourceLine" id="cb20-9" title="9">  &lt;<span class="kw">fun</span>&gt;</a></code></pre></div>
<p>ここでは，以前には登場していない OCaml の機能，<em>局所的抽象型</em> (locally abstract type) を用いた． どの関数でも，新しく導入する任意の型 <code>a</code> に対して <code>(type a)</code> という形式の疑似パラメーターを宣言できる． この型は関数のコンテキスト内で，抽象型のように動作する． 上記の例では，局所的抽象型は型 <code>B.t</code> を(引数で)渡されたリストの要素の型と結びつける共有制約の一部として用いられた．</p>
<p>結果として得られる関数は，リストの要素の型と <code>Bumpable.t</code> の型の両方において多相的である． この関数が実際にちゃんと動作していることが分かる．</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb21-1" title="1"># bump_list int_bumper [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</a>
<a class="sourceLine" id="cb21-2" title="2">- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb21-3" title="3"># bump_list float_bumper [<span class="fl">1.5</span>;<span class="fl">2.5</span>;<span class="fl">3.5</span>];;</a>
<a class="sourceLine" id="cb21-4" title="4">- : <span class="dt">float</span> <span class="dt">list</span> = [<span class="fl">2.5</span>; <span class="fl">3.5</span>; <span class="fl">4.5</span>]</a></code></pre></div>
<p>多相的ファーストクラスモジュールは，ファーストクラスモジュールに関連付けられた型を，使用している他の値の型へと繋ぐことを可能にするため重要である．</p>
<h4 id="more-on-locally-abstract-types">More on Locally Abstract Types</h4>
<p>局所的抽象型の重要な特性の一つは，局所的抽象型を内部で定義している関数の中では，その局所的抽象型は抽象型として扱われるが，外からは多相的であることである． 以下のような例を考える．</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb22-1" title="1"># <span class="kw">let</span> wrap_in_list (<span class="kw">type</span> a) (x:a) = [x];;</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">val</span> wrap_in_list : 'a -&gt; 'a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</a></code></pre></div>
<p>これは，型 <code>a</code> が抽象型(<code>'a list</code>)と互換性のあるやり方で使われているため正常にコンパイルされるが，推論された関数の型は多相的である．</p>
<p>一方で，型 <code>a</code> をなんらかの具体的な型，例えば <code>int</code> など，の様に用いた場合，コンパイラは次のような文句を言うだろう．</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb23-1" title="1"># <span class="kw">let</span> wrap_int_in_list (<span class="kw">type</span> a) (x:a) = x + x;;</a>
<a class="sourceLine" id="cb23-2" title="2">Characters <span class="dv">38-39</span>:</a>
<a class="sourceLine" id="cb23-3" title="3">Error: This expression has <span class="kw">type</span> a but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="dt">int</span></a></code></pre></div>
<p>局所的抽象型の一般的な使い方の一つは，モジュールを構築する際に用いられる新しい型を作ることである． 以下に新しいファーストクラスモジュール構築する例を示す．</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb24-1" title="1"># <span class="kw">module</span> <span class="kw">type</span> Comparable = <span class="kw">sig</span></a>
<a class="sourceLine" id="cb24-2" title="2">    <span class="kw">type</span> t</a>
<a class="sourceLine" id="cb24-3" title="3">    <span class="kw">val</span> <span class="dt">compare</span> : t -&gt; t -&gt; <span class="dt">int</span></a>
<a class="sourceLine" id="cb24-4" title="4">  <span class="kw">end</span> ;;</a>
<a class="sourceLine" id="cb24-5" title="5"><span class="kw">module</span> <span class="kw">type</span> Comparable = <span class="kw">sig</span> <span class="kw">type</span> t <span class="kw">val</span> <span class="dt">compare</span> : t -&gt; t -&gt; <span class="dt">int</span> <span class="kw">end</span></a>
<a class="sourceLine" id="cb24-6" title="6"># <span class="kw">let</span> create_comparable (<span class="kw">type</span> a) <span class="dt">compare</span> =</a>
<a class="sourceLine" id="cb24-7" title="7">    (<span class="kw">module</span> <span class="kw">struct</span></a>
<a class="sourceLine" id="cb24-8" title="8">       <span class="kw">type</span> t = a</a>
<a class="sourceLine" id="cb24-9" title="9">       <span class="kw">let</span> <span class="dt">compare</span> = <span class="dt">compare</span></a>
<a class="sourceLine" id="cb24-10" title="10">     <span class="kw">end</span> : Comparable <span class="kw">with</span> <span class="kw">type</span> t = a)</a>
<a class="sourceLine" id="cb24-11" title="11">  ;;</a>
<a class="sourceLine" id="cb24-12" title="12"><span class="kw">val</span> create_comparable :</a>
<a class="sourceLine" id="cb24-13" title="13">  ('a -&gt; 'a -&gt; <span class="dt">int</span>) -&gt; (<span class="kw">module</span> Comparable <span class="kw">with</span> <span class="kw">type</span> t = 'a) = &lt;<span class="kw">fun</span>&gt;</a>
<a class="sourceLine" id="cb24-14" title="14"># create_comparable Int.<span class="dt">compare</span>;;</a>
<a class="sourceLine" id="cb24-15" title="15">- : (<span class="kw">module</span> Comparable <span class="kw">with</span> <span class="kw">type</span> t = <span class="dt">int</span>) = &lt;<span class="kw">module</span>&gt;</a>
<a class="sourceLine" id="cb24-16" title="16"># create_comparable Float.<span class="dt">compare</span>;;</a>
<a class="sourceLine" id="cb24-17" title="17">- : (<span class="kw">module</span> Comparable <span class="kw">with</span> <span class="kw">type</span> t = <span class="dt">float</span>) = &lt;<span class="kw">module</span>&gt;</a></code></pre></div>
<p>ここでは，多相型を捕獲して，モジュール内の具体的な型としてエクスポートする効果的な方法を示した．</p>
<p>このテクニックはファーストクラスモジュールを超えて有用である． 例えば，ファンクターに渡すためのローカルモジュールを構築するために，同様のアプローチを用いることができる．</p>
<h2 id="おしまい">おしまい</h2>
<p>残りは具体例なので割愛(時間があったらやるかも)．</p>
<p>正直，ほとんど Google 翻訳様で，なんとなく伝わってしまった…ホント凄い．</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
