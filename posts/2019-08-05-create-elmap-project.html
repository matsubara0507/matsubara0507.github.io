<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="elmap.hs プロジェクトを作りました" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        elmap.hs プロジェクトを作りました
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">elmap.hs プロジェクトを作りました</h1>
    <p class="post-meta">
      <time datetime="2019-08-05" itemprop="datePublished">
        Aug 5, 2019
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="../tags/Haskell.html">Haskell</a> <a href="../tags/Elm.html">Elm</a> <a href="../tags/extensible-package.html">extensible-package</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>GUI 付きのツールを作成したい時、普段は Elm を使います． さらにバックエンドを付けるときは Haskell + Elm で実装し，Elm 側で呼び出す API クライアントは <a href="http://hackage.haskell.org/package/elm-export">elm-export</a> と <a href="http://hackage.haskell.org/package/servant-elm">servant-elm</a> というパッケージを使い，Haskell Servant の API 定義から自動生成させていました．</p>
<p>elm-export は Elm 0.19 に追いつけてなかったので独自にフォークして運用し，また愛用している extensible パッケージにも独自で対応していました． しかし，servant-elm が Elm 0.19 に対応するために依存パッケージを elm-export から <a href="http://hackage.haskell.org/package/elm-bridge">elm-bridge</a> に変更したところ，独自で対応してた部分と色々都合が悪かったので，それらのクッションとなる薄いラッパーパッケージ群として elmap.hs プロジェクトを作成しました:</p>
<h2 id="section"><iframe width="426" height="162" scrolling="no" frameborder="0" src="https://matsubara0507.github.io/my-github-cards/?target=matsubara0507/elmap.hs"></iframe></h2>
<p>この記事は elmap.hs を作る上で色々したことのメモ書きです．</p>
<h2 id="なぜ-elm-bridgeservant-elm-ではダメか">なぜ elm-bridge/servant-elm ではダメか</h2>
<p>を説明するためにまずは elm-bridge パッケージについて紹介する．</p>
<h3 id="elm-bridge-パッケージ">elm-bridge パッケージ</h3>
<p>elm-bridge は Haskell の型定義から Elm の型定義などを生成するためのパッケージだ． 型定義の他にも，Elm 側の JSON デコーダー・エンコーダーも自動生成してくれる(メタプログラミングなどが無い Elm にとってこれは大変嬉しい)．</p>
<p>仕組みは簡単で，簡易的な Elm の型定義などを Haskell で表現している．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="co">-- Elm の型定義そのもの</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">data</span> <span class="dt">ETypeDef</span></a>
<a class="sourceLine" id="cb1-3" title="3">   <span class="fu">=</span> <span class="dt">ETypeAlias</span> <span class="dt">EAlias</span>         <span class="co">-- レコードの型エイリアス</span></a>
<a class="sourceLine" id="cb1-4" title="4">   <span class="fu">|</span> <span class="dt">ETypePrimAlias</span> <span class="dt">EPrimAlias</span> <span class="co">-- 普通の型エイリアス</span></a>
<a class="sourceLine" id="cb1-5" title="5">   <span class="fu">|</span> <span class="dt">ETypeSum</span> <span class="dt">ESum</span>             <span class="co">-- 直和型</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">-- Elm の型自身</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">data</span> <span class="dt">EType</span></a>
<a class="sourceLine" id="cb1-9" title="9">   <span class="fu">=</span> <span class="dt">ETyVar</span> <span class="dt">ETVar</span>       <span class="co">-- 型変数</span></a>
<a class="sourceLine" id="cb1-10" title="10">   <span class="fu">|</span> <span class="dt">ETyCon</span> <span class="dt">ETCon</span>       <span class="co">-- コンストラクタ</span></a>
<a class="sourceLine" id="cb1-11" title="11">   <span class="fu">|</span> <span class="dt">ETyApp</span> <span class="dt">EType</span> <span class="dt">EType</span> <span class="co">-- 型適用</span></a>
<a class="sourceLine" id="cb1-12" title="12">   <span class="fu">|</span> <span class="dt">ETyTuple</span> <span class="dt">Int</span>       <span class="co">-- タプル型</span></a></code></pre></div>
<p>Elm での型定義の構文を表したのが <code>ETypeDef</code> 型で，関数の型を書くときなどの型を表現する構文を表したのが <code>EType</code> 型だ． <code>toElmType</code> 関数を使うことで任意の型の <code>EType</code> を <code>Typeable</code> で機械的に導出したり，<code>deriveElmDef</code> と TemplateHaskell で <code>ETypeDef</code> への変換を導出することができる:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">toElmType ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">EType</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">-- ETypeDef への変換は型クラスで定義する</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">class</span> <span class="dt">IsElmDefinition</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="ot">  compileElmDef ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">ETypeDef</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">-- Hoge 型の IsElmDefinition 型クラスのインスタンスを導出</span></a>
<a class="sourceLine" id="cb2-8" title="8">deriveElmDef defaultOptions '<span class="dt">'Hoge</span></a></code></pre></div>
<p>ちなみに <code>deriveElmDef</code> の代わりに <code>deriveBoth</code> を使うと aeson 系の型クラスのインスタンスも一緒に導出してくれる． そして <code>ETypeDef</code> などに変換したあとは，<code>renderElm</code> 関数や <code>makeElmModule</code> 関数を使うことで Elm のコードに変換できる．</p>
<h3 id="都合の悪い部分">都合の悪い部分</h3>
<p>問題はどっちかというと servant-elm にある． servant-elm は Elm 関数の変換に内部で <code>toElmType</code> 関数を使っている:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">LangElm</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">instance</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">HasForeignType</span> <span class="dt">LangElm</span> <span class="dt">EType</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" title="4">  typeFor _ _ _ <span class="fu">=</span> toElmType (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a)</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">getEndpoints ::</span></a>
<a class="sourceLine" id="cb3-7" title="7">  (<span class="dt">HasForeign</span> <span class="dt">LangElm</span> <span class="dt">EType</span> api, <span class="dt">GenerateList</span> <span class="dt">EType</span> (<span class="dt">Foreign</span> <span class="dt">EType</span> api))</a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api</a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="ot">-&gt;</span> [<span class="dt">Req</span> <span class="dt">EType</span>]</a>
<a class="sourceLine" id="cb3-10" title="10">getEndpoints <span class="fu">=</span> listFromAPI (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">LangElm</span>) (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">EType</span>)</a></code></pre></div>
<p>ここで，extensible パッケージの拡張可能レコード型に <code>toElmType</code> を使ってみると…</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">type</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">Record</span> '[ <span class="st">&quot;id&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span>, <span class="st">&quot;name&quot;</span> <span class="fu">&gt;:</span> <span class="dt">String</span> ]</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="fu">&gt;&gt;&gt;</span> toElmType (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">User</span>)</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="dt">ETyApp</span> (<span class="dt">ETyApp</span> (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;:&amp;&quot;</span>})) (<span class="dt">ETyApp</span> (<span class="dt">ETyApp</span> (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;':&quot;</span>})) (<span class="dt">ETyApp</span> (<span class="dt">ETyApp</span> (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;':&gt;&quot;</span>})) (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;\&quot;id\&quot;&quot;</span>}))) (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;Int&quot;</span>})))) (<span class="dt">ETyApp</span> (<span class="dt">ETyApp</span> (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;':&quot;</span>})) (<span class="dt">ETyApp</span> (<span class="dt">ETyApp</span> (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;':&gt;&quot;</span>})) (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;\&quot;name\&quot;&quot;</span>}))) (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;String&quot;</span>})))) (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;'[]&quot;</span>}))))) (<span class="dt">ETyApp</span> (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;Field&quot;</span>})) (<span class="dt">ETyCon</span> (<span class="dt">ETCon</span> {tc_name <span class="fu">=</span> <span class="st">&quot;Identity&quot;</span>})))</a></code></pre></div>
<p>これは絶対に Elm 側で動かない… そもそも拡張可能レコードは型エイリアスで定義されているため型名の情報が落ちてしまうし，理想的には Elm のレコード型に変換してほしい．</p>
<h2 id="section-1"></h2>
<p>ということで，extensible の拡張可能レコードでもうまく動作する薄いラッパーパッケージを作ることにした．</p>
<h2 id="elmap.hs-プロジェクト">elmap.hs プロジェクト</h2>
<p>elm-bridge と servant-elm には生成した <code>ETypeDef</code> や <code>EType</code> を再変換する関数を指定することができる:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- servant-elm</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">data</span> <span class="dt">ElmOptions</span> <span class="fu">=</span> <span class="dt">ElmOptions</span></a>
<a class="sourceLine" id="cb5-3" title="3">  {<span class="ot"> urlPrefix             ::</span> <span class="dt">UrlPrefix</span></a>
<a class="sourceLine" id="cb5-4" title="4">  ,<span class="ot"> elmTypeAlterations    ::</span> (<span class="dt">EType</span> <span class="ot">-&gt;</span> <span class="dt">EType</span>)</a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="co">-- ^ 生成した ETypes を変換しなおす</span></a>
<a class="sourceLine" id="cb5-6" title="6">  ,<span class="ot"> elmAlterations        ::</span> (<span class="dt">ETypeDef</span> <span class="ot">-&gt;</span> <span class="dt">ETypeDef</span>)</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="co">-- ^ 生成した ETypeDef を変換しなおす</span></a>
<a class="sourceLine" id="cb5-8" title="8">  ,<span class="ot"> emptyResponseElmTypes ::</span> [<span class="dt">EType</span>]</a>
<a class="sourceLine" id="cb5-9" title="9">  ,<span class="ot"> stringElmTypes        ::</span> [<span class="dt">EType</span>]</a>
<a class="sourceLine" id="cb5-10" title="10">  }</a></code></pre></div>
<p>しかし，これで extensible の型を変換しなおすのは大変なので <code>toElmType</code> のところから置き換える必要がある(そもそも型名の情報が落ちてしまっているし)．</p>
<h3 id="elmap-パッケージ">elmap パッケージ</h3>
<p><code>toElmType</code> が扱いにくい理由は，<code>Typeable</code> 型クラスから自動で定義を導出されてしまうからだ． 多くの場合，自動で導出される方が嬉しいのだが，今回は型名の情報を与えたり Elm のレコード型に対応させたりなど，個別に対応したいので型クラスを利用することにする:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">class</span> <span class="dt">IsElmType</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">  compileElmType ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">EType</span></a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="kw">instance</span> <span class="dt">IsElmType</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" title="5">  compileElmType _ <span class="fu">=</span> toElmType (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">instance</span> <span class="dt">IsElmType</span> <span class="dt">Float</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-7" title="7">  compileElmType _ <span class="fu">=</span> toElmType (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Float</span>)</a></code></pre></div>
<p>さらに，リネームを簡単に行いやすいようにリネームする関数を定義しておいた:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">toElmTypeWith ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">EType</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co">-- Elm の場合 `Order` という型名になっている</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">instance</span> <span class="dt">IsElmType</span> <span class="dt">Ordering</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-5" title="5">  compileElmType _ <span class="fu">=</span> toElmTypeWith <span class="st">&quot;Order&quot;</span> (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Ordering</span>)</a></code></pre></div>
<h3 id="servant-elmap-パッケージ">servant-elmap パッケージ</h3>
<p>servant 側では elmap パッケージで定義した <code>IsElmType</code> 型クラスを利用するようにする:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">data</span> <span class="dt">LangElmap</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">instance</span> <span class="dt">IsElmType</span> a <span class="ot">=&gt;</span> <span class="dt">HasForeignType</span> <span class="dt">LangElmap</span> <span class="dt">EType</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" title="4">  typeFor _ _ _ <span class="fu">=</span> compileElmType (<span class="dt">Proxy</span> <span class="fu">@</span> a)</a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="ot">getEndpoints ::</span></a>
<a class="sourceLine" id="cb8-7" title="7">  (<span class="dt">HasForeign</span> <span class="dt">LangElmap</span> <span class="dt">EType</span> api, <span class="dt">GenerateList</span> <span class="dt">EType</span> (<span class="dt">Foreign</span> <span class="dt">EType</span> api))</a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api</a>
<a class="sourceLine" id="cb8-9" title="9">  <span class="ot">-&gt;</span> [<span class="dt">Req</span> <span class="dt">EType</span>]</a>
<a class="sourceLine" id="cb8-10" title="10">getEndpoints <span class="fu">=</span> listFromAPI (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">LangElmap</span>) (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">EType</span>)</a></code></pre></div>
<p><code>getEndpoints</code> 関数を書き換えたので，この関数に依存している関数を全部置き換えた(ということをする必要があったのでフォークせずに薄いラッパーパッケージを作るようにした)．</p>
<h3 id="extensible-elmap-パッケージ">extensible-elmap パッケージ</h3>
<p>最後に，extensible の拡張可能レコード型に対して <code>IsElmType</code> 型クラスのインスタンスを定義すれば完成． 完成品はこちら:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">compileElmRecordTypeWith ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">RecordOf</span> h xs) <span class="ot">-&gt;</span> <span class="dt">EType</span></a>
<a class="sourceLine" id="cb9-2" title="2">compileElmRecordTypeWith name _ <span class="fu">=</span> <span class="dt">ETyCon</span> <span class="fu">$</span> <span class="dt">ETCon</span> name</a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="co">-- ここから下は利用者側で定義する</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">type</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">Record</span> '[ <span class="st">&quot;id&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span>, <span class="st">&quot;name&quot;</span> <span class="fu">&gt;:</span> <span class="dt">String</span> ]</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">instance</span> <span class="dt">IsElmType</span> <span class="dt">User</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-8" title="8">  compileElmType <span class="fu">=</span> compileElmRecordTypeWith <span class="st">&quot;User&quot;</span></a></code></pre></div>
<p><code>ElmType</code> 自体は型名を覚えるだけなので簡単(とはいえ，この定義だと型変数などには未対応だが…)． さらに <code>IsElmDefinition</code> 型クラスのインスタンスも定義する:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">compileElmRecordAliasWith ::</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="kw">forall</span> xs h <span class="fu">.</span> <span class="dt">Forall</span> (<span class="dt">KeyTargetAre</span> <span class="dt">KnownSymbol</span> <span class="dt">IsElmType</span>) xs</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">RecordOf</span> h xs) <span class="ot">-&gt;</span> <span class="dt">EAlias</span></a>
<a class="sourceLine" id="cb10-4" title="4">compileElmRecordAliasWith name _ <span class="fu">=</span> <span class="dt">EAlias</span></a>
<a class="sourceLine" id="cb10-5" title="5">  { ea_name <span class="fu">=</span> <span class="dt">ETypeName</span> name []</a>
<a class="sourceLine" id="cb10-6" title="6">  , ea_fields <span class="fu">=</span> fields</a>
<a class="sourceLine" id="cb10-7" title="7">  , ea_omit_null <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb10-8" title="8">  , ea_newtype <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb10-9" title="9">  , ea_unwrap_unary <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb10-10" title="10">  }</a>
<a class="sourceLine" id="cb10-11" title="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-12" title="12">    fields <span class="fu">=</span> henumerateFor</a>
<a class="sourceLine" id="cb10-13" title="13">      (<span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">KeyTargetAre</span> <span class="dt">KnownSymbol</span> <span class="dt">IsElmType</span>))</a>
<a class="sourceLine" id="cb10-14" title="14">      (<span class="dt">Proxy</span> <span class="fu">@</span> xs)</a>
<a class="sourceLine" id="cb10-15" title="15">      (\m acc <span class="ot">-&gt;</span> (stringKeyOf m, compileElmType <span class="fu">$</span> proxyTargetOf m) <span class="fu">:</span> acc)</a>
<a class="sourceLine" id="cb10-16" title="16">      []</a>
<a class="sourceLine" id="cb10-17" title="17"></a>
<a class="sourceLine" id="cb10-18" title="18"><span class="co">-- ここから下は利用者側で定義する</span></a>
<a class="sourceLine" id="cb10-19" title="19"><span class="kw">instance</span> <span class="dt">IsElmDefinition</span> <span class="dt">User</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-20" title="20">  compileElmDef <span class="fu">=</span> <span class="dt">ETypeAlias</span> <span class="fu">.</span> compileElmRecordAliasWith <span class="st">&quot;User&quot;</span></a></code></pre></div>
<p>多少ボイラーテンプレートができてしまったが，まぁ個人的には許容範囲．</p>
<h2 id="おまけ-普通のレコードに対応する">おまけ: 普通のレコードに対応する</h2>
<p>僕はほとんど使わないからいいんだけど，普通のレコード型も <code>IsElmType</code> に対応しやすいようなヘルパー関数を定義しておこう:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">toElmAlias ::</span> <span class="kw">forall</span> a<span class="fu">.</span> (<span class="dt">GIsElmFields</span> (<span class="dt">Rep</span> a), <span class="dt">IsElmType</span> a) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">EAlias</span></a>
<a class="sourceLine" id="cb11-2" title="2">toElmAlias proxy <span class="fu">=</span> <span class="dt">EAlias</span></a>
<a class="sourceLine" id="cb11-3" title="3">  { ea_name <span class="fu">=</span> <span class="dt">ETypeName</span> (renderElm <span class="fu">$</span> compileElmType proxy) []</a>
<a class="sourceLine" id="cb11-4" title="4">  , ea_fields <span class="fu">=</span> gcompileElmFields (<span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">Rep</span> a))</a>
<a class="sourceLine" id="cb11-5" title="5">  , ea_omit_null <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb11-6" title="6">  , ea_newtype <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb11-7" title="7">  , ea_unwrap_unary <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb11-8" title="8">  }</a>
<a class="sourceLine" id="cb11-9" title="9"></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="kw">class</span> <span class="dt">GIsElmFields</span> (<span class="ot">rep ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="ot">  gcompileElmFields ::</span> <span class="dt">Proxy</span> rep <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">EType</span>)]</a>
<a class="sourceLine" id="cb11-12" title="12"></a>
<a class="sourceLine" id="cb11-13" title="13"><span class="co">-- ここから下は利用者側で定義する</span></a>
<a class="sourceLine" id="cb11-14" title="14"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb11-15" title="15">    {<span class="ot"> userId   ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-16" title="16">    ,<span class="ot"> userName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-17" title="17">    } <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb11-18" title="18"></a>
<a class="sourceLine" id="cb11-19" title="19"><span class="kw">instance</span> <span class="dt">IsElmType</span> <span class="dt">Book</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-20" title="20">  compileElmType _ <span class="fu">=</span> <span class="dt">ETyCon</span> <span class="fu">$</span> <span class="dt">ETCon</span> <span class="st">&quot;Book&quot;</span></a>
<a class="sourceLine" id="cb11-21" title="21"></a>
<a class="sourceLine" id="cb11-22" title="22"><span class="kw">instance</span> <span class="dt">IsElmDefinition</span> <span class="dt">Book</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-23" title="23">  compileElmDef <span class="fu">=</span> <span class="dt">ETypeAlias</span> <span class="fu">.</span> toElmAlias</a></code></pre></div>
<p><code>toElmAlias</code> 関数では，Haskell の総称プログラミング(Generics)という機能を利用している． Generics では Haskell 内での型や値のメタ情報を Haskell の型や値として取得できる． これと型クラスを組み合わせることで，型の構造毎に関数の実装を分岐することができる:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="co">-- `M1 D` はデータ型を表現</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">instance</span> <span class="dt">GIsElmFields</span> a <span class="ot">=&gt;</span> <span class="dt">GIsElmFields</span> (<span class="dt">M1</span> <span class="dt">D</span> x a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" title="3">  gcompileElmFields _ <span class="fu">=</span> gcompileElmFields (<span class="dt">Proxy</span> <span class="fu">@</span> a)</a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">-- `M1 C` はコンストラクタを表現</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="kw">instance</span> <span class="dt">GIsElmFields</span> a <span class="ot">=&gt;</span> <span class="dt">GIsElmFields</span> (<span class="dt">M1</span> <span class="dt">C</span> x a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-7" title="7">  gcompileElmFields _ <span class="fu">=</span> gcompileElmFields (<span class="dt">Proxy</span> <span class="fu">@</span> a)</a>
<a class="sourceLine" id="cb12-8" title="8"></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co">-- `M1 S` はレコードのセレクタを表現(`K1` はカインドの情報)</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="kw">instance</span> (<span class="dt">Selector</span> x, <span class="dt">IsElmType</span> a) <span class="ot">=&gt;</span> <span class="dt">GIsElmFields</span> (<span class="dt">M1</span> <span class="dt">S</span> x (<span class="dt">K1</span> <span class="dt">R</span> a)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-11" title="11">  gcompileElmFields _ <span class="fu">=</span> [(selName (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">S1</span> x (<span class="dt">K1</span> <span class="dt">R</span> a) ()), compileElmType (<span class="dt">Proxy</span> <span class="fu">@</span> a))]</a>
<a class="sourceLine" id="cb12-12" title="12"></a>
<a class="sourceLine" id="cb12-13" title="13"><span class="co">--- `:*:` は型の直積を表現</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="kw">instance</span> (<span class="dt">GIsElmFields</span> a, <span class="dt">GIsElmFields</span> b) <span class="ot">=&gt;</span> <span class="dt">GIsElmFields</span> (a <span class="fu">:*:</span> b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-15" title="15">  gcompileElmFields _ <span class="fu">=</span> gcompileElmFields (<span class="dt">Proxy</span> <span class="fu">@</span> a) <span class="fu">++</span> gcompileElmFields (<span class="dt">Proxy</span> <span class="fu">@</span> b)</a></code></pre></div>
<h2 id="おしまい">おしまい</h2>
<p>もう少し簡単に解決する方法もあったような気もするけど，Haskell のメタプログラミングを色々味わえたのでまぁいいや． どうせ，僕ぐらいしか使わないだろうし(笑)</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
