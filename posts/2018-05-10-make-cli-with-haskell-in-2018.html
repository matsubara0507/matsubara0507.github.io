<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="オレ的 Haskell で CLI を作る方法 2018" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        オレ的 Haskell で CLI を作る方法 2018
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">オレ的 Haskell で CLI を作る方法 2018</h1>
    <p class="post-meta">
      <time datetime="2018-05-10" itemprop="datePublished">
        May 10, 2018
      </time>
      
      
      <div class="tags">
          <i class="fa fa-tags"></i> <a href="../tags/Haskell.html">Haskell</a> <a href="../tags/extensible-package.html">extensible-package</a> <a href="../tags/rio.html">rio</a>
      </div>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>現在 <a href="https://github.com/matsubara0507/taskpad">TaskPad</a> という簡易的なタスク管理(編集)ツールを Haskell で作っていて，少し CLI を作るうえでのオレ的ノウハウが溜まったのでメモっとく．</p>
<h2 id="taskpad">TaskPad</h2>
<p>先に，何を作ってるかを書いておく． まだ完成していないが，気持ちは次のような Yaml ファイルを編集して自身のタスク管理をしようかなと考えている．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">memo:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">tasks:</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">1:</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="fu">done:</span><span class="at"> </span><span class="ch">true</span></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="fu">children:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="fu">name:</span><span class="at"> hello</span></a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="fu">2:</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="fu">done:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="fu">children:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="fu">name:</span><span class="at"> world</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="fu">date:</span><span class="at"> </span><span class="st">'20180504'</span></a></code></pre></div>
<p>現状できている CLI は次のような感じ</p>
<pre><code>$ taskpad --help
taskpad - operate daily tasks

Usage: taskpad [-v|--verbose] [-d|--date DATE] COMMAND [--version]

Available options:
  -v,--verbose             Enable verbose mode: verbosity level &quot;debug&quot;
  -d,--date DATE           Task's date
  --version                Show version
  -h,--help                Show this help text

Available commands:
  new                      Create a new task file. Note: if don't use --date
                           option then use today's date.
  add                      Add Task
  done                     Done Task
  tasks                    Show Tasks</code></pre>
<p><code>taskpad new</code> で Yaml ファイルを生成し，<code>taskpad add &quot;hoge&quot;</code> “hoge” というタスクを追加し，<code>taskpad done 1</code> で1番目のタスクを完了したことにし，<code>taskpad tasks</code> でタスクの一覧を出力する．</p>
<h2 id="ノウハウ">ノウハウ？</h2>
<p>たぶん他ではあんまり書いてない，いくつかのことを書いておく．</p>
<ul>
<li>optparse-applicative + extensible を使った CLI のオプションパーサー
<ul>
<li>特にサブコマンドをバリアントで表現しているのが面白い</li>
</ul></li>
<li>optparse-applicative でバージョンを表示</li>
<li>バリアントと型クラスを用いた分岐</li>
<li>rio + extensible で大域変数</li>
<li>rio を用いてロギング</li>
</ul>
<p>オプションパーサーに <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> を用いている． オプションパーサーには <a href="https://hackage.haskell.org/package/optparse-simple">optparse-simple</a> や <a href="https://hackage.haskell.org/package/optparse-generic">optparse-generics</a> など他にもいくつかあるが，サブコマンドのような多少込み入ったコトをしようとすると optparse-applicative が欲しくなる． <a href="https://hackage.haskell.org/package/rio">rio</a> ライブラリは，なんとなく最近使っている alt. Prelude ライブラリ(詳しくは<a href="https://github.com/commercialhaskell/rio#readme">本家の README</a> か<a href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html">前の僕の記事</a>を読んで)． <a href="https://hackage.haskell.org/package/extensible">extensible</a> は Haskell の残念なレコード構文や直和型の代わりに，拡張可能なレコード・バリアント型を提供してくれる面白いパッケージだ．</p>
<h3 id="import-と言語拡張">import と言語拡張</h3>
<p>extensible はかなり言語拡張を用いる． 以降では，めんどくさいので <code>import</code> も含め明示的に扱わない． 以下のコードが先頭にくっついてるとビルドはできるはずだ(たぶん，試してない)．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">{-# LANGUAGE DataKinds             #-}</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">{-# LANGUAGE FlexibleContexts      #-}</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">{-# LANGUAGE OverloadedLabels      #-}</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">{-# LANGUAGE TypeApplications      #-}</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="ot">{-# LANGUAGE TypeFamilies          #-}</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="ot">{-# LANGUAGE TypeOperators         #-}</span></a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="kw">import</span>           <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span>          <span class="kw">as</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="kw">import</span>           <span class="dt">RIO.Time</span></a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="kw">import</span>           <span class="dt">Data.Extensible</span></a>
<a class="sourceLine" id="cb3-15" title="15"><span class="kw">import</span>           <span class="dt">Data.Functor.Identity</span></a>
<a class="sourceLine" id="cb3-16" title="16"><span class="kw">import</span>           <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb3-17" title="17"><span class="kw">import</span>           <span class="dt">GHC.TypeLits</span></a>
<a class="sourceLine" id="cb3-18" title="18"><span class="kw">import</span>           <span class="dt">Options.Applicative</span></a></code></pre></div>
<h3 id="extensible-で-optparse-applicative">extensible で optparse-applicative</h3>
<p>少しだけ <code>optparse-applicative</code> について説明しておく． optparse-applicative は CLI オプションをパースして任意の型にマッピングしてくれる． 主に次のようにして用いる．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-2" title="2">main <span class="fu">=</span> run <span class="fu">=&lt;&lt;</span> execParser opts</a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" title="4">    opts <span class="fu">=</span> info (options <span class="fu">&lt;**&gt;</span> helper)</a>
<a class="sourceLine" id="cb4-5" title="5">         <span class="fu">$</span> fullDesc</a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="fu">&lt;&gt;</span> header <span class="st">&quot;taskpad - operate daily tasks&quot;</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="ot">options ::</span> <span class="dt">Parser</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb4-9" title="9">options <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p><a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:execParser"><code>execParser</code></a> 関数は <code>ParserInfo a -&gt; IO a</code> という型を持つ． <a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:helper"><code>helper :: Parser (a -&gt; a)</code></a> は <code>--help</code> オプションを与えてくれる関数だ． <code>info</code> 関数と <code>fullDesc</code> や <code>header</code> により，<code>Parser a</code> 型のパーサーに対し <code>--help</code> で出力する情報を追加して <code>ParserInfo a</code> 型に変換する．</p>
<h4 id="型の定義">型の定義</h4>
<p><code>extensible</code> で <code>optparse-applicative</code> を使うとは即ち，任意の型，ここでいう <code>Options</code> 型が拡張可能レコードや拡張可能バリアントであるというシチュエーションだ． 今回は <code>Options</code> 型をまずは次のように定義した．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">type</span> <span class="dt">Options</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb5-2" title="2">  '[ <span class="st">&quot;verbose&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-3" title="3">   , <span class="st">&quot;date&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb5-4" title="4">   , <span class="st">&quot;subcmd&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb5-5" title="5">   ]</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">type</span> <span class="dt">SubCmd</span> <span class="fu">=</span> <span class="dt">Variant</span></a>
<a class="sourceLine" id="cb5-8" title="8">  '[ <span class="st">&quot;new&quot;</span>   <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb5-9" title="9">   , <span class="st">&quot;add&quot;</span>   <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-10" title="10">   , <span class="st">&quot;done&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-11" title="11">   , <span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> ()</a>
<a class="sourceLine" id="cb5-12" title="12">   ]</a>
<a class="sourceLine" id="cb5-13" title="13"></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="kw">type</span> <span class="dt">Date</span> <span class="fu">=</span> <span class="dt">Text</span></a></code></pre></div>
<p><code>SubCmd</code> 型が拡張可能なバリアント型だ． ちなみに，Haskell のプリミティブな代数型データ構造で記述すると以下のようになる．</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">Options</span> <span class="fu">=</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb6-2" title="2">  {<span class="ot"> verbose ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-3" title="3">  ,<span class="ot"> date    ::</span> <span class="dt">Maybe</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb6-4" title="4">  ,<span class="ot"> subcmd  ::</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb6-5" title="5">  }</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">data</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="fu">=</span> <span class="dt">New</span></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="fu">|</span> <span class="dt">Done</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-11" title="11">  <span class="fu">|</span> <span class="dt">Tasks</span></a></code></pre></div>
<p>自分的に，extensible を使う利点は3つある．</p>
<ol type="1">
<li>フィールド名と関数名の名前空間が別なので衝突が無い</li>
<li><code>type</code> 宣言によりレコードに対しいちいち型クラスのインスタンスを定義する必要が無い(既にあるものは)</li>
<li>型レベルリストによってフィールド全体に対する走査を行える</li>
</ol>
<p>逆にデメリットは，(2) にも関係するのだが，<code>type</code> 宣言のためインスタンスの定義が衝突することがしばしばある(これはインスタンスのスコープをコントロールできないという Haskell 全体での問題でもある)．</p>
<h4 id="拡張可能レコードのパーサー">拡張可能レコードのパーサー</h4>
<p>まずは拡張可能レコード(<code>Options</code> 型)のパーサーを書いてみる． バリアント(<code>SubCmd</code> 型)のは <code>undefined</code> としておこう． 細かい <code>optparse-applicative</code> の構文は割愛する．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">options ::</span> <span class="dt">Parser</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb7-2" title="2">options <span class="fu">=</span> hsequence</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="fu">$</span> <span class="fu">#</span>verbose <span class="fu">&lt;@=&gt;</span> switch (long <span class="st">&quot;verbose&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">'v'</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Enable verbose mode: verbosity level \&quot;debug\&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb7-4" title="4">   <span class="fu">&lt;:</span> <span class="fu">#</span>date    <span class="fu">&lt;@=&gt;</span> optional (strOption (long <span class="st">&quot;date&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">'d'</span> <span class="fu">&lt;&gt;</span> metavar <span class="st">&quot;DATE&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Task's date&quot;</span>))</a>
<a class="sourceLine" id="cb7-5" title="5">   <span class="fu">&lt;:</span> <span class="fu">#</span>subcmd  <span class="fu">&lt;@=&gt;</span> subcmdParser</a>
<a class="sourceLine" id="cb7-6" title="6">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb7-9" title="9">subcmdParser <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p>拡張可能レコードの値を構築するには <code>#fieldName @= fieldValue</code> というの <code>&lt;:</code> で直列につないでいく(細かくは extensible の解説記事を読んで)． <code>&lt;@=&gt;</code> 演算子はモナドなフィールドの値を持ち上げてくれるバージョンの <code>@=</code> 演算子だ． <code>$</code> の右側は，正確には違うが，次の型のようなイメージとなる．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">'[ <span class="dt">Parser</span> (<span class="st">&quot;verbose&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb8-2" title="2"> , <span class="dt">Parser</span> (<span class="st">&quot;date&quot;</span>    <span class="fu">&gt;:</span> <span class="dt">Maybe</span> <span class="dt">Date</span>)</a>
<a class="sourceLine" id="cb8-3" title="3"> , <span class="dt">Parser</span> (<span class="st">&quot;subcmd&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">SubCmd</span>)</a>
<a class="sourceLine" id="cb8-4" title="4"> ]</a></code></pre></div>
<p>Haskeller っであれば，後はリスト型で言う <code>sequence</code> できれば良さそうとわかるだろう． その型レベルリスト版が <code>hsequence</code> だ．</p>
<h4 id="拡張可能バリアントのパーサー">拡張可能バリアントのパーサー</h4>
<p>さて，今回の自分的なメインディッシュだ． 仮に通常の直和型であれば次のように書くだろう．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb9-2" title="2">subcmdParser <span class="fu">=</span> subparser</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="fu">$</span> command <span class="st">&quot;new&quot;</span>   (<span class="fu">pure</span> <span class="dt">New</span> <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-4" title="4">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;add&quot;</span>   (<span class="dt">Add</span> <span class="fu">&lt;$&gt;</span> strArgument (metavar <span class="st">&quot;TEXT&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-5" title="5">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;done&quot;</span>  (<span class="dt">Done</span> <span class="fu">&lt;$&gt;</span> argument auto (metavar <span class="st">&quot;ID&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-6" title="6">   <span class="fu">&lt;&gt;</span> command <span class="st">&quot;tasks&quot;</span> (<span class="fu">pure</span> <span class="dt">Tasks</span> <span class="ot">`withInfo`</span> <span class="st">&quot;...&quot;</span>)</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="ot">withInfo ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ParserInfo</span> a</a>
<a class="sourceLine" id="cb9-9" title="9">withInfo opts <span class="fu">=</span> info (helper <span class="fu">&lt;*&gt;</span> opts) <span class="fu">.</span> progDesc</a></code></pre></div>
<p>この程度のサブコマンドならそこまで複雑じゃなく書けた． しかし悲しいことに，例えば <code>command &quot;tasks&quot;</code> の行が無くてもビルドは通る． 即ち，<strong>直和型に対し網羅性を型検査で保証することが出来ない</strong>．</p>
<h2 id="section"></h2>
<p>対して extensible のバリアントならどうだろうか． 理想的にはバリアントと同じフィールドを持つレコードの各要素が <code>ParserInfo a</code> であるような値から自動で導出してくれると良い． つまり次のように扱いたい．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">subcmdParser ::</span> <span class="dt">Parser</span> <span class="dt">SubCmd</span></a>
<a class="sourceLine" id="cb10-2" title="2">subcmdParser <span class="fu">=</span> variantFrom</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="fu">$</span> <span class="fu">#</span>new   <span class="fu">@=</span> (<span class="fu">pure</span> () <span class="ot">`withInfo`</span> <span class="st">&quot;Create a new task file. Note: if don't use --date option then use today's date.&quot;</span>)</a>
<a class="sourceLine" id="cb10-4" title="4">   <span class="fu">&lt;:</span> <span class="fu">#</span>add   <span class="fu">@=</span> (strArgument (metavar <span class="st">&quot;TEXT&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Task contents&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;Add Task&quot;</span>)</a>
<a class="sourceLine" id="cb10-5" title="5">   <span class="fu">&lt;:</span> <span class="fu">#</span>done  <span class="fu">@=</span> (argument auto (metavar <span class="st">&quot;ID&quot;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Done task from id&quot;</span>) <span class="ot">`withInfo`</span> <span class="st">&quot;Done Task&quot;</span>)</a>
<a class="sourceLine" id="cb10-6" title="6">   <span class="fu">&lt;:</span> <span class="fu">#</span>tasks <span class="fu">@=</span> (<span class="fu">pure</span> () <span class="ot">`withInfo`</span> <span class="st">&quot;Show Tasks&quot;</span>)</a>
<a class="sourceLine" id="cb10-7" title="7">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="ot">variantFrom ::</span> <span class="dt">RecordOf</span> <span class="dt">ParserInfo</span> xs <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Variant</span> xs)</a>
<a class="sourceLine" id="cb10-10" title="10">variantFrom <span class="fu">=</span> <span class="fu">undefined</span></a>
<a class="sourceLine" id="cb10-11" title="11"></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="kw">instance</span> <span class="dt">Wrapper</span> <span class="dt">ParserInfo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-13" title="13">  <span class="kw">type</span> <span class="dt">Repr</span> <span class="dt">ParserInfo</span> a <span class="fu">=</span> <span class="dt">ParserInfo</span> a</a>
<a class="sourceLine" id="cb10-14" title="14">  _Wrapper <span class="fu">=</span> <span class="fu">id</span></a></code></pre></div>
<p><code>@=</code> と <code>&lt;:</code> で構築したレコードが <code>Record = RecordOf Identity</code> ではなく，<code>RecordOf h</code> であるためには <code>h</code> が <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Wrapper.html#t:Wrapper"><code>Wrapper</code></a> 型クラスのインスタンスである必要がある(というかインスタンスでありさえすれば良い)．</p>
<h2 id="section-1"></h2>
<p>さてキモは <code>variantFrom</code> だ． 通常の直和型版の <code>subcmdParser</code> 関数を見ればわかるように，<code>command</code> 関数で作成した値をモノイドで畳み込めばいいので，お察しの通り(??) <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#v:hfoldMap"><code>hfoldMap</code></a> を使う． ついでに <code>command</code> の一引数目に渡すサブコマンドの文字列はフィールド名から取得するようにしよう． この場合，インデックスと <code>KnownSymbol</code> 制約を渡す必要があるので <code>hfoldMap</code> の代わりに <code>hfoldMapWithIndexFor</code> 関数を使う．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">variantFrom ::</span></a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="dt">Forall</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>) xs <span class="ot">=&gt;</span> <span class="dt">RecordOf</span> <span class="dt">ParserInfo</span> xs <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Variant</span> xs)</a>
<a class="sourceLine" id="cb11-3" title="3">variantFrom <span class="fu">=</span> subparser <span class="fu">.</span> subcmdVariant</a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" title="5">    subcmdVariant <span class="fu">=</span> hfoldMapWithIndexFor (<span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>)) <span class="fu">$</span> \m x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-6" title="6">      <span class="kw">let</span> k <span class="fu">=</span> symbolVal (proxyAssocKey m)</a>
<a class="sourceLine" id="cb11-7" title="7">      <span class="kw">in</span> command k ((<span class="dt">EmbedAt</span> m <span class="fu">.</span> <span class="dt">Field</span> <span class="fu">.</span> <span class="fu">pure</span>) <span class="fu">&lt;$&gt;</span> getField x)</a></code></pre></div>
<p>結果として，<strong>extensible のバリアント版は網羅性を型検査によって検証できるようになった！</strong></p>
<h3 id="バージョンの表示">バージョンの表示</h3>
<p>バージョンの表示は他のコマンドと違い，コマンドが間違って(例えばサブコマンドが無い)いても <code>--version</code> という引数さえあれば優先的にバージョンを表示する必要がある． そのようなオプションを追加する場合には <a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:infoOption"><code>infoOption</code></a> 関数を使う．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Paths_taskpad</span>       <span class="kw">as</span> <span class="dt">Meta</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">import</span>           <span class="dt">Data.Version</span>        (<span class="dt">Version</span>)</a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Version</span>        <span class="kw">as</span> <span class="dt">Version</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="kw">import</span>           <span class="dt">Development.GitRev</span></a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-7" title="7">main <span class="fu">=</span> run <span class="fu">=&lt;&lt;</span> execParser opts</a>
<a class="sourceLine" id="cb12-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" title="9">    opts <span class="fu">=</span> info (options <span class="fu">&lt;**&gt;</span> version Meta.version <span class="fu">&lt;**&gt;</span> helper)</a>
<a class="sourceLine" id="cb12-10" title="10">         <span class="fu">$</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb12-11" title="11"></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="ot">version ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb12-13" title="13">version v <span class="fu">=</span> infoOption (showVersion v)</a>
<a class="sourceLine" id="cb12-14" title="14">    <span class="fu">$</span> long <span class="st">&quot;version&quot;</span></a>
<a class="sourceLine" id="cb12-15" title="15">   <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Show version&quot;</span></a>
<a class="sourceLine" id="cb12-16" title="16"></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="ot">showVersion ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb12-18" title="18">showVersion v <span class="fu">=</span> <span class="fu">unwords</span></a>
<a class="sourceLine" id="cb12-19" title="19">  [ <span class="st">&quot;Version&quot;</span></a>
<a class="sourceLine" id="cb12-20" title="20">  , Version.showVersion v <span class="fu">++</span> <span class="st">&quot;,&quot;</span></a>
<a class="sourceLine" id="cb12-21" title="21">  , <span class="st">&quot;Git revision&quot;</span></a>
<a class="sourceLine" id="cb12-22" title="22">  , <span class="fu">$</span>(gitHash)</a>
<a class="sourceLine" id="cb12-23" title="23">  , <span class="st">&quot;(&quot;</span> <span class="fu">++</span> <span class="fu">$</span>(gitCommitCount) <span class="fu">++</span> <span class="st">&quot; commits)&quot;</span></a>
<a class="sourceLine" id="cb12-24" title="24">  ]</a></code></pre></div>
<p><code>&lt;**&gt;</code> 演算子はただの <code>flip (&lt;*&gt;)</code> だ． ちなみに，<code>version</code> と <code>helper</code> の適用順を入れ替えると <code>--help</code> の表示がほんの少しだけ変わる．</p>
<h3 id="バリアントと型クラス">バリアントと型クラス</h3>
<p>こっからは <code>run :: Options -&gt; IO ()</code> 関数を考える．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">run ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" title="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-3" title="3">  date <span class="ot">&lt;-</span> <span class="fu">maybe</span> getTodaysDate <span class="fu">pure</span> <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb13-4" title="4">  matchField</a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="fu">undefined</span> <span class="co">-- ???</span></a>
<a class="sourceLine" id="cb13-6" title="6">    (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>getTodaysDate</code> 関数は自身で定義しているとする． <code>--date</code> オプションを指定しなかった場合には今日の日付を取得する． 問題はサブコマンドの分岐だ．</p>
<p>バリアントの分岐には <a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"><code>matchField</code></a> 関数を用いる． <code>matchField</code> 関数の型は <code>RecordOf (Match h r) xs -&gt; VariantOf h xs -&gt; r</code> となる． 一引数目のレコードと二引数目のバリアントの <code>xs</code> が等しいということから共通のフィールドを期待しているのが分かるだろう． レコード側の各フィールドに，各バリアントに対するフィールドの値を受け取り <code>r</code> 型の返り値の関数を記述するといった具合だ(この部分が <code>Match h r</code> に集約されている)．</p>
<h2 id="section-2"></h2>
<p>今回は，このレコードの構築に型クラスを用いる． 以下のような型クラスを定義する．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">class</span> <span class="dt">Run</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="ot">  run' ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">Date</span> <span class="ot">-&gt;</span> <span class="dt">AssocValue</span> kv <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>実装は置いておいて，インスタンスを与えてみよう．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" title="2">  run' _ _ _ <span class="fu">=</span> <span class="fu">undefined</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;add&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" title="5">  run' _ _ _ <span class="fu">=</span> <span class="fu">undefined</span></a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;done&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-8" title="8">  run' _ _ _ <span class="fu">=</span> <span class="fu">undefined</span></a>
<a class="sourceLine" id="cb15-9" title="9"></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-11" title="11">  run' _ _ _ <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p><code>run</code> 関数の <code>matchField</code> 関数の引数は次のようになる．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">run ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-2" title="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" title="3">  date <span class="ot">&lt;-</span> <span class="fu">maybe</span> getTodaysDate <span class="fu">pure</span> <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb16-4" title="4">  matchField</a>
<a class="sourceLine" id="cb16-5" title="5">    (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run' m date <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb16-6" title="6">    (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>Proxy @ Run</code> の <code>@</code> の部分は <code>TypeApplications</code> 拡張のモノだ． フィールドの値は <code>Identity x</code> 型として来るので <code>runIdentity</code> 関数を用いて剥がし，<code>run' m date</code> へと適用する． もちろんサブコマンドのインスタンスを書き忘れていた場合は，ちゃんと型検査に引っかかる！</p>
<h3 id="rio-で大域変数">rio で大域変数</h3>
<p><code>rio</code> で大域変数を扱うには <code>RIO env</code> モナドを用いる． 適当なアプリケーションモナドを定義してやろう． 今回はひとつしか大域変数が無いのであんまりメリットを感じないかもしれないが…</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">type</span> <span class="dt">TaskPad</span> <span class="fu">=</span> <span class="dt">RIO</span> <span class="dt">Env</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb17-4" title="4">  '[ <span class="st">&quot;date&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb17-5" title="5">   ]</a></code></pre></div>
<p><code>run</code> 関数も書き直してやる．</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">run ::</span> <span class="dt">MonadUnliftIO</span> m <span class="ot">=&gt;</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb18-2" title="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-3" title="3">  date <span class="ot">&lt;-</span> <span class="fu">maybe</span> getTodaysDate <span class="fu">pure</span> <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb18-4" title="4">  <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>date   <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb18-5" title="5">         <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb18-6" title="6">  runRIO env <span class="fu">$</span></a>
<a class="sourceLine" id="cb18-7" title="7">    matchField</a>
<a class="sourceLine" id="cb18-8" title="8">      (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run' m <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb18-9" title="9">      (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a>
<a class="sourceLine" id="cb18-10" title="10"></a>
<a class="sourceLine" id="cb18-11" title="11"><span class="kw">class</span> <span class="dt">Run</span> kv <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-12" title="12"><span class="ot">  run' ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">AssocValue</span> kv <span class="ot">-&gt;</span> <span class="dt">TaskPad</span> ()</a></code></pre></div>
<p>試しに <code>new</code> サブコマンドを書いてみよう．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" title="2">  run' _ _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-3" title="3">    date <span class="ot">&lt;-</span> asks (view <span class="fu">#</span>date)</a>
<a class="sourceLine" id="cb19-4" title="4">    writeMemo <span class="fu">$</span> mkMemo date</a></code></pre></div>
<p><code>mkMemo</code> や <code>writeMemo</code> については次のように定義している． <code>Memo</code> 型も拡張可能レコードだ． 最近の extensible のアップデートで拡張可能レコードが <code>ToJson</code> 型クラスと <code>FromJson</code> 型クラスのインスタンスになったので，Yaml への変換は特にインスタンスを書くことなく行えるようになった．</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Yaml</span> <span class="kw">as</span> <span class="dt">Y</span></a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="kw">type</span> <span class="dt">Memo</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb20-4" title="4">  '[ <span class="st">&quot;date&quot;</span>  <span class="fu">&gt;:</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb20-5" title="5">   , <span class="st">&quot;tasks&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Task</span></a>
<a class="sourceLine" id="cb20-6" title="6">   , <span class="st">&quot;memo&quot;</span>  <span class="fu">&gt;:</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb20-7" title="7">   ]</a>
<a class="sourceLine" id="cb20-8" title="8"></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="kw">type</span> <span class="dt">Task</span> <span class="fu">=</span> <span class="dt">Record</span> (<span class="dt">TaskFields</span> <span class="fu">++</span> '[<span class="st">&quot;children&quot;</span> <span class="fu">&gt;:</span> [<span class="dt">SubTask</span>]])</a>
<a class="sourceLine" id="cb20-10" title="10"><span class="kw">type</span> <span class="dt">SubTask</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="dt">TaskFields</span></a>
<a class="sourceLine" id="cb20-11" title="11"></a>
<a class="sourceLine" id="cb20-12" title="12"><span class="kw">type</span> <span class="dt">TaskFields</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-13" title="13">  '[ <span class="st">&quot;name&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb20-14" title="14">   , <span class="st">&quot;done&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-15" title="15">   ]</a>
<a class="sourceLine" id="cb20-16" title="16"></a>
<a class="sourceLine" id="cb20-17" title="17"><span class="ot">mkMemo ::</span> <span class="dt">Date</span> <span class="ot">-&gt;</span> <span class="dt">Memo</span></a>
<a class="sourceLine" id="cb20-18" title="18">mkMemo date</a>
<a class="sourceLine" id="cb20-19" title="19">    <span class="fu">=</span> <span class="fu">#</span>date  <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb20-20" title="20">   <span class="fu">&lt;:</span> <span class="fu">#</span>tasks <span class="fu">@=</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb20-21" title="21">   <span class="fu">&lt;:</span> <span class="fu">#</span>memo  <span class="fu">@=</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb20-22" title="22">   <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb20-23" title="23"></a>
<a class="sourceLine" id="cb20-24" title="24"><span class="ot">writeMemo ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Memo</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb20-25" title="25">writeMemo memo <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-26" title="26">  writeFileBinary (Text.unpack <span class="fu">$</span> memo <span class="fu">^.</span> <span class="fu">#</span>date <span class="fu">&lt;&gt;</span> <span class="st">&quot;.yaml&quot;</span>) (Y.encode memo)</a></code></pre></div>
<h3 id="rio-でロギング">rio でロギング</h3>
<p>ロギングは実用アプリケーションの重要な要素だろう． <code>rio</code> であればまぁまぁ簡単に書ける．</p>
<p>まずは <code>Env</code> にロギング用の関数を足してやる． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogFunc"><code>LogFunc</code></a> 型や <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:HasLogFunc"><code>HasLogFunc</code></a> 型クラスは <code>rio</code> ライブラリに定義されているものだ．</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb21-2" title="2">  '[ <span class="st">&quot;date&quot;</span>   <span class="fu">&gt;:</span> <span class="dt">Date</span></a>
<a class="sourceLine" id="cb21-3" title="3">   , <span class="st">&quot;logger&quot;</span> <span class="fu">&gt;:</span> <span class="dt">LogFunc</span></a>
<a class="sourceLine" id="cb21-4" title="4">   ]</a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="kw">instance</span> <span class="dt">HasLogFunc</span> <span class="dt">Env</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" title="7">  logFuncL <span class="fu">=</span> lens (view <span class="fu">#</span>logger) (\x y <span class="ot">-&gt;</span> x <span class="fu">&amp;</span> <span class="fu">#</span>logger <span class="ot">`set`</span> y)</a></code></pre></div>
<p>実はこれだけで <code>TaskPad</code> モナド(すなわち <code>RIO Env</code> モナド)の中で自由にロギング関数を呼べるようになる． 試しに <code>new</code> サブコマンドにロギングを足してみよう． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logInfo"><code>logInfo</code></a> 関数がロギング関数のひとつだ．</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">instance</span> <span class="dt">Run</span> (<span class="st">&quot;new&quot;</span> <span class="fu">&gt;:</span> ()) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" title="2">  run' _ _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-3" title="3">    date <span class="ot">&lt;-</span> asks (view <span class="fu">#</span>date)</a>
<a class="sourceLine" id="cb22-4" title="4">    writeMemo <span class="fu">$</span> mkMemo date</a>
<a class="sourceLine" id="cb22-5" title="5">    logInfo (display <span class="fu">$</span> <span class="st">&quot;create new task's file: &quot;</span> <span class="fu">&lt;&gt;</span> date <span class="fu">&lt;&gt;</span> <span class="st">&quot;.yaml&quot;</span>)</a></code></pre></div>
<p>あとは <code>run</code> 関数を書き換えよう(<code>Env</code> 型の中身が変わったので)．</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="ot">run ::</span> <span class="dt">MonadUnliftIO</span> m <span class="ot">=&gt;</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb23-2" title="2">run opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" title="3">  date    <span class="ot">&lt;-</span> <span class="fu">maybe</span> getTodaysDate <span class="fu">pure</span> <span class="fu">$</span> opts <span class="fu">^.</span> <span class="fu">#</span>date</a>
<a class="sourceLine" id="cb23-4" title="4">  logOpts <span class="ot">&lt;-</span> logOptionsHandle stdout (opts <span class="fu">^.</span> <span class="fu">#</span>verbose)</a>
<a class="sourceLine" id="cb23-5" title="5">  withLogFunc logOpts <span class="fu">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-6" title="6">    <span class="kw">let</span> env <span class="fu">=</span> <span class="fu">#</span>date   <span class="fu">@=</span> date</a>
<a class="sourceLine" id="cb23-7" title="7">           <span class="fu">&lt;:</span> <span class="fu">#</span>logger <span class="fu">@=</span> logger</a>
<a class="sourceLine" id="cb23-8" title="8">           <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb23-9" title="9">    runRIO env <span class="fu">$</span></a>
<a class="sourceLine" id="cb23-10" title="10">      matchField</a>
<a class="sourceLine" id="cb23-11" title="11">        (htabulateFor (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Run</span>) <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> (<span class="dt">Match</span> <span class="fu">$</span> run' m <span class="fu">.</span> runIdentity))</a>
<a class="sourceLine" id="cb23-12" title="12">        (opts <span class="fu">^.</span> <span class="fu">#</span>subcmd)</a></code></pre></div>
<p><code>LogFunc</code> 型の値を得るには <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:withLogFunc"><code>withLogFunc</code></a> 関数を用いるのが良いだろう． <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogOptions"><code>LogOptions</code></a> 型の値(ここでいう <code>logOpts</code>)を生成する <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logOptionsHandle"><code>logOptionsHandle</code></a> 関数の二引数目に <code>True</code> を与えることでログがデバッグ仕様になる(そういえば <code>Options</code> 型には <code>--verbose</code> オプションがあった)． ちなみに，デバッグ仕様のときにだけ表示するロギング関数として <a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logDebug"><code>logDebug</code></a> 関数がある．</p>
<h2 id="おしまい">おしまい</h2>
<p>早く完成させるぞ</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
