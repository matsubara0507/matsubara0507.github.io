<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="Haskell の API 定義から Kotlin の関数を生成するライブラリを作った" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        Haskell の API 定義から Kotlin の関数を生成するライブラリを作った
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Haskell の API 定義から Kotlin の関数を生成するライブラリを作った</h1>
    <p class="post-meta">
      <time datetime="2017-11-03" itemprop="datePublished">
        Nov 3, 2017
      </time>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://hackage.haskell.org/package/servant-kotlin">servant-kotlin</a> という Haskell パッケージを作った． そん時のメモ書き．</p>
<h2 id="servant-kotlin">servant-kotlin</h2>
<p>RESTful API を型として定義できる Haskell ライブラリ <a href="https://haskell-servant.github.io">Servant</a> という Web フレームワークがある． 例えば以下のような API の型を定義できる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Todo</span> <span class="fu">=</span> <span class="dt">Todo</span>
  {<span class="ot"> todoId ::</span> <span class="dt">Int</span>
  ,<span class="ot"> title  ::</span> <span class="dt">Text</span>
  ,<span class="ot"> done   ::</span> <span class="dt">Bool</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Todo</span>

<span class="kw">type</span> <span class="dt">CRUD</span> <span class="fu">=</span> <span class="st">&quot;todos&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Todo]</span>
       <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;todos&quot;</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON, FormUrlEncoded] Todo :&gt; Post '</span>[<span class="dt">JSON</span>] <span class="dt">Todo</span></code></pre></div>
<p><code>servant-kotlin</code> を用いると，上記の <code>Todo</code> 型と <code>CRUD</code> 型から以下のような Kotlin のエンドポイント関数を生成できる．</p>
<div class="sourceCode"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span class="kw">class</span> TodoAPI(<span class="kw">private</span> <span class="kw">val</span> <span class="va">baseURL</span>: <span class="dt">String</span>) {
  <span class="kw">data</span> <span class="kw">class</span> Todo(<span class="kw">val</span> <span class="va">todoId</span>: <span class="dt">Int</span>, <span class="kw">val</span> <span class="va">title</span>: <span class="dt">String</span>, <span class="kw">val</span> <span class="va">done</span>: <span class="dt">Boolean</span>)

  <span class="kw">fun</span> getTodos(<span class="va">handler</span>: (<span class="dt">Request</span>, <span class="dt">Response</span>, <span class="dt">Result</span>&lt;<span class="dt">List</span>&lt;<span class="dt">Todo</span>&gt;, <span class="dt">FuelError</span>&gt;) -&gt; <span class="dt">Unit</span>) {
    Fuel.<span class="kw">get</span>(<span class="st">&quot;/&quot;</span> + <span class="st">&quot;todos&quot;</span>).responseObject(handler)
  }

  <span class="kw">fun</span> <span class="fu">postTodos</span>(<span class="va">body</span>: <span class="dt">Todo</span>, <span class="va">handler</span>: (<span class="dt">Request</span>, <span class="dt">Response</span>, <span class="dt">Result</span>&lt;<span class="dt">Todo</span>, <span class="dt">FuelError</span>&gt;) -&gt; <span class="dt">Unit</span>) {
    Fuel.post(<span class="st">&quot;/&quot;</span> + <span class="st">&quot;todos&quot;</span>).body(Gson().toJson(body, Todo::<span class="kw">class</span>.java)).responseObject(<span class="va">handler</span>)
    }
}</code></pre></div>
<p>同種のものに <a href="https://hackage.haskell.org/package/servant-elm"><code>servant-elm</code></a> や <a href="https://hackage.haskell.org/package/servant-ruby"><code>servant-ruby</code></a> というのがある． 今回は主に <code>servant-elm</code> と，Haskell の型定義から Elm の型定義を生成する <a href="https://hackage.haskell.org/package/elm-export"><code>elm-export</code></a> を参考して作った． 参考と言うか，ほぼ丸パクリ(笑)</p>
<h2 id="いきさつ">いきさつ</h2>
<p><a href="../post/2017-10-23-create.anaqram.html">前回の記事</a> で紹介した通り，Elm × Haskell × Kotlin の Android + Web アプリを作った． Haskell ではもちろん Servant で API をサーバーを立てて，Elm (Web UI) 側は <code>servant-elm</code> を使って API の定義から生成してたんだが，Kotlin (Android Client) 側にはそういうパッケージがまだ無い． なので作った．</p>
<h2 id="section"></h2>
<p>自分用に作ったため，ちゃんとした動作確認は自分のパターンでしかしていない． そもそも，<code>Header</code> や <code>QueryFlag</code> など，今回の要件では必要なかった部分はまだ未実装だ．</p>
<p>まぁそのうち実装します(Kotlin 側をまじめに調べてないので，どういう形に出力すればいいかを知らない…)．</p>
<h2 id="作る">作る</h2>
<h3 id="型の生成">型の生成</h3>
<p>まずは Haskell で定義した型から Kotlin の型(クラス)を生成する必要がある． 取りあえず，あらゆる Haskell の型を生成可能にする必要は無い(JSON として使えるやつだけ)ので，そういうつもりで実装する．</p>
<h2 id="section-1"></h2>
<p>Kotlin には <a href="https://kotlinlang.org/docs/reference/data-classes.html">data class</a> と呼ばれるクラスがある． 例えば，さっきの <code>Todo</code> 型に対応する data calss は以下の通り．</p>
<div class="sourceCode"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span class="kw">data</span> <span class="kw">class</span> Todo(<span class="kw">val</span> <span class="va">todoId</span>: <span class="dt">Int</span>, <span class="kw">val</span> <span class="va">title</span>: <span class="dt">String</span>, <span class="kw">val</span> <span class="va">done</span>: <span class="dt">Boolean</span>)</code></pre></div>
<p>乱暴に言えば固有のメソッドの定義が無いクラスで，ほぼほぼ C言語の構造体と同じ． Haskell のレコード型をこの data class に対応させることにした．</p>
<h2 id="section-2"></h2>
<p><code>elm-export</code> では <code>ElmType</code> 型クラスというのを定義している．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ElmType</span> a <span class="kw">where</span>
<span class="ot">  toElmType ::</span> a <span class="ot">-&gt;</span> <span class="dt">ElmDatatype</span></code></pre></div>
<p><code>ElmDatatype</code> 型は Elm の型構造を Haskell で表現したものだ(詳しくは <a href="https://github.com/krisajenkins/elm-export/blob/94b939bb95ec4a86ae634e785ee93b66c3c1c7e6/src/Elm/Type.hs"><code>Elm/Type.hs</code></a> を見て)． これらを参考にして，Kotlin の場合も同様に <code>KotlinType</code> 型クラスと <a href="https://github.com/matsubara0507/servant-kotlin/blob/f08e3e2ae237a1c8a4931204c26bc83f03ea0e67/src/Servant/Kotlin/Type.hs#L31"><code>KotlinClass</code> 型</a>を定義した．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">KotlinType</span> a <span class="kw">where</span>
<span class="ot">  toKotlinType ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">KotlinClass</span></code></pre></div>
<p>Haskell の全ての型を，必ず Kotlin のクラスに変換できるとは思わなかった(例えば，フィールド名の無いフィールドを持つクラスは定義できない)ので，念のため <code>Maybe</code> を返している．</p>
<h2 id="section-3"></h2>
<p>で，まずは Primitive な Haskell 型のいくつかを <code>KotlinType</code> 型クラスのインスタンスにしてみた．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">KotlinType</span> <span class="dt">Int</span> <span class="kw">where</span>
  toKotlinType _ <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">PrimitiveClass</span> <span class="dt">KInt</span>

<span class="kw">instance</span> <span class="dt">KotlinType</span> () <span class="kw">where</span>
  toKotlinType _ <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">PrimitiveClass</span> <span class="dt">KUnit</span>

<span class="kw">instance</span> <span class="dt">KotlinType</span> <span class="dt">Text</span> <span class="kw">where</span>
  toKotlinType _ <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">PrimitiveClass</span> <span class="dt">KString</span>

<span class="kw">instance</span> <span class="dt">KotlinType</span> a <span class="ot">=&gt;</span> <span class="dt">KotlinType</span> [a] <span class="kw">where</span>
  toKotlinType _ <span class="fu">=</span> <span class="dt">ExClass</span> <span class="fu">.</span> <span class="dt">KList</span> <span class="fu">&lt;$&gt;</span> toKotlinType (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a)

<span class="kw">instance</span> <span class="dt">KotlinType</span> a <span class="ot">=&gt;</span> <span class="dt">KotlinType</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  toKotlinType _ <span class="fu">=</span>
    <span class="dt">PrimitiveClass</span> <span class="fu">.</span> <span class="dt">KNullable</span> <span class="fu">&lt;$&gt;</span> toKotlinType (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a)</code></pre></div>
<p>文字列とか配列・リストの辺りは，本当にこんな定義でいいかは怪しいが，あんまり悩んでてもしょうがないので，暫定的にこのような定義にしてる．</p>
<p>ちなみに，Kotlin には <code>Maybe</code> や <code>Optional</code> のようなコンテナ型は無く，Nullable というモノを用いている． <code>A</code> 型の Nullable は <code>A?</code> と書くのだ．</p>
<h3 id="generics">Generics</h3>
<p>さて，最悪これでお終いでも良いのだが，<code>deriving</code> ができないと流石に使いにくい． なので，頑張って Generics を定義する(とはいえ，<code>elm-export</code> のを真似るだけだが)．</p>
<h2 id="section-4"></h2>
<p>Generics とは，乱暴な言い方をすると，Haskell の型構造を Haskell の型と型クラスで表現したものだ． もっと細かい情報が含まれてるとはいえ，<code>elm-export</code> の <code>ElmDatatype</code> 型と <code>ElmType</code> 型クラスや，今回の <code>KotlinClass</code> 型と <code>KotlinType</code> 型クラスにイメージは似ている(もちろんもっと精巧に作られているが)．</p>
<p><code>deriving</code> で任意の型を <code>Generic</code> 型クラスのインスタンスにできる(個人的にはココがすごい)ので，<code>Generic</code> 型クラスのインスタンスに対する default 実装を与えておけば良いのだ．</p>
<h2 id="section-5"></h2>
<p><code>Generic</code> 型クラスは次のような定義になっている．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Generic</span> a <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span><span class="ot"> a ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="ot">  from  ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Rep</span> a) x
<span class="ot">  to    ::</span> (<span class="dt">Rep</span> a) x <span class="ot">-&gt;</span> a</code></pre></div>
<p><code>Rep a x</code> という型が Haskell の型構造を表現した型だ(<code>x</code> があるのは再帰的に構造をラップするためだと思う)． 例えば <code>Bool</code> の <code>Rep a x</code> 型を見てみる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;&gt;</span> from (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)
<span class="dt">M1</span> {unM1 <span class="fu">=</span> <span class="dt">R1</span> (<span class="dt">M1</span> {unM1 <span class="fu">=</span> <span class="dt">U1</span>})}
ghci<span class="fu">&gt;&gt;</span> <span class="fu">:</span>t from (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)
from (<span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span>)
<span class="ot">  ::</span> <span class="dt">D1</span>
       (<span class="ch">'MetaData &quot;Bool&quot; &quot;GHC.Types&quot; &quot;ghc-prim&quot; '</span><span class="dt">False</span>)
       (<span class="dt">C1</span> (<span class="ch">'MetaCons &quot;False&quot; '</span><span class="dt">PrefixI</span> <span class="ch">'False) U1</span>
        <span class="fu">:+:</span> <span class="dt">C1</span> (<span class="ch">'MetaCons &quot;True&quot; '</span><span class="dt">PrefixI</span> <span class="ch">'False) U1)</span>
       x</code></pre></div>
<p>なので，<code>Rep a x</code> 型に対しての <code>KotlinType</code> 型クラスのための型クラス <code>GenericKotlinType</code> を定義する．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">KotlinType</span> a <span class="kw">where</span>
<span class="ot">  toKotlinType ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">KotlinClass</span>
  toKotlinType <span class="fu">=</span> genericToKotlinType <span class="fu">.</span> from
  default<span class="ot"> toKotlinType ::</span> (<span class="dt">Generic</span> a, <span class="dt">GenericKotlinType</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span>
    a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">KotlinClass</span>

<span class="kw">class</span> <span class="dt">GenericKotlinType</span> f <span class="kw">where</span>
<span class="ot">  genericToKotlinType ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">KotlinClass</span></code></pre></div>
<h2 id="section-6"></h2>
<p>あとは，各データ構造の型(e.g. <code>D1</code> や <code>(:+:)</code>)ごとにインスタンスを定義してあげれば良い．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Datatype</span> d, <span class="dt">GenericKotlinFields</span> f)
  <span class="ot">=&gt;</span> <span class="dt">GenericKotlinType</span> (<span class="dt">D1</span> d f) <span class="kw">where</span>
  genericToKotlinType datatype <span class="fu">=</span> fmap <span class="dt">DataClass</span> <span class="fu">$</span>
    <span class="dt">KotlinDataClass</span> (pack <span class="fu">$</span> datatypeName datatype)
      <span class="fu">&lt;$&gt;</span> genericToKotlinFields (unM1 datatype)

<span class="co">-- Kotlin のインスタンスフィールを返す型クラス</span>
<span class="kw">class</span> <span class="dt">GenericKotlinFields</span> f <span class="kw">where</span>
<span class="ot">  genericToKotlinFields ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">KotlinFields</span>

<span class="kw">instance</span> (<span class="dt">Selector</span> s, <span class="dt">GenericKotlinType</span> a)
  <span class="ot">=&gt;</span> <span class="dt">GenericKotlinFields</span> (<span class="dt">S1</span> s a) <span class="kw">where</span>
  genericToKotlinFields selector <span class="fu">=</span>
    <span class="kw">case</span> selName selector <span class="kw">of</span>
      <span class="st">&quot;&quot;</span>   <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
      name <span class="ot">-&gt;</span>
        <span class="dt">Node</span> <span class="fu">.</span> <span class="dt">KotlinField</span> (pack name)
          <span class="fu">&lt;$&gt;</span> genericToKotlinType (undefined<span class="ot"> ::</span> a p)

<span class="kw">instance</span> <span class="dt">GenericKotlinFields</span> (f <span class="fu">:+:</span> g) <span class="kw">where</span>
  genericToKotlinFields _ <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="kw">instance</span> (<span class="dt">GenericKotlinFields</span> f, <span class="dt">GenericKotlinFields</span> g)
  <span class="ot">=&gt;</span> <span class="dt">GenericKotlinFields</span> (f <span class="fu">:*:</span> g) <span class="kw">where</span>
  genericToKotlinFields _ <span class="fu">=</span>
    <span class="dt">Brunch</span> <span class="fu">&lt;$&gt;</span> genericToKotlinFields (undefined<span class="ot"> ::</span> f p)
           <span class="fu">&lt;*&gt;</span> genericToKotlinFields (undefined<span class="ot"> ::</span> g p)</code></pre></div>
<p>ちなみに <code>D1 d f</code> 型は datatype を，<code>S1 s a</code> 型はレコード型のフィールドを，<code>f :+: g</code> 型は直和型を，<code>f :*: g</code> 型は直積型を表している．</p>
<h3 id="servant-api-の型の変換">Servant API の型の変換</h3>
<p>最初に定義した Servant API の型では(書きやすいけど)扱いにくいので，変換する部分が必要だ． もちろん，Servant 側が型クラスとして定義してある．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">HasForeign</span> lang ftype (<span class="ot">api ::</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Foreign</span> ftype<span class="ot"> api ::</span> <span class="fu">*</span>
<span class="ot">  foreignFor ::</span>
    <span class="dt">Proxy</span> lang
    <span class="ot">-&gt;</span> <span class="dt">Proxy</span> ftype
    <span class="ot">-&gt;</span> <span class="dt">Proxy</span> api
    <span class="ot">-&gt;</span> <span class="dt">Req</span> ftype
    <span class="ot">-&gt;</span> <span class="dt">Foreign</span> ftype api

<span class="ot">listFromAPI ::</span>
  ( <span class="dt">HasForeign</span> lang ftype api
  , <span class="dt">GenerateList</span> ftype (<span class="dt">Foreign</span> ftype api)
  ) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> lang
    <span class="ot">-&gt;</span> <span class="dt">Proxy</span> ftype
    <span class="ot">-&gt;</span> <span class="dt">Proxy</span> api
    <span class="ot">-&gt;</span> [<span class="dt">Req</span> ftype]
listFromAPI <span class="fu">=</span> <span class="fu">...</span>

<span class="kw">class</span> <span class="dt">HasForeignType</span> lang ftype a <span class="kw">where</span>
<span class="ot">  typeFor ::</span> <span class="dt">Proxy</span> lang <span class="ot">-&gt;</span> <span class="dt">Proxy</span> ftype <span class="ot">-&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> ftype</code></pre></div>
<p><code>listFromAPI</code> 関数を使うことでメタ情報の載った API の型 <code>Req ftype</code> の値が手に入る． 重要なのは <code>HasForeign</code> 型クラスだが，インスタンスが既にかなり定義されていて，実質的には <code>HasForeignType</code> 型クラスの<a href="https://github.com/matsubara0507/servant-kotlin/blob/f08e3e2ae237a1c8a4931204c26bc83f03ea0e67/src/Servant/Kotlin/Internal/Foreign.hs">インスタンスを定義</a>すれば良い．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LangKotlin</span>

<span class="kw">instance</span> (<span class="dt">KotlinType</span> a) <span class="ot">=&gt;</span>
  <span class="dt">HasForeignType</span> <span class="dt">LangKotlin</span> <span class="dt">KotlinClass</span> a <span class="kw">where</span>
  typeFor _ _ _ <span class="fu">=</span> toKotlinType' (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a)</code></pre></div>
<h3 id="生成する">生成する</h3>
<p>さて，後は実際に Kotlin のコードを文字列として生成する部分を作る． しかし，この部分は泥臭い部分なので細かくは説明しないでおく． <code>servant-elm</code> と見比べながら書き直していった．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- generate types</span>
<span class="kw">class</span> <span class="dt">GenerateKotlin</span> a <span class="kw">where</span>
<span class="ot">  generateKotlin ::</span> a <span class="ot">-&gt;</span> [<span class="dt">Text</span>]

<span class="kw">instance</span> <span class="dt">GenerateKotlin</span> <span class="dt">KotlinPrimitiveClass</span> <span class="kw">where</span>
  generateKotlin <span class="dt">KDouble</span> <span class="fu">=</span> [<span class="st">&quot;Double&quot;</span>]
  generateKotlin <span class="dt">KFloat</span>  <span class="fu">=</span> [<span class="st">&quot;Float&quot;</span>]
  <span class="fu">...</span>

<span class="co">-- generate apis</span>
<span class="ot">generateKotlinForAPIWith ::</span>
  ( <span class="dt">F.HasForeign</span> <span class="dt">LangKotlin</span> <span class="dt">KotlinClass</span> api
  , <span class="dt">F.GenerateList</span> <span class="dt">KotlinClass</span> (<span class="dt">F.Foreign</span> <span class="dt">KotlinClass</span> api))
  <span class="ot">=&gt;</span> <span class="dt">KotlinOptions</span>
  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> api
  <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
generateKotlinForAPIWith opts <span class="fu">=</span>
  nub <span class="fu">.</span> fmap (docToText <span class="fu">.</span> generateKotlinForRequest opts) <span class="fu">.</span> getEndpoints

<span class="ot">generateKotlinForRequest ::</span> <span class="dt">KotlinOptions</span> <span class="ot">-&gt;</span> <span class="dt">F.Req</span> <span class="dt">KotlinClass</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>
generateKotlinForRequest <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p><code>Doc</code> 型というのを使ってる． これは <a href="https://hackage.haskell.org/package/wl-pprint-text"><code>wl-pprint-text</code></a> というパッケージのモノで，直接文字列方を使うのではなく，この <code>Doc</code> 型を使うことでインデントなどをいい感じにしてくれる．</p>
<h2 id="section-7"></h2>
<p>Elm との違いは，最終的な出力をいじる所． Elm (や Haskell) はトップレベルのインデント(関数や型定義)は揃ってるので，そのままでいいのだが，OOP 言語はクラスにラップする必要があるのでめんどくさい．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generateKotlinForAPIClass ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
generateKotlinForAPIClass className body <span class="fu">=</span> mconcat
  [ [ docToText <span class="fu">$</span> <span class="st">&quot;class&quot;</span> <span class="fu">&lt;+&gt;</span> textStrict className <span class="fu">&lt;&gt;</span> <span class="st">&quot;(private val baseURL: String) {&quot;</span> ]
  , fmap (docToText <span class="fu">.</span> vsep <span class="fu">.</span> fmap (indent indentNum <span class="fu">.</span> textStrict) <span class="fu">.</span> T.lines) body
  , [ <span class="st">&quot;}&quot;</span> ]
  ]</code></pre></div>
<p>めんどくさかったので，一度 <code>Doc</code> 型に戻してからインデントをそろえて，<code>Text</code> 型に直して返している(効率悪そう…)．</p>
<h3 id="ファイルへ出力">ファイルへ出力</h3>
<p>最後にファイルへ出力する部分を書く． <code>Spec</code> という名前はどうかと思うんだけど…(<code>elm-export</code> がそうしてる)．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Spec</span> <span class="fu">=</span> <span class="dt">Spec</span>
  {<span class="ot"> namespace    ::</span> [<span class="dt">Text</span>]
  ,<span class="ot"> filename     ::</span> <span class="dt">Text</span>
  ,<span class="ot"> declarations ::</span> [<span class="dt">Text</span>]
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>というの定義して，この内容から出力している． <code>declarations</code> というのが，<code>generateKotlinForAPIClass</code> 関数などで出力した値を渡す．</p>
<h2 id="完成">完成</h2>
<p>こんな風な <code>Main</code> を書くと生成できる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">spec ::</span> <span class="dt">Spec</span>
spec <span class="fu">=</span> <span class="dt">Spec</span> [<span class="st">&quot;com&quot;</span>, <span class="st">&quot;github&quot;</span>, <span class="st">&quot;matsubara0507&quot;</span>] <span class="st">&quot;TodoAPI&quot;</span> <span class="fu">$</span> mconcat
  [ [ defKotlinImports ]
  , generateKotlinForAPIClass <span class="st">&quot;TodoAPI&quot;</span> <span class="fu">$</span> mconcat
      [ generateKotlinForDefDataClass (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Todo</span>)
      , generateKotlinForAPI (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">CRUD</span>)
      ]
  ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  specsToDir [spec] <span class="st">&quot;example/src/main/java&quot;</span></code></pre></div>
<h3 id="stackage">Stackage</h3>
<p>出来上がったので</p>
<ol style="list-style-type: decimal">
<li>PVP (依存パッケージのバージョン)を適当に指定して</li>
<li>Hackage にアップロードして</li>
<li><code>servant-elm</code> を参考にして<a href="https://github.com/matsubara0507/servant-kotlin/blob/f08e3e2ae237a1c8a4931204c26bc83f03ea0e67/test/Servant/Kotlin/Internal/GenerateSpec.hs">テストを追加</a>し</li>
<li>Stackage に <a href="https://github.com/fpco/stackage/pull/2987">PR</a> を出して</li>
</ol>
<p>無事 Stack の <a href="https://www.stackage.org/nightly-2017-10-28/package/servant-kotlin-0.1.0.0">Nightly</a> に登録された！</p>
<h3 id="サンプル">サンプル</h3>
<p>ちなみに，サンプルは GitHub にあげてある．</p>
<p>この <a href="https://github.com/matsubara0507/servant-kotlin/blob/f08e3e2ae237a1c8a4931204c26bc83f03ea0e67/example/Generater.hs">Haskell コード</a>から，この <a href="https://github.com/matsubara0507/servant-kotlin/blob/f08e3e2ae237a1c8a4931204c26bc83f03ea0e67/example/src/main/java/com/github/matsubara0507/TodoAPI.kt">Kotlin コード</a>を生成する．</p>
<h2 id="おしまい">おしまい</h2>
<p>Generics は使ってみると，意外と分かりやすいですね． ただ，これでいいんだろうか…という不安は付いて回りますが(笑)</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
