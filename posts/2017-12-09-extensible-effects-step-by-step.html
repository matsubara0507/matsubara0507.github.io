<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html lang="ja">

  <head>
  <meta charset="utf-8">
  <link rel="icon" href="../assets/icon.jpg">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
    
      <meta property="og:title" content="Extensible Effects ステップ・バイ・ステップ" />
    
  

  <meta property="og:site_name" content="ひげメモ" />

  

  
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86386380-1', 'auto');
  ga('send', 'pageview');
</script>

  

  <title>
    
      
        Extensible Effects ステップ・バイ・ステップ
      
    
  </title>

  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/highlight.css">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
</head>


  <body>
      <div class="outer">

        <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://matsubara0507.github.io/">ひげメモ</a>

  </div>

  <div class="header-badge">
    <a href="https://matsubara0507.github.io/">
        <img src="../assets/icon.jpg" />
    </a>
  </div>

</header>


        <div class="page-content">
          <div class="wrapper">
            <article class="post card" itemscope itemtype="http://schema.org/BlogPosting">
 <div class="card-content">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Extensible Effects ステップ・バイ・ステップ</h1>
    <p class="post-meta">
      <time datetime="2017-12-09" itemprop="datePublished">
        Dec 9, 2017
      </time>
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://qiita.com/advent-calendar/2017/haskell">Haskell アドベントカレンダー (その１)</a>の9日目の記事です． Backpack の話の予定でしたが，先にこっちが書けたので<a href="https://qiita.com/advent-calendar/2017/haskell3">その３</a>のと入れ替えました． 複数とっておくとこういうことが出来るよね(いいの？)．</p>
<h2 id="section"></h2>
<p>さて本題． タイトルからお察しの通り，以下の記事のオマージュです．</p>
<ul>
<li><a href="http://bicycle1885.hatenablog.com/entry/2012/12/08/165236">モナドトランスフォーマー・ステップ・バイ・ステップ(Monad Transformers Step By Step) - りんごがでている</a></li>
</ul>
<h2 id="いきさつ">いきさつ</h2>
<p>最近アルバイトで，モナドトランスフォーマーの代わりに<a href="https://hackage.haskell.org/package/extensible">extensible</a> パッケージの extensible effects でモナドスタックを作ってました． (理論的な部分は置いておいて)使い方の部分は概ね分かったので記事にしたいと思い，昔々にモナドトランスフォーマーでお世話になった上の記事を extensible effects で追ってみようと思ったわけです．</p>
<p>なので，extensible effects に関する Haskell のパッケージはいくつかあるんですが，<strong>今回は <a href="https://hackage.haskell.org/package/extensible">extensible</a> パッケージを使います</strong>．</p>
<h3 id="extensible-effects">Extensible Effects</h3>
<p>とは何かについては特に言及しません． <a href="http://fumieval.hatenablog.com/entry/2017/08/02/230422">extensible の作者さんの記事</a>やググるなりしてください．</p>
<h2 id="概要">概要</h2>
<p>上述した記事を参考にして，extensible effects によるモナドスタックをステップバイステップに構築してみる． 最終的には， エラー処理(<code>Either</code>)，環境渡し(<code>Reader</code>)，状態(<code>State</code>)，ログ(<code>Writer</code>)，入出力(<code>IO</code>)といった機能をモナドスタックに積む．</p>
<p>ちなみに，モナドトランスフォーマーと extensible effects を比較したりは基本的にしない． そもそも，オリジナルなモナドを導入しない限りは(パフォーマンス以外に)大きな差は生まれないと思う(たぶん)．</p>
<h2 id="section-1"></h2>
<p>あと，必要なモジュールについては基本的に省く． (おまけを除く)全てのコードは以下のリポジトリに置いたので適宜参照してください．</p>
<ul>
<li><a href="https://github.com/matsubara0507/extensible-effexts-step-by-step">matsubara0507/extensible-effexts-step-by-step</a></li>
</ul>
<h3 id="step-0.-イントロダクション">Step 0. イントロダクション</h3>
<p>とりあえず，実行するプログラムの例だけ示しておく． モナドトランスフォーマーの記事と同じようにシンプルなプログラミング言語(？)のインタープリタを使う．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span>   <span class="fu">=</span> <span class="dt">String</span>                <span class="co">-- variable names</span>
<span class="kw">data</span> <span class="dt">Exp</span>    <span class="fu">=</span> <span class="dt">Lit</span> <span class="dt">Integer</span>           <span class="co">-- expressions</span>
            <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Name</span>
            <span class="fu">|</span> <span class="dt">Plus</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
            <span class="fu">|</span> <span class="dt">Abs</span> <span class="dt">Name</span> <span class="dt">Exp</span>
            <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
            <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="kw">data</span> <span class="dt">Value</span>  <span class="fu">=</span> <span class="dt">IntVal</span> <span class="dt">Integer</span>        <span class="co">-- values</span>
            <span class="fu">|</span> <span class="dt">FunVal</span> <span class="dt">Env</span> <span class="dt">Name</span> <span class="dt">Exp</span>
            <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="kw">type</span> <span class="dt">Env</span>    <span class="fu">=</span> <span class="dt">Map.Map</span> <span class="dt">Name</span> <span class="dt">Value</span>    <span class="co">-- mapping from names to values</span>

<span class="ot">eval0 ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval0 env (<span class="dt">Lit</span> i)       <span class="fu">=</span> <span class="dt">IntVal</span> i
eval0 env (<span class="dt">Var</span> n)       <span class="fu">=</span> fromJust (Map.lookup n env)
eval0 env (<span class="dt">Plus</span> e1 e2)  <span class="fu">=</span>
    <span class="kw">let</span>
        <span class="dt">IntVal</span> i1 <span class="fu">=</span> eval0 env e1
        <span class="dt">IntVal</span> i2 <span class="fu">=</span> eval0 env e2
    <span class="kw">in</span>  
        <span class="dt">IntVal</span> (i1 <span class="fu">+</span> i2)
eval0 env (<span class="dt">Abs</span> n e)     <span class="fu">=</span> <span class="dt">FunVal</span> env n e
eval0 env (<span class="dt">App</span> e1 e2)   <span class="fu">=</span>
    <span class="kw">let</span>
        val1 <span class="fu">=</span> eval0 env e1
        val2 <span class="fu">=</span> eval0 env e2
    <span class="kw">in</span>
        <span class="kw">case</span> val1 <span class="kw">of</span>
            <span class="dt">FunVal</span> env' n body <span class="ot">-&gt;</span> eval0 (Map.insert n val2 env') body</code></pre></div>
<p>評価関数 <code>eval0</code> をステップバイステップに拡張していくといった感じ． <code>let ... in</code> の辺りとか冗長な気もするが，モナドを導入したときに変更が楽になるようにこう書かれている．</p>
<p>これを実行するには ghci で以下のように書けばよい．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> exampleExp <span class="fu">=</span> <span class="dt">Lit</span> <span class="dv">12</span> <span class="ot">`Plus`</span> (<span class="dt">App</span> (<span class="dt">Abs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Lit</span> <span class="dv">4</span> <span class="ot">`Plus`</span> <span class="dt">Lit</span> <span class="dv">2</span>))
<span class="fu">&gt;</span> eval0 Map.empty exampleExp
<span class="dt">IntVal</span> <span class="dv">18</span></code></pre></div>
<p>ちなみに，<code>exampleExp</code> は <code>12 + ((λx -&gt; x) (4+2))</code> という式を表現している．</p>
<h3 id="step-1.-モナドスタイルに">Step 1. モナドスタイルに</h3>
<p>まずはモナドスタイルに変更する． 本来であれば，<code>Identity</code> モナドを使えばよいのだが，今回は次のように書き換えた．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>

<span class="kw">type</span> <span class="dt">Eval1</span> a <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">'[] a</span>

<span class="ot">runEval1 ::</span> <span class="dt">Eval1</span> a <span class="ot">-&gt;</span> a
runEval1 ev <span class="fu">=</span> leaveEff ev</code></pre></div>
<p>extensible ではモナドを型レベルリスト <code>'[]</code> に入れていくことで，モナドスタックを表現する． なので，空にしてしまえばなにも積まれていないモナドの完成である(<a href="https://hackage.haskell.org/package/extensible-0.4.6/docs/Data-Extensible-Effect.html#t:Eff"><code>Eff xs</code></a> が <code>Monad</code> のインスタンスになっている)．</p>
<p>そして <code>eval0</code> もモナドスタイルに書き直す(<code>eval1</code> とする)．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval1 ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Eval1</span> <span class="dt">Value</span>
eval1 env (<span class="dt">Lit</span> i)       <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">IntVal</span> i
eval1 env (<span class="dt">Var</span> n)       <span class="fu">=</span>
    maybe (fail (<span class="st">&quot;undefined variable: &quot;</span> <span class="fu">++</span> n)) return <span class="fu">$</span> Map.lookup n env
eval1 env (<span class="dt">Plus</span> e1 e2)  <span class="fu">=</span> <span class="kw">do</span>
    <span class="dt">IntVal</span> i1 <span class="ot">&lt;-</span> eval1 env e1
    <span class="dt">IntVal</span> i2 <span class="ot">&lt;-</span> eval1 env e2
    return <span class="fu">$</span> <span class="dt">IntVal</span> (i1 <span class="fu">+</span> i2)
eval1 env (<span class="dt">Abs</span> n e)     <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">FunVal</span> env n e
eval1 env (<span class="dt">App</span> e1 e2)   <span class="fu">=</span> <span class="kw">do</span>
    val1 <span class="ot">&lt;-</span> eval1 env e1
    val2 <span class="ot">&lt;-</span> eval1 env e2
    <span class="kw">case</span> val1 <span class="kw">of</span>
      <span class="dt">FunVal</span> env' n body <span class="ot">-&gt;</span> eval1 (Map.insert n val2 env') body</code></pre></div>
<p>無駄に <code>return</code> とバインドを呼んでるだけ． ちなみに，この <code>eval1</code> 関数はモナドトランスフォーマーのモノと何ら変わらない．</p>
<p>ghci で試すには次のようにする(<code>exampleExp</code> は前と同じ)．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> runEval1 <span class="fu">$</span> eval1 Map.empty exampleExp
<span class="dt">IntVal</span> <span class="dv">18</span></code></pre></div>
<h3 id="step-2.-エラー処理を加える">Step 2. エラー処理を加える</h3>
<p>さて，ここからが楽しくなってくる． エラー処理を加えるために <code>Either e</code> モナドをモナドスタックに積もう．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">type</span> <span class="dt">Eval2</span> a <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">'[ &quot;Either&quot; &gt;: Either String ] a</span>

<span class="ot">runEval2 ::</span> <span class="dt">Eval2</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a
runEval2 ev <span class="fu">=</span> retractEff ev</code></pre></div>
<p><code>(&gt;:)</code> 型演算子を使って，モナドの Key (ここでいう <code>&quot;Either&quot;</code>)と積みたいモナドの，いわゆるタプルを作る． モナドスタックを表現する型レベルリストは，モナドの型を要素に持つのではなく，モナドの型とその Key のタプルを持つのだ．</p>
<p>さて，これに合わせて <code>eval1</code> 関数も書き換える．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval2 ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Eval2</span> <span class="dt">Value</span>
eval2 env (<span class="dt">Lit</span> i)       <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">IntVal</span> i
eval2 env (<span class="dt">Var</span> n)       <span class="fu">=</span>
    <span class="kw">case</span> Map.lookup n env <span class="kw">of</span>
        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> throwError (<span class="st">&quot;unbound variable: &quot;</span> <span class="ot">`mappend`</span> n)
        <span class="dt">Just</span> val <span class="ot">-&gt;</span> return val
eval2 env (<span class="dt">Plus</span> e1 e2)  <span class="fu">=</span> <span class="kw">do</span>
    e1' <span class="ot">&lt;-</span> eval2 env e1
    e2' <span class="ot">&lt;-</span> eval2 env e2
    <span class="kw">case</span> (e1', e2') <span class="kw">of</span>
        (<span class="dt">IntVal</span> i1, <span class="dt">IntVal</span> i2) <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">IntVal</span> (i1 <span class="fu">+</span> i2)
        _                      <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in addition&quot;</span>
eval2 env (<span class="dt">Abs</span> n e)     <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">FunVal</span> env n e
eval2 env (<span class="dt">App</span> e1 e2)   <span class="fu">=</span> <span class="kw">do</span>
    val1 <span class="ot">&lt;-</span> eval2 env e1
    val2 <span class="ot">&lt;-</span> eval2 env e2
    <span class="kw">case</span> val1 <span class="kw">of</span>
        <span class="dt">FunVal</span> env' n body <span class="ot">-&gt;</span> eval2 (Map.insert n val2 env') body
        _                  <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in application&quot;</span>

<span class="ot">throwError ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eval2</span> a
throwError err <span class="fu">=</span> liftEff (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="st">&quot;Either&quot;</span>) <span class="fu">$</span> <span class="dt">Left</span> err</code></pre></div>
<p>実はモナドトランスフォーマーのモノと全く同じ． 但し，<code>MonadError</code> 型クラスの<code>throwError</code> 関数は呼べないので(<code>Eval2</code> はインスタンスではない)，代わりに自分で定義した．</p>
<p><a href="https://hackage.haskell.org/package/extensible-0.4.6/docs/Data-Extensible-Effect.html#v:liftEff"><code>liftEff</code></a> 関数で持ち上げてやる． ただし，どこに持ち上げればいいかを明示してやるために，<code>Proxy :: Proxy &quot;Either&quot;</code> を引数として与えている． どこに持ち上げるかは，この <code>Proxy</code> で指定するので，例えばモナドスタックがどんどん積まれて行っても，<code>lift</code> を何回も呼び出す必要は全くない．</p>
<p>ghci で実行してみる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> runEval2 <span class="fu">$</span> eval2 Map.empty exampleExp
<span class="dt">Right</span> (<span class="dt">IntVal</span> <span class="dv">18</span>)
<span class="fu">&gt;</span> runEval2 <span class="fu">$</span> eval2 Map.empty (<span class="dt">Plus</span> (<span class="dt">Lit</span> <span class="dv">1</span>) (<span class="dt">Abs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))
<span class="dt">Left</span> <span class="st">&quot;type error in addition&quot;</span>
<span class="fu">&gt;</span> runEval2 <span class="fu">$</span> eval2 Map.empty (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)
<span class="dt">Left</span> <span class="st">&quot;unbound variable: x&quot;</span></code></pre></div>
<h4 id="組込みのモナドを使う">組込みのモナドを使う</h4>
<p>実は，extensible にはいくつかのモナドが extensible effects 用に用意されている． <code>Either</code> の場合は <a href="https://hackage.haskell.org/package/extensible-0.4.6/docs/Data-Extensible-Effect.html#t:EitherEff"><code>EitherEff</code></a> を使う．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Eval2</span> a <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">'[ &quot;Either&quot; &gt;: EitherEff String ] a</span>

<span class="ot">throwError ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eval2</span> a
throwError err <span class="fu">=</span> throwEff (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="st">&quot;Either&quot;</span>) err

<span class="ot">runEval2 ::</span> <span class="dt">Eval2</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a
runEval2 ev <span class="fu">=</span> leaveEff <span class="fu">$</span> runEitherEff ev</code></pre></div>
<p>現状だとあまりありがたみは無いが，2つ以上のモナドを積んだときに <code>runEval2</code> を書くのが非常に楽になる． というか，2つより上にある <code>run</code> 系の関数を自分で定義するのは大変なのだ．</p>
<h4 id="monaderror-を使う"><code>MonadError</code> を使う</h4>
<p>実は，<a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html#t:MonadError"><code>MonadError</code></a> のインスタンスも用意してある． <code>EitherEff</code> の代わりに <a href="https://hackage.haskell.org/package/extensible-0.4.6/docs/Data-Extensible-Effect-Default.html#t:EitherDef"><code>EitherDef</code></a> を使えば良い．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Eval2</span> a <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">'[ EitherDef String ] a</span>

<span class="ot">runEval2 ::</span> <span class="dt">Eval2</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a
runEval2 ev <span class="fu">=</span> leaveEff <span class="fu">$</span> runEitherDef ev</code></pre></div>
<p><code>throwError</code> は <code>MonadError</code> 型クラスのを使うのでもう要らない．</p>
<p>注意点として，<code>EitherDef</code> が定義されている <code>Data.Extensible.Effect.Default</code> モジュールは，大本のモジュールである <code>Data.Extensible</code> にエクスポートされていないので，別途インポートする必要がある． おそらく，<code>MonadError</code> のインスタンス宣言が広範囲に影響するのを懸念してだろう(<code>Eff xs</code> 全部に影響しているので)．</p>
<h2 id="section-2"></h2>
<p>また，以降は <code>Data.Extensible.Effect.Default</code> モジュールにあるモナド型をスタックに積んでいくことにする．</p>
<h3 id="step-3.-環境を隠す">Step 3. 環境を隠す</h3>
<p><code>eval2</code> 関数では，環境 <code>Env</code> を明示的に引数としていて渡しているが，これを <code>Reader r</code> モナドを使って隠蔽する． <code>Reader r</code> モナドの <code>Eff</code> 版として <a href="https://hackage.haskell.org/package/extensible-0.4.6/docs/Data-Extensible-Effect-Default.html#t:ReaderDef"><code>ReaderDef</code></a> を用いる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Eval3</span> a <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">'[ ReaderDef Env, EitherDef String ] a</span>

<span class="ot">runEval3 ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Eval3</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a
runEval3 env ev <span class="fu">=</span> leaveEff <span class="fu">.</span> runEitherDef <span class="fu">.</span> flip runReaderDef env <span class="fu">$</span> ev</code></pre></div>
<p>既に，<code>MonadReader</code> の型クラスのインスタンスになっているので <code>ask</code> 関数や <code>loacal</code> 関数を利用できる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval3 ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Eval3</span> <span class="dt">Value</span>
eval3 (<span class="dt">Lit</span> i)       <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">IntVal</span> i
eval3 (<span class="dt">Var</span> n)       <span class="fu">=</span> <span class="kw">do</span>
    env <span class="ot">&lt;-</span> ask
    <span class="kw">case</span> Map.lookup n env <span class="kw">of</span>
        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> throwError (<span class="st">&quot;unbound variable: &quot;</span> <span class="ot">`mappend`</span> n)
        <span class="dt">Just</span> val <span class="ot">-&gt;</span> return val
eval3 (<span class="dt">Plus</span> e1 e2)  <span class="fu">=</span> <span class="kw">do</span>
    e1' <span class="ot">&lt;-</span> eval3 e1
    e2' <span class="ot">&lt;-</span> eval3 e2
    <span class="kw">case</span> (e1', e2') <span class="kw">of</span>
        (<span class="dt">IntVal</span> i1, <span class="dt">IntVal</span> i2) <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">IntVal</span> (i1 <span class="fu">+</span> i2)
        _                      <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in addition&quot;</span>
eval3 (<span class="dt">Abs</span> n e)     <span class="fu">=</span> <span class="kw">do</span>
    env <span class="ot">&lt;-</span> ask
    return <span class="fu">$</span> <span class="dt">FunVal</span> env n e
eval3 (<span class="dt">App</span> e1 e2)   <span class="fu">=</span> <span class="kw">do</span>
    val1 <span class="ot">&lt;-</span> eval3 e1
    val2 <span class="ot">&lt;-</span> eval3 e2
    <span class="kw">case</span> val1 <span class="kw">of</span>
        <span class="dt">FunVal</span> env' n body <span class="ot">-&gt;</span>
            local (const (Map.insert n val2 env')) (eval3 body)
        _                  <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in application&quot;</span></code></pre></div>
<p><code>eval3 (Var n)</code> と <code>eval3 (Abs n e)</code> の最初に <code>ask</code> を使って環境を参照している． また <code>eval3 (App e1 e2)</code> の最後に，<code>local</code> 関数で変数に値を束縛した環境で更新している．</p>
<h3 id="step-4.-状態を加える">Step 4. 状態を加える</h3>
<p>簡約回数を状態として引き回してみる． 状態を引き回すには <code>State s</code> モナドを使う． わざわざ説明することではないが，<code>State s a</code> は <code>s -&gt; (a, s)</code> と同義である．</p>
<p><code>State s</code> モナドの <code>Eff</code> 版として <a href="https://hackage.haskell.org/package/extensible-0.4.6/docs/Data-Extensible-Effect-Default.html#t:StateDef"><code>StateDef</code></a> を用いる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Eval4</span> a <span class="fu">=</span>
    <span class="dt">Eff</span> <span class="ch">'[ ReaderDef Env, EitherDef String, StateDef Integer ] a</span>

<span class="ot">runEval4 ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Eval4</span> a <span class="ot">-&gt;</span> (<span class="dt">Either</span> <span class="dt">String</span> a, <span class="dt">Integer</span>)
runEval4 env st ev <span class="fu">=</span>
    leaveEff <span class="fu">.</span> flip runStateDef st <span class="fu">.</span> runEitherDef <span class="fu">.</span> flip runReaderDef env <span class="fu">$</span> ev</code></pre></div>
<p>(モナドトランスフォーマーの記事でも書いてあるように) <code>Either</code> や <code>State</code> のような <strong>最終的な結果に影響を与えるモナドを組み合わせる場合には順番が重要になってくる</strong>． 今回は <code>Either</code> の外に <code>State</code> を置きたいので，<code>(Either String a, Integer)</code> となるようにモナドスタックを積んだ． <code>Eff</code> の場合は型レベルリストの左から剥がしていき，剥がした結果を右に渡すイメージなので注意してください(要するに左畳み込み？)．</p>
<p><code>eval3</code> 関数は以下のように書き換える．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tick ::</span> (<span class="dt">Num</span> s, <span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> m ()
tick <span class="fu">=</span> <span class="kw">do</span>
    st <span class="ot">&lt;-</span> get
    put (st <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">eval4 ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Eval4</span> <span class="dt">Value</span>
eval4 (<span class="dt">Lit</span> i)       <span class="fu">=</span> <span class="kw">do</span>
    tick
    return <span class="fu">$</span> <span class="dt">IntVal</span> i
eval4 (<span class="dt">Var</span> n)       <span class="fu">=</span> <span class="kw">do</span>
    tick
    env <span class="ot">&lt;-</span> ask
    <span class="kw">case</span> Map.lookup n env <span class="kw">of</span>
        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> throwError (<span class="st">&quot;unbound variable: &quot;</span> <span class="ot">`mappend`</span> n)
        <span class="dt">Just</span> val <span class="ot">-&gt;</span> return val
eval4 (<span class="dt">Plus</span> e1 e2)  <span class="fu">=</span> <span class="kw">do</span>
    tick
    e1' <span class="ot">&lt;-</span> eval4 e1
    e2' <span class="ot">&lt;-</span> eval4 e2
    <span class="kw">case</span> (e1', e2') <span class="kw">of</span>
        (<span class="dt">IntVal</span> i1, <span class="dt">IntVal</span> i2) <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">IntVal</span> (i1 <span class="fu">+</span> i2)
        _                      <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in addition&quot;</span>
eval4 (<span class="dt">Abs</span> n e)     <span class="fu">=</span> <span class="kw">do</span>
    tick
    env <span class="ot">&lt;-</span> ask
    return <span class="fu">$</span> <span class="dt">FunVal</span> env n e
eval4 (<span class="dt">App</span> e1 e2)   <span class="fu">=</span> <span class="kw">do</span>
    tick
    val1 <span class="ot">&lt;-</span> eval4 e1
    val2 <span class="ot">&lt;-</span> eval4 e2
    <span class="kw">case</span> val1 <span class="kw">of</span>
        <span class="dt">FunVal</span> env' n body <span class="ot">-&gt;</span>
            local (const (Map.insert n val2 env')) (eval4 body)
        _                  <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in application&quot;</span></code></pre></div>
<p>ghci の結果は次のようになる．</p>
<pre><code>&gt; runEval4 Map.empty 0 $ eval4 exampleExp
(Right (IntVal 18),8)</code></pre>
<h3 id="step-5.-ログを加える">Step 5. ログを加える</h3>
<p>ログとしてモナドスタックに <code>Writer w</code> モナドを積む． <code>Writer w</code> モナドの <code>Eff</code> 版として <code>WriterDef</code> を使う． <code>State</code> のときと同様に，最後に影響を与えるモナドなので，積む順番に注意が必要だ．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Eval5</span> a <span class="fu">=</span>
    <span class="dt">Eff</span> <span class="ch">'[ ReaderDef Env, EitherDef String, WriterDef [String], StateDef Integer ] a</span>

<span class="ot">runEval5 ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Eval5</span> a <span class="ot">-&gt;</span> ((<span class="dt">Either</span> <span class="dt">String</span> a, [<span class="dt">String</span>]), <span class="dt">Integer</span>)
runEval5 env st ev <span class="fu">=</span>
    leaveEff <span class="fu">.</span> flip runStateDef st <span class="fu">.</span> runWriterDef <span class="fu">.</span> runEitherDef <span class="fu">.</span> flip runReaderDef env <span class="fu">$</span> ev</code></pre></div>
<p>ちなみに，<code>Writer w</code> の <code>w</code> は <code>Monoid</code> 型クラスのインスタンスである必要がある．</p>
<p>ほぼほぼ意味は無いんだけど，今回は評価中に遭遇した変数名を書き出すというログをとることにする．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval5 ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Eval5</span> <span class="dt">Value</span>
eval5 (<span class="dt">Lit</span> i)       <span class="fu">=</span> <span class="kw">do</span>
    tick
    return <span class="fu">$</span> <span class="dt">IntVal</span> i
eval5 (<span class="dt">Var</span> n)       <span class="fu">=</span> <span class="kw">do</span>
    tick
    tell [n]
    env <span class="ot">&lt;-</span> ask
    <span class="kw">case</span> Map.lookup n env <span class="kw">of</span>
        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> throwError (<span class="st">&quot;unbound variable: &quot;</span> <span class="ot">`mappend`</span> n)
        <span class="dt">Just</span> val <span class="ot">-&gt;</span> return val
eval5 (<span class="dt">Plus</span> e1 e2)  <span class="fu">=</span> <span class="kw">do</span>
    tick
    e1' <span class="ot">&lt;-</span> eval5 e1
    e2' <span class="ot">&lt;-</span> eval5 e2
    <span class="kw">case</span> (e1', e2') <span class="kw">of</span>
        (<span class="dt">IntVal</span> i1, <span class="dt">IntVal</span> i2) <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">IntVal</span> (i1 <span class="fu">+</span> i2)
        _                      <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in addition&quot;</span>
eval5 (<span class="dt">Abs</span> n e)     <span class="fu">=</span> <span class="kw">do</span>
    tick
    env <span class="ot">&lt;-</span> ask
    return <span class="fu">$</span> <span class="dt">FunVal</span> env n e
eval5 (<span class="dt">App</span> e1 e2)   <span class="fu">=</span> <span class="kw">do</span>
    tick
    val1 <span class="ot">&lt;-</span> eval5 e1
    val2 <span class="ot">&lt;-</span> eval5 e2
    <span class="kw">case</span> val1 <span class="kw">of</span>
        <span class="dt">FunVal</span> env' n body <span class="ot">-&gt;</span>
            local (const (Map.insert n val2 env')) (eval5 body)
        _                  <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in application&quot;</span></code></pre></div>
<p><code>eval5 (Var n)</code> に <code>tell [n]</code> が追加されただけである(<code>tell</code> 関数は <code>Monoid</code> で合成して追記する)．</p>
<p>ghci で実行すると次のようになる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> runEval5 Map.empty <span class="dv">0</span> <span class="fu">$</span> eval5 exampleExp
((<span class="dt">Right</span> (<span class="dt">IntVal</span> <span class="dv">18</span>),[<span class="st">&quot;x&quot;</span>]),<span class="dv">8</span>)</code></pre></div>
<h3 id="step-6.-ioはどうすんの">Step 6. IOはどうすんの？</h3>
<p>さぁ最後は <code>IO</code> だ． 実は <code>IO</code> の <code>Eff</code> 版は用意されていない． しかし，<a href="https://hackage.haskell.org/package/extensible-0.4.6/docs/Data-Extensible-Effect-Default.html"><code>Data.Extensible.Effect.Default</code></a> モジュールの中を見てみると，一番下の <code>Orphan instances</code> のところに <code>MonadIO</code> もある． 定義より，次のようにすれば，<code>MonadIO</code> のインスタンスとなり <code>liftIO</code> が使えるようになる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Eval6</span> a <span class="fu">=</span>
    <span class="dt">Eff</span> <span class="ch">'[ ReaderDef Env, EitherDef String, WriterDef [String], StateDef Integer, &quot;IO&quot; &gt;: IO ] a</span>

<span class="ot">runEval6 ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Eval6</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ((<span class="dt">Either</span> <span class="dt">String</span> a, [<span class="dt">String</span>]), <span class="dt">Integer</span>)
runEval6 env st ev <span class="fu">=</span>
    retractEff <span class="fu">.</span> flip runStateDef st <span class="fu">.</span> runWriterDef <span class="fu">.</span> runEitherDef <span class="fu">.</span> flip runReaderDef env <span class="fu">$</span> ev</code></pre></div>
<p><code>runEval</code> の方は <code>leaveEff</code> から <code>retractEff</code> にしただけだ．</p>
<p>今回は次のようにいわゆる <code>printf</code> デバッグを <code>eval6 (Lit i)</code> のところに入れている．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval6 ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Eval6</span> <span class="dt">Value</span>
eval6 (<span class="dt">Lit</span> i)       <span class="fu">=</span> <span class="kw">do</span>
    tick
    liftIO <span class="fu">$</span> print i
    return <span class="fu">$</span> <span class="dt">IntVal</span> i
eval6 (<span class="dt">Var</span> n)       <span class="fu">=</span> <span class="kw">do</span>
    tick
    tell [n]
    env <span class="ot">&lt;-</span> ask
    <span class="kw">case</span> Map.lookup n env <span class="kw">of</span>
        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> throwError (<span class="st">&quot;unbound variable: &quot;</span> <span class="ot">`mappend`</span> n)
        <span class="dt">Just</span> val <span class="ot">-&gt;</span> return val
eval6 (<span class="dt">Plus</span> e1 e2)  <span class="fu">=</span> <span class="kw">do</span>
    tick
    e1' <span class="ot">&lt;-</span> eval6 e1
    e2' <span class="ot">&lt;-</span> eval6 e2
    <span class="kw">case</span> (e1', e2') <span class="kw">of</span>
        (<span class="dt">IntVal</span> i1, <span class="dt">IntVal</span> i2) <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">IntVal</span> (i1 <span class="fu">+</span> i2)
        _                      <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in addition&quot;</span>
eval6 (<span class="dt">Abs</span> n e)     <span class="fu">=</span> <span class="kw">do</span>
    tick
    env <span class="ot">&lt;-</span> ask
    return <span class="fu">$</span> <span class="dt">FunVal</span> env n e
eval6 (<span class="dt">App</span> e1 e2)   <span class="fu">=</span> <span class="kw">do</span>
    tick
    val1 <span class="ot">&lt;-</span> eval6 e1
    val2 <span class="ot">&lt;-</span> eval6 e2
    <span class="kw">case</span> val1 <span class="kw">of</span>
        <span class="dt">FunVal</span> env' n body <span class="ot">-&gt;</span>
            local (const (Map.insert n val2 env')) (eval6 body)
        _                  <span class="ot">-&gt;</span> throwError <span class="st">&quot;type error in application&quot;</span></code></pre></div>
<p>これを ghci で実行すると次のようになる．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> runEval6 Map.empty <span class="dv">0</span> <span class="fu">$</span> eval6 exampleExp
<span class="dv">12</span>
<span class="dv">4</span>
<span class="dv">2</span>
((<span class="dt">Right</span> (<span class="dt">IntVal</span> <span class="dv">18</span>),[<span class="st">&quot;x&quot;</span>]),<span class="dv">8</span>)</code></pre></div>
<h2 id="おまけ">おまけ</h2>
<p>組み合わせる前提のモナドはどうすれば良いだろうか？ 例えば，<a href="https://hackage.haskell.org/package/monad-logger">monad-logger</a> パッケージの <code>LoggingT</code> モナドとか(これは下に <code>IO</code> を持ってないといけない)．</p>
<p>実はぼくも良く分かっていない… が，とりあえず思いつく方法を書いておく．</p>
<h2 id="section-3"></h2>
<p>まずは <code>IO</code> を <code>LoggingT IO</code> に置き換える(ごちゃごちゃするので <code>IO</code> 以外は消した)．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">'[ &quot;Logger&quot; &gt;: LoggingT IO ] a</span>

<span class="ot">runEval ::</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
runEval <span class="fu">=</span> runStdoutLoggingT <span class="fu">.</span> retractEff</code></pre></div>
<p>こうすると <code>Data.Extensible.Effect.Default</code> の <code>MonadIO</code> のインスタンスは使えないので，自分で <code>liftIO</code> のような関数を定義する必要がある．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftIO' ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">MarketM</span> a
liftIO' <span class="fu">=</span> liftEff (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="st">&quot;Logger&quot;</span>) <span class="fu">.</span> liftIO</code></pre></div>
<p>ちなみに，<code>MonadIO</code> のインスタンスには <strong>できない</strong> ． 既に <code>Eff xs</code> の <code>MonadIO</code> のインスタンスは <code>Data.Extensible.Effect.Default</code> に定義してあるからだ(なのでコレをインポートしなければできるよ)．</p>
<h2 id="section-4"></h2>
<p>正直，これで十分だがどーしても共存させたい，ないしは <code>LoggingT</code> 以外の <code>IO</code> 前提のモナドと共存させたいときにはどうするか． イロイロ頑張って結果以下のようにできた．</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">'[ LoggerDef, &quot;IO&quot; &gt;: IO ] a</span>

<span class="ot">runEval ::</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
runEval <span class="fu">=</span> retractEff <span class="fu">.</span> runLoggerDef

<span class="kw">type</span> <span class="dt">LoggerDef</span> <span class="fu">=</span> <span class="st">&quot;Logger&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Logging</span>
<span class="kw">type</span> <span class="dt">Logging</span> <span class="fu">=</span> <span class="dt">LoggingT</span> <span class="dt">IO</span>

<span class="ot">runLoggerDef ::</span> (<span class="dt">MonadIO</span> (<span class="dt">Eff</span> xs)) <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">LoggerDef</span> <span class="ch">': xs) a -&gt; Eff xs a</span>
runLoggerDef <span class="fu">=</span> pealEff0 pure <span class="fu">$</span> \m k <span class="ot">-&gt;</span> k <span class="fu">=&lt;&lt;</span> liftIO (runStdoutLoggingT m)

<span class="kw">class</span> (<span class="dt">Associate</span> <span class="st">&quot;Logger&quot;</span> <span class="dt">Logging</span> xs) <span class="ot">=&gt;</span> <span class="dt">MonadLogger</span> (<span class="dt">Eff</span> xs) <span class="kw">where</span>
    monadLoggerLog loc ls level msg <span class="fu">=</span>
        liftEff (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="st">&quot;Logger&quot;</span>) <span class="fu">$</span> monadLoggerLog loc ls level msg</code></pre></div>
<p>重要なのは <code>runLoggerDef</code> の部分． (2つ目以上に積んだ extensible にないモナドは)こういった剥がす関数を自分で定義する必要があり，ここが一番難しい． 自分より下に <code>MonadIO</code> のインスタンス，ようするに <code>&quot;IO&quot; &gt;: IO</code> がある前提で，一度 IO にしてから，再度持ち上げるというずるいやり方をした．</p>
<p>いまいちパッとしないけど，これで一応目的のものはできる…</p>
<h2 id="おしまい">おしまい</h2>
<p><code>eval</code> 関数の実装はモナドトランスフォーマーのときと変わらないので，あんまり面白くなかったですね…すいません．</p>
  </div>
</div>
</article>

          </div>
        </div>

        <footer class="site-footer">

  <div class="wrapper">

    <span class="footer-heading">ひげメモ</span>

  </div>

  <div class="page-content card" style="display: flex; justify-content: center; padding: 5px 0px">
    <a href="https://haskell.jp/blog/posts/links.html#matsubara0507.github.io">
      <img width="234" src="https://haskell.jp/img/supported-by-haskell-jp.svg" alt="Supported By Haskell-jp.">
    </a>
  </div>

</footer>


      </div>
  </body>

</html>
